<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用mklink命令软连接Onedrive同步任意文件夹</title>
    <url>/2019/12/20/%E4%BD%BF%E7%94%A8mklink%E5%91%BD%E4%BB%A4%E8%BD%AF%E8%BF%9E%E6%8E%A5Onedrive%E5%90%8C%E6%AD%A5%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p>一般来说,想要让Onedrive将某个目录下的文件上传到云,得将对应的文件或者文件夹拷贝到Onedrive目录下,但是有时候却又不方便将文件挪动到Onedrive,例如D盘是仓库盘,存放着大量视频,但是Onedrive却在C盘,这个时候将视频移动到Onedrive会占用大量空间,并且本来D盘作为仓库盘就是用于存放资料的,现在挪动到C盘,影响文件规划.</p>
<p>所以可以使用mklink命令来在存放文件的目录和Onedrive目录中创建一个连接,让Onedrive识别到.</p>
<p>使用管理员权限打开CMD,输入以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mklink /J OneDrive文件夹下的目录绝对路径 需要链接到Onedrive的目录绝对路径</span><br></pre></td></tr></table></figure>

<p>即可.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>windows10</tag>
        <tag>Onedrive</tag>
      </tags>
  </entry>
  <entry>
    <title>326.3的幂</title>
    <url>/2019/07/02/326-3%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 27<br>输出: true</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 0<br>输出: false</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: 9<br>输出: true</p>
</blockquote>
<p>示例 4:</p>
<blockquote>
<p>输入: 45<br>输出: false</p>
</blockquote>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>3或者某个数的幂次方有两个特点:</p>
<ol>
<li>这个幂次方模3肯定为0.</li>
<li>这个幂次方除以3之后继续模3,也会为0,直到它最后变成1</li>
</ol>
<p>所以我们可以通过循环,只要这个数模3为0就将它除以3,然后继续循环,知道它最后结果为1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPowerOfThree</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>292.Nim游戏</title>
    <url>/2019/07/02/292-Nim%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<p>示例:</p>
<blockquote>
<p>输入: 4<br>输出: false<br>解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</p>
</blockquote>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据题目所说,我们每次可以拿1-3块,也就是说假设现在轮到我们的局面只剩1-3块,那我们必赢;但是如果轮到我们局面剩下4块,那我们必输,因为我们不管最后拿多少,肯定会剩下石头,让对手胜出,由此可见,在谁的回合中剩下4块石头,谁必输;另一方面,为了让对手回合有4块石头,我们的回合就一定得是5-7块石头,如果我们的回合有8块石头,那无论我们拿多少个石头,对方都能够逼迫我们下一回合拥有4块石头,所以我们也输了.</p>
<p>也就是说,只要我们的回合是4,8,12,16等等4的倍数块,那对手就总能够逼迫我们剩下四块,导致我们失败;另一方面,只要我们的回合不是4的倍数块,我们就能逼迫对手变成4的倍数块,从而赢得胜利.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">CanWinNim</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>283.移动零</title>
    <url>/2019/07/01/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<blockquote>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p>
</blockquote>
<p>说明:</p>
<ul>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ul>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然要求在原数组上操作,并且要尽量减少操作,那说明就应该在一趟扫描中解决问题.</p>
<p>题目想要的是将0移到数组末尾,一个思路是在一趟扫描中,只要遇到0,就用后面不是0的数覆盖到这个0,覆盖完了之后,将数组后面的数字都设置成0.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveZeroes</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">int</span> num <span class="keyword">in</span> nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[flag] = num;</span><br><span class="line">            flag += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = flag; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器设置时区</title>
    <url>/2019/06/28/docker%E5%AE%B9%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA/</url>
    <content><![CDATA[<p>docker容器中的时区一般来说都是使用<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6" target="_blank" rel="noopener">UTC</a>,但是中国的时区是使用<a href="https://zh.wikipedia.org/wiki/CST" target="_blank" rel="noopener">CST</a>,所以当使用某些需要依赖时间的服务时时间就会对不上,这时候就要修改容器的时区.</p>
<p>Debian和ubuntu类似但是稍微有点不同.</p>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>ubuntu镜像本身是没有安装一个叫tzdata的软件,这个软件可以帮我们设置时区,而且在首次安装后会自动帮我们设置已经指定了的时区,所以要做的有2步,在Dockerfile文件中添加以下命令,既可在原有的RUN指令之后添加,也可另起一行RUN,但必须在<strong>apt-get update</strong>命令之后:</p>
<a id="more"></a>

<ol>
<li><p>设置<code>/etc/localtime</code>文件的内容为我们需要的时区.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装tzdata软件.这时候软件首次安装会自动帮我们设置第一步已经指定的时区.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y tzdata</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>生成镜像后可以在容器终端输入date查看时间.</p>
<h2 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h2><p>Debian与Ubuntu不同,它本身已经安装了tzdata软件,所以并不能像Ubuntu那样在首次安装之后自动帮我们设置时区,而要手动使用命令重新配置,步骤如下,在Dockerfile文件中添加以下命令,所有以RUN开头的命令,既可在原有的RUN指令之后添加,也可另起一行RUN.</p>
<ol>
<li><p>首先检查Dockerfile的起始部分中是否有<code>ENV DEBIAN_FRONTEND=noninteractive</code>这一句,这一句命令是设置环境变量<code>DEBIAN_FRONTEND</code>的值为<code>noninteractive</code>,作用是让Debian前端命令设置为非交互式,这种模式下设置dpkg不需要人为手动输入选择操作而是自动配置,如果没有这一句,请先在文件中添加这一句.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=noninteractive</span><br></pre></td></tr></table></figure>
</li>
<li><p>与ubuntu一样,设置/etc/localtime文件的内容为我们需要的时区.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过非交互模式重新配置tzdata.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> dpkg-reconfigure -f noninteractive tzdata</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这个时候就已经设置完成了,但是要将前端命令从非交互式的重新设置为交互式的,所以要在Dockerfile的末尾添加一句命令:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=dialog</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>解决docker容器无法输入中文问题</title>
    <url>/2019/06/28/%E8%A7%A3%E5%86%B3docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一般情况下docker镜像产生的容器,都是无法直接在终端中输入中文的,因为docker镜像追求的就是最小化修改,没有必要的部分是不会进行添加与修改的.</p>
<p>虽然Debian和Ubuntu是爹和儿子,但是两者设置的方法略有不同.</p>
<p>总体的步骤就是:</p>
<ol>
<li>修改文件<strong>/etc/locale.gen</strong>,将需要的语言注释取消掉.</li>
<li>运行<strong>locale-gen</strong>命令.</li>
</ol>
<a id="more"></a>

<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>Ubuntu与debian不同的是Ubuntu仓库里有一个语言包,只要安装了语言包就会自动配置好<code>zh_CN.UTF-8</code>,所以我们要做的就是直接安装<strong>language-pack-zh-hans</strong></p>
<p>在Dockerfile文件中添加以下命令,所有以RUN开头的命令,既可在原有的RUN指令之后添加,也可另起一行RUN,但必须在<strong>apt-get update</strong>命令之后:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get -y install language-pack-zh-hans</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> LANG=<span class="string">'zh_CN.utf8'</span></span><br></pre></td></tr></table></figure>

<p>生成镜像后即可在终端输入中文.</p>
<h2 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h2><p>由于debian不仅没有语言包,连locales都没有安装,所以要先安装locales,然后通过<strong>sed</strong>将<strong>locale.gen</strong>文件的<strong>zh_CN.UTF-8</strong>前的注释去掉,并且运行locale-gen,安装zh_CN.UTF-8</p>
<p>在Dockerfile文件中添加以下命令,所有以RUN开头的命令,既可在原有的RUN指令之后添加,也可另起一行RUN,但必须在<strong>apt-get update</strong>命令之后:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y locales \</span></span><br><span class="line"><span class="bash">    &amp;&amp; sed -i <span class="string">'/^#.* zh_CN.UTF-8 /s/^#//'</span> /etc/locale.gen \</span></span><br><span class="line"><span class="bash">    &amp;&amp; locale-gen</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> LANG=<span class="string">'zh_CN.utf8'</span></span><br></pre></td></tr></table></figure>

<p>生成镜像后即可在终端输入中文.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode使用docker搭建hexo博客</title>
    <url>/2019/06/28/VSCode%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>随着vscode推出remote-container容器开发模式,在docker里面搭hexo变得简单了起来,非常方便,现在来记录一下vscode使用docker搭建hexo的步骤.</p>
<p>首先要知道待解决的问题有哪些:</p>
<ul>
<li>vscode的remote-container模式好在哪.</li>
<li>如何使用vscode调用docker生成一个镜像.</li>
<li>生成的镜像会有哪些问题.</li>
<li>安装hexo需要哪些东西.</li>
<li>要对Dockerfile进行什么修改才能让生成的容器本身就安装好hexo.</li>
</ul>
<a id="more"></a>

<h2 id="vscode的remote-container模式好在哪"><a href="#vscode的remote-container模式好在哪" class="headerlink" title="vscode的remote-container模式好在哪"></a>vscode的remote-container模式好在哪</h2><p>优点有3个:</p>
<ol>
<li>vscode的<code>remote-container</code>模式使得新手用户几乎不需要太多的手动干涉docker,即可开箱即用.只需安装对应的插件,并且安装了docker,即可成功地让vscode帮你完成大部分事情.</li>
<li>vscode还会将你本机的git配置与容器中的git进行关联,使得几乎可以直接在容器中使用<code>hexo d</code>命令将博客部署到GitHubPage而不需要任何设置.</li>
<li>不管你去到哪台电脑,只要这台电脑的vscode安装了这个插件和docker,就能自动识别到<code>.devcontainer</code>文件夹中的内容,然后<strong>自动帮你生成hexo镜像</strong>.</li>
</ol>
<h2 id="如何使用vscode调用docker生成一个hexo容器"><a href="#如何使用vscode调用docker生成一个hexo容器" class="headerlink" title="如何使用vscode调用docker生成一个hexo容器"></a>如何使用vscode调用docker生成一个hexo容器</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件:"></a>前提条件:</h3><ol>
<li><p>安装了<strong>vscode 1.35</strong>以上版本.</p>
</li>
<li><p>安装了<code>Remote Developmentm</code>插件.<img src="https://i.loli.net/2019/07/04/5d1dce8fb3c5d35149.png" alt=""></p>
</li>
<li><p>电脑已经安装了docker.</p>
</li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h3><ol>
<li><p>使用vscode打开你想要创建hexo博客的文件夹(这个文件夹既可以是新创建的文件夹,又可以是你以前就已经用hexo写过博客的文件夹),例如我这里的<strong>hexodocker</strong>空文件夹.<img src="https://i.loli.net/2019/07/04/5d1dcf7a3fe2e53998.png" alt=""></p>
</li>
<li><p>按F1,输入<code>remote</code>,在选项中选择<code>Open Folder in Container</code>,选择我们现在所在的这个hexodocker文件夹<img src="https://i.loli.net/2019/07/04/5d1dd01a72fce45611.png" alt=""></p>
</li>
<li><p>下一步vscode会让你选择你所需要的基础镜像,由于我们知道hexo是基于node.js的所以要找到node.js镜像<img src="https://i.loli.net/2019/07/04/5d1dd0dacffe353417.png" alt=""></p>
</li>
<li><p>选择完镜像,这时候vscode就会在你的这个目录下生成一个<code>.devcontainer</code>文件夹,这个文件夹有两个文件,一个是<code>devcontainer.json</code>,另一个是<code>Dockerfile</code>文件,vscode此时会依靠这两个文件,驱使docker生成新的镜像与容器.注意这时候生成镜像与容器所需的时间完全取决于你的电脑性能和网络性能,如果感觉vscode卡了很久都没用动,可以直接关闭vscode并且重新打开.<img src="https://i.loli.net/2019/07/04/5d1dd1c4e3c3670595.png" alt=""></p>
</li>
<li><p>一切完成之后,可以看到自动生成的Dockerfile的内容,并且docker已经按照这个文件创建了镜像与容器,而且已经自动将这个容器与我们当前的文件夹进行了一个挂载.</p>
<p>但是要注意的是,这个生成的镜像却并不是最终我们所需要的,因为这些内容只是vscode帮我们自动生成的,我们要对它进行修改.<img src="https://i.loli.net/2019/07/04/5d1dd578e2bca71189.png" alt=""></p>
</li>
</ol>
<h3 id="生成的镜像会有哪些问题"><a href="#生成的镜像会有哪些问题" class="headerlink" title="生成的镜像会有哪些问题"></a>生成的镜像会有哪些问题</h3><p>根据我爬过的坑,生成的镜像并不能直接使用,会有一些问题:</p>
<ol>
<li>容器内的默认时区是UTC,而中国的时区是CST,如果不把时区改过来,生成的文章时间是错误的.解决的方法请看我这一篇文章<a href="https://jiayaoo3o.github.io/2019/06/29/docker容器设置时区/">docker容器设置时区</a>.</li>
<li>容器默认是没有对中文进行处理的,所以直接通过镜像生成的容器是无法输入中文的,那当我们使用<code>hexo new &quot;文章标题&quot;</code> 包含中文的时候,会无法输入.解决方法请看我的这一篇文章<a href="https://jiayaoo3o.github.io/2019/06/29/解决docker容器无法输入中文问题/">解决docker容器无法输入中文问题</a>.</li>
</ol>
<h3 id="安装hexo需要哪些东西"><a href="#安装hexo需要哪些东西" class="headerlink" title="安装hexo需要哪些东西"></a>安装hexo需要哪些东西</h3><p>这里不会教你使用hexo的方方面面,这些东西去看网上的博客一搜一大把,我们只需要知道,安装hexo只需要在确保node.js环境正常的情况下输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure>

<p>即可安装,所以我们也要在dockerfile中配置这两句.</p>
<h3 id="要对Dockerfile进行什么修改"><a href="#要对Dockerfile进行什么修改" class="headerlink" title="要对Dockerfile进行什么修改"></a>要对Dockerfile进行什么修改</h3><p>接下来直接贴上Dockerfile文件,注意看注释,并且仔细对比哪些是自动生成的,哪些是人为添加的.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Copyright (c) Microsoft Corporation. All rights reserved.</span></span><br><span class="line"><span class="comment"># Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.</span></span><br><span class="line"><span class="comment">#-------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> node:lts</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure apt</span></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/deb.debian.org/mirrors.ustc.edu.cn/g'</span> /etc/apt/sources.list \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get -y install --no-install-recommends apt-utils 2&gt;&amp;1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify git and needed tools are installed</span></span><br><span class="line"><span class="comment"># 这一部分直接解决了时区问题和中文输入问题</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y git procps locales \</span></span><br><span class="line"><span class="bash">    &amp;&amp; sed -i <span class="string">'/^#.* zh_CN.UTF-8 /s/^#//'</span> /etc/locale.gen \</span></span><br><span class="line"><span class="bash">    &amp;&amp; locale-gen \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\</span></span><br><span class="line"><span class="bash">    &amp;&amp; dpkg-reconfigure -f noninteractive tzdata</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove outdated yarn from /opt and install via package </span></span><br><span class="line"><span class="comment"># so it can be easily updated via apt-get upgrade yarn</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> rm -rf /opt/yarn-* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -f /usr/<span class="built_in">local</span>/bin/yarn \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -f /usr/<span class="built_in">local</span>/bin/yarnpkg \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl apt-transport-https lsb-release \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -sS https://dl.yarnpkg.com/$(lsb_release -is | tr <span class="string">'[:upper:]'</span> <span class="string">'[:lower:]'</span>)/pubkey.gpg | apt-key add - 2&gt;/dev/null \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"deb https://dl.yarnpkg.com/<span class="variable">$(lsb_release -is | tr '[:upper:]' '[:lower:]')</span>/ stable main"</span> | tee /etc/apt/sources.list.d/yarn.list \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get -y install --no-install-recommends yarn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install eslint</span></span><br><span class="line"><span class="comment"># 这一部分负责安装hexo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install -g eslint \</span></span><br><span class="line"><span class="bash">    &amp;&amp; npm install -g hexo-cli \</span></span><br><span class="line"><span class="bash">    &amp;&amp; npm install hexo -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Clean up</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get autoremove -y \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get clean -y \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/* </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=dialog</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the default shell to bash instead of sh</span></span><br><span class="line"><span class="keyword">ENV</span> <span class="keyword">SHELL</span><span class="bash"> /bin/bash</span></span><br><span class="line"><span class="comment"># 这里负责设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> LANG=<span class="string">'zh_CN.utf8'</span></span><br></pre></td></tr></table></figure>

<p>修改完成之后,我们要继续按F1,然后找到<code>Rebuild Container</code>重新生成新容器,这个时候就会得到一个完全可用的hexo容器.<img src="https://i.loli.net/2019/07/04/5d1dda0281bac67071.png" alt=""></p>
<h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><p>这里与平时创建博客的方法就完全一致了,只要在终端中输入<code>hexo init</code>即可,而如果你以前就已经在这个文件夹里面使用<code>hexo init</code>初始化过,那建议删除<code>node_modules</code>文件夹,然后再在终端中输入<code>npm install</code>命令安装所有需要的模块.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>windows10下UWP应用使用系统代理</title>
    <url>/2019/06/28/windows10%E4%B8%8BUWP%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>由于UWP本身运行在沙盒中,默认情况下是不能直接访问localhost的,所以也就不能直接访问本机的代理服务,但是win10自身有一个叫CheckNetIsolation.exe 的命令行工具可以将uwp应用设置为使用代理.</p>
<h2 id="单独指定某个UWP应用可以代理"><a href="#单独指定某个UWP应用可以代理" class="headerlink" title="单独指定某个UWP应用可以代理"></a>单独指定某个UWP应用可以代理</h2><ol>
<li><p>通过Win+S在搜索框输入”注册表”来打开<strong>注册表编辑器</strong><img src="https://i.loli.net/2019/06/28/5d16280329cd127618.png" alt=""></p>
</li>
<li><p>在上图的蓝色框处,输入下面的地址:</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER<span class="symbol">\S</span>oftware<span class="symbol">\C</span>lasses<span class="symbol">\L</span>ocal Settings<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\A</span>ppContainer<span class="symbol">\M</span>appings</span><br></pre></td></tr></table></figure>

<p>就会定位到上图的位置,左边的的密密麻麻的都是电脑上UWP应用的SID值,而右边绿色框的DIsplayName就是你点击的某个uwp应用的名字,现在要做的就是慢慢按方向键下键,寻找你需要进行代理的uwp软件.</p>
</li>
<li><p>找到需要代理的软件之后,复制该软件红色框处的SID,然后在CMD中输入以下命令:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">CheckNetIsolation.exe loopbackexempt <span class="literal">-a</span> <span class="literal">-p</span>=UWP的SID</span><br></pre></td></tr></table></figure>

<p>就可以直接生效了.</p>
</li>
<li><p>如果需要取消代理,恢复原样,在CMD中输入以下命令:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">CheckNetIsolation.exe loopbackexempt <span class="literal">-d</span> <span class="literal">-p</span>=UWP的SID</span><br></pre></td></tr></table></figure>

<h2 id="对所有UWP应用设置可以代理"><a href="#对所有UWP应用设置可以代理" class="headerlink" title="对所有UWP应用设置可以代理"></a>对所有UWP应用设置可以代理</h2><p>从上面的方法可以知道,想要对某个uwp使用代理,就只要知道它的SID然后设置就可以了,现在想要对所有uwp进行设置,也就是只要知道所有uwp的SID.</p>
<p>在CMD中输入以下命令即可对所有UWP进行设置:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> /F <span class="string">"tokens=11 delims=\"</span> %p <span class="keyword">IN</span> (<span class="string">'REG QUERY "HKCU\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings"'</span>) <span class="keyword">DO</span> CheckNetIsolation.exe LoopbackExempt <span class="literal">-a</span> <span class="literal">-p</span>=%p</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>CapsLock键的AutoHotKey映射方案</title>
    <url>/2019/06/26/CapsLock%E9%94%AE%E7%9A%84AutoHotKey%E6%98%A0%E5%B0%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>CapsLock键,占着最好的位置,产出最低的贡献,所以很多人包括我都会选择将它映射成其他功能.<br>vim党喜欢将CapsLock键映射成esc,这样退出输入模式就会非常的轻松,但是我vim用得不多,所以更想要将它映射成ctrl键,并且由于vim的hjkl方向移动很好用,所以我也打算将CapsLock＋hjkl实现方向移动.</p>
<a id="more"></a>

<p>但是这里问题就出现了,如果直接将CapsLock–&gt;ctrl,那假设想要实现CapsLock＋hjkl方向移动,就意味着要将ctrl+hjkl进一步映射成左下右上,但是这样会发生冲突,因为ctrl+hjkl本身是有含义的,例如chrome下ctrl+h就是历史记录,如果修改了这个按键映射那就没法直接调出历史记录了.</p>
<p>所以,将CapsLock映射为ctrl,和hjkl实现方向移动,总是会产生冲突的.</p>
<p>但是我想到了一个完美的方法去解决这个问题,那就是将CapsLock键映射为右ctrl键,注意不是ctrl,而是右ctrl,这个操作就可以完美实现我需要的两个功能.</p>
<p>因为右手边的ctrl键隔得太远平时就很少用,所以将CapsLock–&gt;右ctrl的好处是,不会影响左ctrl与hjkl的组合功能.</p>
<p>例如,现在按住CapsLock+h,光标会往左边移动,但是按住左边的ctrl+h,仍然可以调出历史记录,并且CapsLock可以实现ctrl的全部功能,例如CapsLock+c,v复制粘贴功能仍然能够实现.</p>
<p>附上autohotkey脚本:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">SetCapsLockState, AlwaysOff </span><br><span class="line">CapsLock::RControl ;CapsLock映射右ctrl.</span><br><span class="line">#CapsLock::CapsLock ;win+CapsLock映射为CapsLock.</span><br><span class="line"></span><br><span class="line">&gt;^h::<span class="built_in">Send</span>, &#123;Left&#125; ;右ctrl+hjkl实现移动.</span><br><span class="line">&gt;^j::<span class="built_in">Send</span>, &#123;Down&#125;</span><br><span class="line">&gt;^k::<span class="built_in">Send</span>, &#123;Up&#125;</span><br><span class="line">&gt;^l::<span class="built_in">Send</span>, &#123;Right&#125;</span><br><span class="line"></span><br><span class="line">&gt;^+h::<span class="built_in">Send</span>, +&#123;Left&#125; ;右ctrl+shift+hjkl实现选定移动.</span><br><span class="line">&gt;^+j::<span class="built_in">Send</span>, +&#123;Down&#125;</span><br><span class="line">&gt;^+k::<span class="built_in">Send</span>, +&#123;Up&#125;</span><br><span class="line">&gt;^+l::<span class="built_in">Send</span>, +&#123;Right&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>autohotkey</tag>
      </tags>
  </entry>
  <entry>
    <title>linux安装docker</title>
    <url>/2019/06/26/linux%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<h2 id="不要直接安装apt仓库内的docker-io"><a href="#不要直接安装apt仓库内的docker-io" class="headerlink" title="不要直接安装apt仓库内的docker.io"></a>不要直接安装apt仓库内的docker.io</h2><p>apt仓库中的docker.io是很老版本的docker,现在新版的docker是直接叫做docker-ce,不要直接<code>sudo apt install docker.io</code></p>
<p>如果你已经这样安装了docker.io,请输入以下命令卸载:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>

<p>此时docker.io会被卸载,但是以前下载的images, containers,volumes都会得以保留.</p>
<a id="more"></a>

<h2 id="通过仓库安装"><a href="#通过仓库安装" class="headerlink" title="通过仓库安装"></a>通过仓库安装</h2><ol>
<li><p>升级仓库:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo apt update</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过apt安装以下软件使得可以通过https使用仓库:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sudo</span> apt-<span class="meta">get</span> install apt-transport-https ca-certificates curl gnupg-agent software-properties-<span class="meta">common</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加Docker的官方GPG密钥：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">curl -fsSL http<span class="variable">s:</span>//download.docker.<span class="keyword">com</span>/linux/ubuntu/gpg | sudo apt-key <span class="built_in">add</span> -</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用下面命令添加稳定版仓库:</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> add-apt-repository </span><span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开始安装docker-ce:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="keyword">update</span></span><br><span class="line">   sudo apt install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="通过deb包安装"><a href="#通过deb包安装" class="headerlink" title="通过deb包安装"></a>通过deb包安装</h2><ol>
<li><p>去<a href="https://download.docker.com/linux/ubuntu/dists/" target="_blank" rel="noopener"><code>https://download.docker.com/linux/ubuntu/dists/</code></a>选择你的Ubuntu版本，在<code>pool/stable/</code>里找到合适你版本的deb包.</p>
</li>
<li><p>通过下面命令直接安装deb包,注意找到自己下载deb包的目录和包名.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i /path/to/package.deb</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要升级docker-ce,要再去下载新的deb包重复安装.</p>
</li>
</ol>
<h2 id="使用脚本安装"><a href="#使用脚本安装" class="headerlink" title="使用脚本安装"></a>使用脚本安装</h2><p>这个方法好处是非常的简单,一个脚本全部搞完,并且树莓派只能以这种方式安装docker.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>

<p>以后更新只要在apt内更新即可,不需要重新运行脚本.</p>
<h2 id="添加用户到docker组"><a href="#添加用户到docker组" class="headerlink" title="添加用户到docker组"></a>添加用户到docker组</h2><p>如果不想每次运行docker都要在前面加入sudo,那可以将当前用户加入docker组:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> usermod -aG docker 用户名</span><br></pre></td></tr></table></figure>

<p>注销,并且重新登录即可生效.</p>
<h2 id="卸载docker-ce"><a href="#卸载docker-ce" class="headerlink" title="卸载docker-ce"></a>卸载docker-ce</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> purge docker-ce</span><br></pre></td></tr></table></figure>

<p>主机上的镜像,容器都不会自动删除,想要手动删除,可以输入:</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/<span class="class"><span class="keyword">lib</span>/<span class="title">docker</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git项目换行符LF与CRLF导致的大量更改解决办法</title>
    <url>/2019/06/26/git%E9%A1%B9%E7%9B%AE%E6%8D%A2%E8%A1%8C%E7%AC%A6LF%E4%B8%8ECRLF%E5%AF%BC%E8%87%B4%E7%9A%84%E5%A4%A7%E9%87%8F%E6%9B%B4%E6%94%B9%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h2 id="产生该问题的原因"><a href="#产生该问题的原因" class="headerlink" title="产生该问题的原因"></a>产生该问题的原因</h2><p>产生该问题的原因是由于windows平台和linux平台的默认换行符是不一样的,linux使用的是<code>0x0A(LF)</code>而Windows使用的是<code>0x0D0A(CRLF)</code>,这就导致了当Windows下的代码放到linux下运行时,虽然代码没有错,但是linux下的git检测到项目的换行符为CRLF时会自动换成LF.</p>
<a id="more"></a>

<h2 id="该问题的症状"><a href="#该问题的症状" class="headerlink" title="该问题的症状"></a>该问题的症状</h2><p>出现这个问题的症状表现为git会提示项目的每一个文件的所有位置都发生了修改,但是查看diff的时候发现其实哪都没修改,这是因为换行符被换了但是我们是看不出来的.</p>
<h2 id="解决该问题的方法"><a href="#解决该问题的方法" class="headerlink" title="解决该问题的方法"></a>解决该问题的方法</h2><p>由于代码多是运行在linux,所以现在主流的换行符标准就是LF,所以我们的项目一开始就应该有将换行符设置为LF的意识.</p>
<p>项目一开始创建,还没有加入git仓库的时候就应该将换行符设置为LF,vscode等工具都提供了这个简单的功能,</p>
<p><img src="https://i.loli.net/2019/06/09/5cfc7e70d69e995247.png" alt="img"></p>
<p>如果项目已经加入了git仓库,那就让git帮我们解决问题,git有一个<code>autocrlf</code>配置,可以在我们提交时自动转换换行符,它有3个选项:</p>
<ul>
<li><strong>true:</strong> 提交时转换为 LF，检出时转换为 CRLF</li>
<li><strong>false:</strong> 提交检出均不转换</li>
<li><strong>input:</strong> 提交时转换为LF，检出时不转换</li>
</ul>
<p>另一个设置项<code>safecrlf</code>用于检查文件是否包含着混合换行符,也有3个选项:</p>
<ul>
<li><strong>true:</strong> 拒绝提交包含混合换行符的文件</li>
<li><strong>false:</strong> 允许提交包含混合换行符的文件</li>
<li><strong>warn:</strong> 提交包含混合换行符的文件时给出警告</li>
</ul>
<p>所以,如果我们要将已经加入git的大量CRLF结尾文件批量转换成LF结尾的文件,可以这样设置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br><span class="line">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure>

<p>这样设置之后,先将项目提交一次,这样所有的文件就都会被改成LF结尾.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>278.第一个错误的版本</title>
    <url>/2019/06/26/278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>示例:</p>
<blockquote>
<p>给定 n = 5，并且 version = 4 是第一个错误的版本。</p>
<p>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true</p>
<p>所以，4 是第一个错误的版本。</p>
</blockquote>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题如果没看明白题目说的调用接口判断是啥意思那可能会理解错题意,题目是说现在已经提供给你一个isBadVersion()函数给你去判断了,你不需要自己写这个函数,直接在代码里调用就可以了,思路也比较明确,应该要使用二分法来查找.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstBadVersion</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (IsBadVersion(mid))</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>268.缺失数字</title>
    <url>/2019/06/26/268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p>
<p><strong>示例 1:</strong></p>
<p>复制</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<p>复制</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的思路有很多,我挑了最简单的两个来写.</p>
<ul>
<li>直接对输入的整型数组进行排序,排序了之后与0-n的序列进行逐个比较,如果遇到不相等,那就说明找到了这个缺失的数字.</li>
<li>由于题目说明有且仅有一个数是缺失的,所以我们如果求出了不缺失情况下的和,减去现在数组的和,差值就是这个缺失的数字,而且由于这个0-n序列是一个等差数列,求和可以直接使用公式.</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>排序法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MissingNumber</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array.Sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求和法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MissingNumber</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = (nums.Length * (nums.Length + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum -= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>263.丑数</title>
    <url>/2019/06/03/263-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">6</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">解释:</span> <span class="number">6</span> <span class="string">=</span> <span class="number">2</span> <span class="string">×</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">8</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">解释:</span> <span class="number">8</span> <span class="string">=</span> <span class="number">2</span> <span class="string">×</span> <span class="number">2</span> <span class="string">×</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">14</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">解释:</span> <span class="number">14</span> <span class="string">不是丑数，因为它包含了另外一个质因数</span> <span class="number">7</span><span class="string">。</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><code>1</code> 是丑数。</li>
<li>输入不会超过 32 位有符号整数的范围: [−2<sup>31</sup>,  2<sup>31</sup> − 1]</li>
</ol>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>丑数的定义是只会存在2,3,5这三个因数的一个或多个,也就说明一个丑数整除这三个数中的一个或者多个,肯定是可以除尽的,所以可以逐步缩小输入的数,只要当输入数可以整除2,3,5中的数时,就除以他们,这样逐步计算下去,如果逐步缩小到最后的结果为1,那就说明这个输入的数仅包含质因数2,3,5.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsUgly</span>(<span class="params"><span class="keyword">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (num == <span class="number">1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>258.各位相加</title>
    <url>/2019/06/02/258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入 : <span class="number">38</span></span><br><span class="line">输出 : <span class="number">2</span> </span><br><span class="line">解释 : 各位相加的过程为：<span class="number">3</span> + <span class="number">8</span> = <span class="number">11</span>, <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span>。 由于 <span class="number">2</span> 是一位数，所以返回 <span class="number">2</span>。</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong><br>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题非常有意思的点是进阶里面说的:</p>
<blockquote>
<p>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
</blockquote>
<p>说明这道题不止只有暴力循环解法,还有更巧妙的,只用O(1)时间的解法,也就是说,连扫描一趟的功夫都不用,直接就能得到结果.</p>
<p>这个时候就应该通过数学找规律来解题了,先用比较小的数去尝试看看能不能发现规律:</p>
<p>10—1</p>
<p>11—2</p>
<p>12—3</p>
<p>18—9</p>
<p>19—1</p>
<p>20—2</p>
<p>21—3</p>
<p>99—9</p>
<p>100—1</p>
<p>101—2</p>
<p>102—3</p>
<p>109—1</p>
<p>110—2</p>
<p>111—3</p>
<p>117—9</p>
<p>可以看到,有某个数是比较特别的,那就是这个9.</p>
<p>各位相加答案为9的数,刚好也即是9的倍数.也就是说某个数能被9整除,那他的各位相加结果就刚好是9.</p>
<p>并且无法被9整除的数,得到的余数也就刚好是答案.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>暴力法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">AddDigits</span>(<span class="params"><span class="keyword">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规律法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">AddDigits</span>(<span class="params"><span class="keyword">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = num % <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>242.有效的字母异位词</title>
    <url>/2019/05/31/242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"anagram"</span>, <span class="attr">t</span> = <span class="string">"nagaram"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"rat"</span>, <span class="attr">t</span> = <span class="string">"car"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p>
<p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先要知道什么是字母异位词,它是指两个字符串所包含的字母的出现次数都相同,只是顺序不一样.</p>
<p>这道题解决的思路还是挺多的,而且虽然说明上明确只有小写字母,但是进阶里问到如果出现unicode字符怎么办,所以方法里最好不要有硬编码26个字母出现.</p>
<ul>
<li>方法一:将两个字符串直接排序,然后逐个比较对应位置是否相同.</li>
<li>方法二:s字符串里面每出现一个字母,就在字典对应位置+1;t字符串里每出现一个字母,就在对应位置-1,这样一加一减,结果就应该是字典里面所有数据都为0,如果不是,说明两者不是字母异位词.</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>排序法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsAnagram</span>(<span class="params"><span class="keyword">string</span> s, <span class="keyword">string</span> t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.Length != t.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str1 = s.ToCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] str2 = t.ToCharArray();</span><br><span class="line">    Array.Sort(str1);</span><br><span class="line">    Array.Sort(str2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1[i] != str2[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字典法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsAnagram</span>(<span class="params"><span class="keyword">string</span> s, <span class="keyword">string</span> t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.Length != t.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> charDict = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> c <span class="keyword">in</span> s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (charDict.ContainsKey(c))</span><br><span class="line">        &#123;</span><br><span class="line">            charDict[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            charDict.Add(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> c <span class="keyword">in</span> t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (charDict.ContainsKey(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (--charDict[c] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                charDict.Remove(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> charDict.Count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>237.删除链表中的节点</title>
    <url>/2019/05/31/237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">5</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9.</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">9.</span></span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题真的是一道神题目,如果不看解释一开始我连意思都没读懂.</p>
<p>这道题是指,函数里面给定的节点就是要删除的节点,它自身就处于这条链表内,所以其实问的是<strong>在你只拥有自身节点的情况下如何删除自身</strong>?</p>
<p>而这道题的解法真的是太有意思了,因为我们知道,如果只知道自身节点是没法直接删除自身的,因为一般来说删除一个链表的某个节点的方法,是将这个被删除节点的头节点与自己的尾节点相连,然后自己就会被孤立了.</p>
<p>但是现在不知道自己的上一个节点,只知道自己,如何删掉自己?</p>
<p>方法就是复制下一个节点的数据到自己身上,把自己变成自己的下一个节点,然后删掉下一个节点.</p>
<p>这样的效果就仿佛是自己被删除了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteNode</span>(<span class="params">ListNode node</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node.val = node.next.val;<span class="comment">//用下一个节点的数据覆盖当前节点.</span></span><br><span class="line">    node.next = node.next.next;<span class="comment">//删除下一个节点.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>234.回文链表</title>
    <url>/2019/05/29/234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题,有上中下三种解法:</p>
<ul>
<li><p>下等解法,直接用个栈来存储每个链表的元素,由于栈是后进先出的,所以每一个出栈元素都是链表的末尾元素,这时候可以直接和头元素比较是否相等.</p>
<p>但是这样做的缺点很明显,首先浪费时间和空间;其次要是这个链表是循环链表,那就爆栈了.</p>
</li>
<li><p>中等解法,将链表整条直接反转,然后继续比较两条链表是否完全一致.</p>
<p>这样做的缺点是,会浪费一点点的时间,因为我们知道,如果一条链是回文链,那其实只要比较一半的数据就够了,并不需要完全比较.</p>
</li>
<li><p>上等解法,找到链表的中点,然后将中点节点的后面部分反转,如果和前面部分一致,那就说明是回文链表了.</p>
<p>而反转链表的这个部分,可以直接找回当初的<a href="https://jiayaoo3o.github.io/2019/05/24/206-反转链表/">206.反转链表</a>.</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPalindrome</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast.next.next;<span class="comment">//快的每次走两步.</span></span><br><span class="line">        slow = slow.next;<span class="comment">//慢的每次走一步,快的走到尾了,慢的就会在中间.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newLinkedList = <span class="literal">null</span>;<span class="comment">//创建一个新的链表.</span></span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode tempNode = slow.next;<span class="comment">//创建临时链表存放头节点的尾巴.</span></span><br><span class="line">        slow.next = newLinkedList;<span class="comment">//将新链表接到头节点后面.</span></span><br><span class="line">        newLinkedList = slow;<span class="comment">//再次成为新链表.</span></span><br><span class="line">        slow = tempNode;<span class="comment">//将临时链表覆盖原链表.</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow = newLinkedList;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow.val != head.val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>232.用栈实现队列</title>
    <url>/2019/05/28/232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) – 将一个元素放入队列的尾部。</li>
<li>pop() – 从队列首部移除元素。</li>
<li>peek() – 返回队列首部的元素。</li>
<li>empty() – 返回队列是否为空。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">queue</span>.<span class="built_in">peek</span>();  <span class="comment">// 返回 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// 返回 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>你只能使用标准的栈操作 – 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只能使用栈来实现队列的话,可以使用两个栈.</p>
<p>因为队列的特性是后进后出,而栈的特性是后进先出,要实现后进后出,也就是说最新入栈的元素,要被放到栈底.</p>
<p>所以可以定义一个临时栈,只要有元素进入主栈,就将主栈的所有元素搬到临时栈,在栈底放入新元素,然后再将数据从临时栈搬入主栈.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; stack1 = <span class="keyword">new</span> Stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; stack2 = <span class="keyword">new</span> Stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack1.Count != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack2.Push(stack1.Pop());<span class="comment">//将所有元素从主栈搬到临时栈.</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack1.Push(x);<span class="comment">//将新元素放入主栈底.</span></span><br><span class="line">        <span class="keyword">while</span> (stack2.Count != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack1.Push(stack2.Pop());<span class="comment">//将所有元素从临时栈搬回主栈.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Pop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.Pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Peek</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.Peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Empty</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.Count &gt; <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1009 Product of Polynomials</title>
    <url>/2019/05/28/1009-Product-of-Polynomials/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>This time, you are supposed to find <em>A</em>×<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p>
<p><em>K</em> <em>N1</em> <em>aN1</em> <em>N2</em> <em>aN2</em> … <em>NK</em> <em>aNK</em></p>
<p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>Ni</em> and <em>aNi</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10, 0≤<em>NK</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the product of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be <strong>NO</strong> extra space at the end of each line. Please be accurate up to 1 decimal place.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 2.4 0 3.2</span><br><span class="line">2 2 1.5 1 0.5</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 3.6 2 6.0 1 1.6</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个多项式,其中N是指数,aNi是对应的系数,现在要算两个多项式的乘积.</p>
<p>系数精确到小数点后一位.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题要说难吧,其实不难,只要将两个多项式用泛型字典存起来,再定义一个排序的泛型字典接收他们相乘的结果就可以了.</p>
<p>但是里面有坑,尤其是第0个测试点,就是一个坑,因为题目要求精确到小数点的后1位,但是假如有两个系数分别是double类型的0.1和0.4,那他们相乘的结果是0.04保留一位有效数字那就是0.0了,所以虽然这个乘积不是0,但是是要被四舍五入舍去的,所以我们最后还要有一步判断最后的值是否&gt;=0.05.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; A = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;();</span><br><span class="line">    Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; B = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> product = <span class="keyword">new</span> SortedDictionary&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;();<span class="comment">//注意这里定义了一个排序字典,会自动帮我们把里面的数据排序.</span></span><br><span class="line">    <span class="keyword">string</span>[] inputsA = Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">string</span>[] inputsB = Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">string</span> result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; inputsA.Length - <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        A.Add(<span class="keyword">int</span>.Parse(inputsA[i]), <span class="keyword">double</span>.Parse(inputsA[i + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; inputsB.Length - <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">        <span class="comment">//这里其实可以不需要B字典,直接在循环里面计算A多项式的每个项与inputB相乘也是可以的.</span></span><br><span class="line">        <span class="comment">//但是我发现速度相差不大,就直接定义两个字典了,反正代码更容易读.</span></span><br><span class="line">    &#123;</span><br><span class="line">        B.Add(<span class="keyword">int</span>.Parse(inputsB[i]), <span class="keyword">double</span>.Parse(inputsB[i + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> A)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> B)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!product.ContainsKey(a.Key + b.Key))</span><br><span class="line">            &#123;</span><br><span class="line">                product.Add(a.Key + b.Key, a.Value * b.Value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                product[a.Key + b.Key] += a.Value * b.Value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> p <span class="keyword">in</span> product)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.Abs(p.Value) &gt;= <span class="number">0.05</span>)</span><br><span class="line">            <span class="comment">//注意这里用到了绝对值,因为如果系数是-0.1和0.5相乘结果是-0.05也是要保留的.</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="string">" "</span> + p.Key + <span class="string">" "</span> + p.Value.ToString(<span class="string">"0.0"</span>) + result;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(count + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1007 Maximum Subsequence Sum</title>
    <url>/2019/05/28/1007-Maximum-Subsequence-Sum/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a sequence of <em>K</em> integers { <em>N1</em>, <em>N2</em>, …, <em>NK</em> }. A continuous subsequence is defined to be { <em>Ni</em>, <em>Ni</em>+<em>1</em>, …, <em>Nj</em> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>
<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em>numbers, separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个整型序列,要求出这个序列的最大子序和,最大子序和的开始和结束这三个元素.</p>
<p>注意,如果整个序列全部元素都为负数,那就最大子序和为0,开始和结束分别分该序列的起始和结束.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题和leetcode的这道<a href="https://jiayaoo3o.github.io/2019/05/06/53-最大子序和/">53.最大子序和</a>解法基本是一致的,如果添加数组的下一个数导致这个和成为了负数,说明这个序列能到达的最大的长度已经结束了,因为加上下一个数只会让和变得更小,新的序列应该从下一个数开始尝试.</p>
<p>但是这一道题的另一个不一样的点是还要记录最大子序和的起始和结束.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">string</span>[] lines = Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">int</span>[] inputs = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>, temp = <span class="number">0</span>;<span class="comment">//temp用来记录新的子串的起始位置.</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">-1</span>;<span class="comment">//max的初值设置为负数.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        inputs[i] = <span class="keyword">int</span>.Parse(lines[i]);</span><br><span class="line">        sum = sum + inputs[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            temp = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = sum;</span><br><span class="line">                begin = temp;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; <span class="number">0</span>)<span class="comment">//用max&lt;0来判断是否全为负数是因为只要max不小于0,那说明整个序列里面起码得有一个非负数的元素.</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125; &#123;1&#125; &#123;2&#125;"</span>, <span class="number">0</span>, inputs[<span class="number">0</span>], inputs[count - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125; &#123;1&#125; &#123;2&#125;"</span>, max, inputs[begin], inputs[end]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1006 Sign In and Sign Out</title>
    <url>/2019/05/28/1006-Sign-In-and-Sign-Out/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer <em>M</em>, which is the total number of records, followed by <em>M</em> lines, each in the format:</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">ID<span class="number">_n</span>umber Sign<span class="number">_</span><span class="keyword">in</span><span class="number">_</span>time Sign<span class="number">_</span><span class="keyword">out</span><span class="number">_</span>time</span><br></pre></td></tr></table></figure>

<p>where times are given in the format <code>HH:MM:SS</code>, and <code>ID_number</code> is a string with no more than 15 characters.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p>
<p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">CS301111 15:30:28 17:00:10</span><br><span class="line">SC3021234 08:00:00 11:25:25</span><br><span class="line">CS301133 21:45:00 21:58:40</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SC3021234 CS301133</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一些签到信息,你要找出谁是最早来负责开门的人和谁是最晚来负责关门的人.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的重点是如何简单快捷地判断给定的时间大小,这里用C#的DateTime类型会非常简单,只要将两个时间字符串转换成DateTime型就可以比较大小了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">string</span>[] recordsID = <span class="keyword">new</span> <span class="keyword">string</span>[count];</span><br><span class="line">    <span class="keyword">string</span>[] signInRecords = <span class="keyword">new</span> <span class="keyword">string</span>[count];</span><br><span class="line">    <span class="keyword">string</span>[] signOutRecords = <span class="keyword">new</span> <span class="keyword">string</span>[count];</span><br><span class="line">    <span class="keyword">int</span> firstPerson = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastPerson = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> recode = Console.ReadLine();</span><br><span class="line">        recordsID[i] = recode.Split()[<span class="number">0</span>];</span><br><span class="line">        signInRecords[i] = recode.Split()[<span class="number">1</span>];</span><br><span class="line">        signOutRecords[i] = recode.Split()[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (DateTime.Parse(signInRecords[i]) &lt; DateTime.Parse(signInRecords[firstPerson]))</span><br><span class="line">        &#123;</span><br><span class="line">            firstPerson = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DateTime.Parse(signOutRecords[i]) &gt; DateTime.Parse(signOutRecords[lastPerson]))</span><br><span class="line">        &#123;</span><br><span class="line">            lastPerson = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(recordsID[firstPerson] + <span class="string">" "</span> + recordsID[lastPerson]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>231.2的幂</title>
    <url>/2019/05/26/231-2%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">1</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">解释:</span> <span class="number">20</span> <span class="string">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">16</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">解释:</span> <span class="number">24</span> <span class="string">=</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">218</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题可真是个神仙题目,如果会解那就非常简洁,如果不会解那就得暴力判断.</p>
<p>一个神奇而优雅的解法是,由于2的幂次方(1,2,4,8…)的二进制数都有一个奇特的特点:</p>
<blockquote>
<p>1 : 0001 , 0 : 0000<br>2 : 0010 , 1 : 0001<br>4 : 0100 , 3 : 0011<br>8 : 1000 , 7 : 0111</p>
</blockquote>
<p>他们都只有一位为1,并且他们减去一之后都只有一位为0.</p>
<p>所以将他们相与,结果刚好就为0.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPowerOfTwo</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;<span class="comment">//n与n-1相与,每一个0和1相与结果都为0.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>225.用队列实现栈</title>
    <url>/2019/05/25/225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) – 元素 x 入栈</li>
<li>pop() – 移除栈顶元素</li>
<li>top() – 获取栈顶元素</li>
<li>empty() – 返回栈是否为空</li>
</ul>
<p><strong>注意:</strong></p>
<ul>
<li>你只能使用队列的基本操作– 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用队列实现栈方法比较简单.栈的每一个出栈元素都是最后的元素,但是队列的出队元素是第一个元素,所以要做的就是设法将队列每一个入队的元素移到队头.</p>
<p>所以要做的就是每当有一个元素入队,就将队列里在它前面的元素全部出队一次再入队一次.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyStack</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        queue.Enqueue(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queue.Count - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.Enqueue(queue.Dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Pop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.Dequeue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Top</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.Peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Empty</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.Count &gt; <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>217.存在重复元素</title>
    <url>/2019/05/24/217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题解决的方法有非常多,但是比较快的做法都是先将数组排序,因为排序之后相同元素就一定会挨着,比较好找.</p>
<p>可以直接比较两个相邻的数是否相等,或者也可以使用哈希集合来判断某个数据是否已经出现过.</p>
<p>两者提交结果耗时都差不多.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>直接循环比较相邻元素法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">ContainsDuplicate</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.Length &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Array.Sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用哈希集合来判断当前数字是否已经存在过:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">ContainsDuplicate</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.Length &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;<span class="keyword">int</span>&gt; numSet = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> num <span class="keyword">in</span> nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numSet.Contains(num))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            numSet.Add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>206.反转链表</title>
    <url>/2019/05/24/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题可以使用迭代和递归两种形式来反转链表,先说迭代:</p>
<p>用迭代来反转单链表,也就相当于将每一个节点的头节点,放到自己的尾节点来,所以步骤应该是这样的:</p>
<ol>
<li>将原链表头节点的尾部进行临时保存,防止断链丢失所有数据.</li>
<li>取出头节点,将null节点接入头节点,成为新链.</li>
<li>再将刚刚临时保存的链表头节点取出,将新链接入此头节点尾部,再次成为新链.</li>
<li>重复以上步骤直到临时保存的链表为null.</li>
</ol>
<p>用递归来反转链表,就要按照递归的解题步骤,找到递归的几个要素:</p>
<ol>
<li><p>首先要坚信我们的函数已经可以实现所需功能,哪怕它还没写完,但是我们要明确这个函数已经可以实现这个功能了,所以我们先写出这个已经实现功能的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找出递归结束的条件.这道题显然我们可以知道,当链表的长度为1时,不需要反转了,直接返回它本身就可以了:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来我们要做的就是找出怎么将这个问题化为它的子问题,可以知道,假如现在的链表是这样的:</p>
<blockquote>
<p>1-&gt;2-&gt;3-&gt;4</p>
</blockquote>
<p>那假如我们将它的头节点后面进行反转,那后面那部分链表将会变成</p>
<blockquote>
<p>1-&gt;2&lt;-3&lt;-4</p>
</blockquote>
<p>1(head)还是头节点,它的下一个节点还是2(head.next),但是后面的部分已经反转完成了,所以现在要做的就是将2(head.next)的下一个节点变为1(head),而将1(head)的下一个节点变为null,所以这时候代码应该是这样的:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newLinkedList = ReverseList(head.next);<span class="comment">//接收已经反转了的链表.</span></span><br><span class="line">    head.next.next = head;<span class="comment">//将2(head.next)的下一个节点(next)变为1(head).</span></span><br><span class="line">    head.next = <span class="literal">null</span>;<span class="comment">//将1(head)的下一个节点变为null.</span></span><br><span class="line">    <span class="keyword">return</span> newLinkedList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>迭代版本:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newLinkedList = <span class="literal">null</span>;<span class="comment">//创建一个新的链表.</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode tempNode = head.next;<span class="comment">//创建临时链表存放头节点的尾巴.</span></span><br><span class="line">        head.next = newLinkedList;<span class="comment">//将新链表接到头节点后面.</span></span><br><span class="line">        newLinkedList = head;<span class="comment">//再次成为新链表.</span></span><br><span class="line">        head = tempNode;<span class="comment">//将临时链表覆盖原链表.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newLinkedList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归版本:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newLinkedList = ReverseList(head.next);<span class="comment">//接收已经反转了的链表.</span></span><br><span class="line">    head.next.next = head;<span class="comment">//将2(head.next)的下一个节点(next)变为1(head).</span></span><br><span class="line">    head.next = <span class="literal">null</span>;<span class="comment">//将1(head)的下一个节点变为null.</span></span><br><span class="line">    <span class="keyword">return</span> newLinkedList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>205.同构字符串</title>
    <url>/2019/05/23/205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong>t</strong>，判断它们是否是同构的。</p>
<p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong>t</strong> ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"egg"</span>, <span class="attr">t</span> = <span class="string">"add"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"foo"</span>, <span class="attr">t</span> = <span class="string">"bar"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"paper"</span>, <span class="attr">t</span> = <span class="string">"title"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>你可以假设 <strong><em>s</em></strong> 和 <strong>t</strong> 具有相同的长度。</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然同构的s和t有着一一对应的关系,应该使用泛型字典来存储这样的一一对应关系.</p>
<p>因为我们知道,如果s,和t长度相同却不构成一对一关系,那就只可能是一对多,多对一,多对多关系,所以我们在一个循环之内一定可以判断两者是否同构.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsIsomorphic</span>(<span class="params"><span class="keyword">string</span> s, <span class="keyword">string</span> t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; strInfo = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strInfo.ContainsKey(s[i]))<span class="comment">//如果字典里面没有s[i].</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (strInfo.ContainsValue(t[i]))<span class="comment">//但是已经存在了与之对应的t[i],说明产生了多对一关系.</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            strInfo.Add(s[i], t[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (strInfo[s[i]] != t[i])<span class="comment">//如果字典里面已经有了s[i],就看看t[i]是否与之配对.</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>203.删除链表中的节点</title>
    <url>/2019/05/22/203-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>删除链表中等于给定值 <strong>val</strong> 的所有节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">6</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>, val = <span class="number">6</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题可以用两种解法解决.</p>
<ul>
<li>直接用最普通的循环方法,在一个循环内判断链表中的某个数是否与val相同,然后删去相同节点.</li>
<li>用递归方法来解决.</li>
</ul>
<p>这里重点讲解一下递归解决这道题的思路.</p>
<p>首先我们用递归函数的时候,要明确的知道这个函数是干嘛的,<strong>并且坚信它已经可以实现这个功能</strong>,所以到了这道题,首先我们要明确知道,这个题目要求的方法是”删除链表中定值等于val的节点,并且<strong>返回删除后的链表</strong>“.所以我们可以得到下面这个函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">RemoveElements</span>(<span class="params">ListNode head, <span class="keyword">int</span> val</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先不管里面是怎么实现的,现在我们要做的是<strong>坚信这个函数已经实现了这个功能</strong>.</p>
<p>然后,我们要找出递归函数的出口,即终止条件,也就是说当递归到了什么程度的时候,可以结束.</p>
<p>可以想到,当head到了最小情况,也就是为null的时候,可以直接返回null结束了.所以head==null就是终止条件:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">RemoveElements</span>(<span class="params">ListNode head, <span class="keyword">int</span> val</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来,我们就要将问题逐步分解为子问题,将递归范围逐步减小.</p>
<p>想一下,如果一条长度为4个节点的链表,放入我们的函数,将会如何操作.注意这个时候不要想递归是如何实现的,而是要坚信现在的函数已经可以实现这个功能了.</p>
<p>这个时候会有两种情况:</p>
<ol>
<li>这个4个节点的链表的第一个节点就是要删除的节点.这个时候我们只要放弃掉第一个节点,将剩下的三个节点作为一条新的链表,继续放入我们的函数中进行判断即可.所以现在代码应该是这样的:</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">RemoveElements</span>(<span class="params">ListNode head, <span class="keyword">int</span> val</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.val == val)<span class="comment">//如果是要删除的.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RemoveElements(head.next, val);<span class="comment">//那就把第一个节点扔掉,将剩下的三个节点作为一个新的链表,继续放入函数判断.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>这个4个节点的链表的第一个节点不是我们要删除的节点,这个时候我们保留第一个节点,将剩下的的3个节点作为一个新的链表,继续放入函数中进行判断.这个时候代码就会成为这样:</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">RemoveElements</span>(<span class="params">ListNode head, <span class="keyword">int</span> val</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RemoveElements(head.next, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head.next = RemoveElements(head.next, val);<span class="comment">//保留第一个节点head,将剩下的三个节点作为一个新的链表放入函数进行判断,并且将结果接到头节点后面.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里,整个递归就已经完成了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>普通循环法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">RemoveElements</span>(<span class="params">ListNode head, <span class="keyword">int</span> val</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode p = <span class="keyword">new</span> ListNode(<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        next = head</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode h = p;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.next.val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">RemoveElements</span>(<span class="params">ListNode head, <span class="keyword">int</span> val</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RemoveElements(head.next, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head.next = RemoveElements(head.next, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>202.快乐数</title>
    <url>/2019/05/20/202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<p><strong>示例:</strong> </p>
<blockquote>
<p>输入: 19<br>输出: true<br>解释:<br>1<sup>2</sup> + 9<sup>2</sup> = 82<br>8<sup>2</sup> + 2<sup>2</sup>= 68<br>6<sup>2 </sup>+ 8<sup>2</sup> = 100<br>1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2 </sup>= 1</p>
</blockquote>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题要算平方和不难,唯一要注意的就是,什么时候循环退出返回false,因为如果这个数不是快乐数,那就会一直循环下去.</p>
<p>这里选择使用哈希集来存储出现过的数,如果某个非快乐数已经出现过了,那说明已经进入循环了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsHappy</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;<span class="keyword">int</span>&gt; used = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!used.Contains(result))</span><br><span class="line">    &#123;</span><br><span class="line">        used.Add(result);</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = result + (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>198.打家劫舍</title>
    <url>/2019/05/20/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是一道典型的动态规划题目.</p>
<p>可以创建一个数组sum[],动态地记录偷或者不偷这一家房子会得到的最高金额.</p>
<p>如果决定偷,那sum[i]=sum[i-2]+nums[i].</p>
<p>如果决定不偷,那这个位置的最高金额和上一个位置的一样sum[i]=sum[i-1].</p>
<p>判断偷不偷的依据是看两者谁提供的金额更高.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rob</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.Length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums.Length == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.Length];</span><br><span class="line">    sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    sum[<span class="number">1</span>] = Math.Max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; sum.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = Math.Max(sum[i - <span class="number">1</span>], sum[i - <span class="number">2</span>] + nums[i]);<span class="comment">//判断偷和不偷得到的最高金额.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum[sum.Length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>191.位1的个数</title>
    <url>/2019/05/19/191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000000001011</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 '<span class="number">1</span>'。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000010000000</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000010000000</span> 中，共有一位为 '<span class="number">1</span>'。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">31</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 中，共有 <span class="number">31</span> 位为 '<span class="number">1</span>'。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题解法有很多,这里举两个.</p>
<p>一种是最基本的暴力解法,就是将数转换成二进制字符串,一个循环内数有多少个1.</p>
<p>另一种就是通过判断数字的最后一位是不是1,然后让整个数不断右移,每次都判断最右边的那个数字,想要判断最后一位是不是1,可以通过与运算.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>转换成字符串法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">HammingWeight</span>(<span class="params"><span class="keyword">uint</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">string</span> s = Convert.ToString(n, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右移法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">HammingWeight</span>(<span class="params"><span class="keyword">uint</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>190. 颠倒二进制位</title>
    <url>/2019/05/16/190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">00000010100101000001111010011100</span></span><br><span class="line">输出: <span class="number">00111001011110000010100101000000</span></span><br><span class="line">解释: 输入的二进制串 <span class="number">00000010100101000001111010011100</span> 表示无符号整数 <span class="number">43261596</span>，</span><br><span class="line">因此返回 <span class="number">964176192</span>，其二进制表示形式为 <span class="number">00111001011110000010100101000000</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">10111111111111111111111111111111</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 表示无符号整数 <span class="number">4294967293</span>，</span><br><span class="line">因此返回 <span class="number">3221225471</span> 其二进制表示形式为 <span class="number">10101111110010110010011101101001</span>。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道考察位运算的题目,通过左移和右移来得到结果.</p>
<p>可以先创建一个结果变量,用于存放输入变量最右边一位的信息,然后让结果变量不断左移,输入变量不断右移,这样循环32次,就可以将输入变量颠倒了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">uint</span> <span class="title">reverseBits</span>(<span class="params"><span class="keyword">uint</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result &lt;&lt;= <span class="number">1</span>;<span class="comment">//先左移一个位置,让出最右边空位.</span></span><br><span class="line">        result = result + n &amp; <span class="number">1</span>;<span class="comment">//用与运算得到n最右边一位,交给result.</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;<span class="comment">//n右移一位,挤掉最右边的位置.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>172.阶乘后的零</title>
    <url>/2019/05/15/172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: <span class="number">3</span>! = <span class="number">6</span>, 尾数中没有零。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: <span class="number">5</span>! = <span class="number">120</span>, 尾数中有 <span class="number">1</span> 个零.</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 你算法的时间复杂度应为 <em>O</em>(log <em>n</em>) </p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是相当有难度的一道题,要明白这个简单的解法并不简单.</p>
<p>首先先把这个数的阶乘暴力算出来,然后从后往前数多少个零这种做法肯定是不可取的,肯定是有更巧妙的方法的.</p>
<p>先来观察结果的尾数中0的个数与什么有关.</p>
<p>阶乘是指将1到n之间的所有数都乘起来,而在这些数之中,想要得到尾数0,则必然需要2x5才会有0,要么就是2的倍数乘以5或者5的倍数会得到0.<br>例如:</p>
<blockquote>
<p>6!=1x2x3x4x5x6</p>
</blockquote>
<p>就是通过2x5来得到尾数0的,所以我们可以得知,尾数0的个数受到2和5的个数限制.</p>
<p>而另一方面,我们通过公式可以得知,2的个数必然是会比5的个数多的,例如上面的式子,可以拆成:</p>
<blockquote>
<p>6!=1x2x3x(2x2)x5x(2x3)</p>
</blockquote>
<p>所以我们可以进一步得出结论,尾数0的个数受限于5的个数,有多少个5,就总会有多少个2来和它组成一个10来产生一个0.</p>
<p>到了这里我们的目标就从算出尾数有多少个0,变成了给定的阶乘数里面包含了多少个5.例如30!里面能凑出7个5,分别是</p>
<blockquote>
<p><strong>5</strong> , 2x<strong>5</strong>  ,3x<strong>5</strong> , 4x<strong>5</strong> , <strong>5</strong>x<strong>5</strong> , 6x<strong>5</strong></p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TrailingZeroes</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count = count + n / <span class="number">5</span>;</span><br><span class="line">        n = n / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>169.求众数</title>
    <url>/2019/05/15/169-%E6%B1%82%E4%BC%97%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题由于题目已经明确了众数是出现次数大于n/2次,所以就可以得到一个规律:只要将这个数组进行排序,那数组中间的那个数无论如何都会是众数,因为众数占据了长度的一半以上.</p>
<p>所以这道题可以有两种解法:</p>
<ul>
<li>直接返回排序之后数组的一半位置的数.</li>
<li>用一个哈希表记录数字出现的次数,如果多于一半就是众数</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>排序法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MajorityElement</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array.Sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.Length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希表法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MajorityElement</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numsInfo = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> num <span class="keyword">in</span> nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numsInfo.ContainsKey(num))</span><br><span class="line">        &#123;</span><br><span class="line">            numsInfo[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            numsInfo.Add(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numsInfo[num] &gt; nums.Length / <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>167.两数之和 II - 输入有序数组</title>
    <url>/2019/05/15/167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p>
<p><strong>说明:</strong></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: numbers = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释: <span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于题目已经明说这个数组是一个有序数组,并且一定会有一个答案,那我们就可以使用双指针法来得到结果.</p>
<p>设置一个头指针和一个尾指针,分别指向首元素的尾元素,然后让头尾相加.</p>
<p>如果结果太大,那就说明尾元素过大了,让尾指针前进一步.</p>
<p>如果结果太小,那就说明头指针太小了,让头指针往后一步.</p>
<p>这样逐步逼近,就能得到结果.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">TwoSumII</span>(<span class="params"><span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numbers.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[left] + numbers[right] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; left + <span class="number">1</span>, right + <span class="number">1</span> &#125;;<span class="comment">//下标要加一.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[left] + numbers[right] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>160.相交链表</title>
    <url>/2019/05/14/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>在节点 c1 开始相交。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">8</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">8</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。</span><br><span class="line">在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br></pre></td></tr></table></figure>



<p><strong>示例 2：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">2</span>, listA = [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], listB = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], skipA = <span class="number">3</span>, skipB = <span class="number">1</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">2</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">2</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]。在 A 中，相交节点前有 <span class="number">3</span> 个节点；</span><br><span class="line">在 B 中，相交节点前有 <span class="number">1</span> 个节点。</span><br></pre></td></tr></table></figure>



<p><strong>示例 3：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">null</span></span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。</span><br><span class="line">由于这两个链表不相交，所以 <span class="built_in">int</span>ersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 <span class="literal">null</span>。</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要判断两个链表是否有交点的难点在于,由于两条链表的长度不一样,所以无法简单的做到一一比较,因此解题思路就是先将两个链表的起始长度设置为一样,然后逐个比较.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先实现一个计算链表长度的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountNode</span>(<span class="params">ListNode list</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (list != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        list = list.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">GetIntersectionNode</span>(<span class="params">ListNode headA, ListNode headB</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headB == <span class="literal">null</span> || headA == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> CountA = CountNode(headA);</span><br><span class="line">    <span class="keyword">int</span> CountB = CountNode(headB);</span><br><span class="line">    <span class="keyword">if</span> (CountA &gt; CountB)<span class="comment">//如果A比B长</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CountA - CountB; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            headA = headA.next;<span class="comment">//那就将A变得和B一样短.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CountB - CountA; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            headB = headB.next;<span class="comment">//否则就将B变得和A一样短.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == headB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> headA;<span class="comment">//当两者长度一样时,开始逐位比较,相等说明相交.</span></span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>141.环形链表</title>
    <url>/2019/05/13/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<a id="more"></a>

<p><strong>示例 2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>示例 3：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于链表得环问题,我们可以使用快慢指针来解决.</p>
<p>想象两个人在环形跑道上同向跑步,一个快一个慢,那快的和慢的总会相遇的.我们利用这一个点,定义一个快指针,一个慢指针,如果它们两个相遇了,那说明链表有环.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">HasCycle</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast.next.next;<span class="comment">//快指针每次走两步.</span></span><br><span class="line">        slow = slow.next;<span class="comment">//慢指针每次走一步.</span></span><br><span class="line">        <span class="keyword">if</span> (fast == slow)<span class="comment">//两者相遇.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>136.只出现一次的数字</title>
    <url>/2019/05/13/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的一个巧妙的解法就是使用异或来计算,两个数异或会产生以下的特点:</p>
<ul>
<li>任何数与0异或会得到它本身.</li>
<li>任何数与自己异或会得到0.</li>
</ul>
<p>而题目已经说明只有某个元素出现了一次,其余的都出现了两次,也就是说这些出现偶数次的元素异或结果都会等于0,唯独只出现一次的这个元素与剩下的0异或得到本身.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SingleNumber</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n = n ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>125.验证回文串</title>
    <url>/2019/05/13/125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight smalltalk"><table><tr><td class="code"><pre><span class="line">输入: <span class="comment">"A man, a plan, a canal: Panama"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight smalltalk"><table><tr><td class="code"><pre><span class="line">输入: <span class="comment">"race a car"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题还是比较简单的,因为只考虑字母和数字字符,剩下的都不考虑,所以解题步骤只有3步:</p>
<ul>
<li>将输入字符串全部转化为小写.</li>
<li>逐个验证是否是字母或者数字,如果是就假如新的字符串.</li>
<li>验证这个新的字符串是否为回文.</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPalindrome</span>(<span class="params"><span class="keyword">string</span> s</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = s.ToLower();</span><br><span class="line">    System.Text.StringBuilder result = <span class="keyword">new</span> System.Text.StringBuilder();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> c <span class="keyword">in</span> s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span> || c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.Append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.Length / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (result[i] != result[result.Length - <span class="number">1</span> - i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>121.买卖股票的最佳时机</title>
    <url>/2019/05/12/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> </span><br><span class="line">注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>定义两个变量最大利润和最小价格,在一个循环内比较每一天的最大利润和当前的最大利润相比谁更大,如果今天的利润比最大利润还大,那就让今天的利润成为最大利润.今天的最大利润等于今天的价格减去最小价格.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxProfit</span>(<span class="params"><span class="keyword">int</span>[] prices</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.Length &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>], maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxProfit = Math.Max(maxProfit, prices[i] - minPrice);<span class="comment">//得到这么多天以来的最大利润.</span></span><br><span class="line">        minPrice = Math.Min(minPrice, prices[i]);<span class="comment">//得到这么多天以来的最小价格.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>104.二叉树的最大深度</title>
    <url>/2019/05/12/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>还是用递归的方法来逐层+1,算出最大的深度</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxDepth</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.Max(MaxDepth(root.left), MaxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1002 A+B for Polynomials</title>
    <url>/2019/05/10/1002-A-B-for-Polynomials/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>This time, you are supposed to find <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p>
<p><em>K</em> <em>N1</em> <em>aN1</em> <em>N2</em> <em>aN2</em> … <em>NK</em> <em>aNK</em></p>
<p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>Ni</em> and <em>aNi</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10，0≤<em>NK</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 2.4 0 3.2</span><br><span class="line">2 2 1.5 1 0.5</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 1.5 1 2.9 0 3.2</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>计算两个多项式的和,注意这里每一个输入的多项式最多只会有10项,但是多项式最大的项能到第1000项.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用一个长度为1001的整型数组作为哈希表,下标表示第几项,值代表系数的值.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] A = Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">string</span>[] B = Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">double</span>[] polynomialInfo = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">1001</span>];<span class="comment">//定义一个用于存放系数信息的哈希表.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.Length - <span class="number">1</span>; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        polynomialInfo[<span class="keyword">int</span>.Parse(A[i])] = <span class="keyword">double</span>.Parse(A[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; B.Length - <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        polynomialInfo[<span class="keyword">int</span>.Parse(B[i])] += <span class="keyword">double</span>.Parse(B[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">string</span> result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; polynomialInfo.Length; i++)<span class="comment">//这里的循环1000个位置只有最多10个是有用的,但是没有必要进行优化,因为我试了,时间都差不多.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (polynomialInfo[i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="string">" "</span> + i + <span class="string">" "</span> + polynomialInfo[i].ToString(<span class="string">"0.0"</span>) + result;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Write(count + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>101. 对称二叉树</title>
    <url>/2019/05/09/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>上回说到,遇到树的题目,往递归方面靠会比较合适,要判断这个二叉树是否对称,相当于递归判断每一个节点的左右节点的子节点是否成为镜像.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先实现一个递归函数,用来判断一个树的左右两个节点是否镜像对称</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsSymmetricTree</span>(<span class="params">TreeNode p, TreeNode q</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span> || p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>)<span class="comment">//如果左null右非null或者右null左非null,说明一定不是对称的.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) || (p.val == q.val) &amp;&amp; IsSymmetricTree(p.left, q.right) &amp;&amp; IsSymmetricTree(p.right, q.left);</span><br><span class="line">        <span class="comment">//先判断是不是都为null,然后再判断左右两个值是否相等,再递归判断左右子节点.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsSymmetric</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IsSymmetricTree(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1152 Google Recruitment</title>
    <url>/2019/05/09/1152-Google-Recruitment/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>In July 2004, Google posted on a giant billboard along Highway 101 in Silicon Valley (shown in the picture below) for recruitment. The content is super-simple, a URL consisting of the first 10-digit prime found in consecutive digits of the natural constant <em>e</em>. The person who could find this prime number could go to the next step in Google’s hiring process by visiting this website.</p>
<p><img src="https://images.ptausercontent.com/57148679-d574-4f49-b048-775c6c07791c.jpg" alt="prime.jpg"></p>
<p>The natural constant <em>e</em> is a well known transcendental number（超越数）. The first several digits are: <em>e</em> = 2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642<strong>7427466391</strong>932003059921… where the 10 digits in bold are the answer to Google’s question.</p>
<p>Now you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case first gives in a line two positive integers: L (≤ 1,000) and K (&lt; 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, output <code>404</code> instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 5</span><br><span class="line">23654987725541023819</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">49877</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 3</span><br><span class="line">2468024680</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">404</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>找出给定长度的正整数L内的第一个长度为K的素数.</p>
<ul>
<li>正整数内的0也算作长度,例如200236内找出第一个长度为4的素数,那0023就是答案.</li>
<li>如果没有要求的素数,输出404.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题还是相对简单的,因为主要的考点还是在与判断某个数是不是素数,而判断素数的函数已经写过很多次了.</p>
<p>另一方面要获得指定长度的字符串,只需要用字符串的Substring()方法就可以了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先实现一个判断是否为素数的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsPrime</span>(<span class="params"><span class="keyword">int</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.Sqrt(input); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (input % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> primeLength = <span class="keyword">int</span>.Parse(Console.ReadLine().Split()[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">string</span> input = Console.ReadLine();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= input.Length - primeLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsPrime(<span class="keyword">int</span>.Parse(input.Substring(i, primeLength))))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(input.Substring(i, primeLength));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">"404"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1144 The Missing Number</title>
    <url>/2019/05/09/1144-The-Missing-Number/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given N integers, you are supposed to find the smallest positive integer that is NOT in the given list.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10<sup>5</sup>). Then N integers are given in the next line, separated by spaces. All the numbers are in the range of <strong>int</strong>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>Print in a line the smallest positive integer that is missing from the input list.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">5 -25 9 6 1 3 4 2 5 17</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定N个数，要求找出不在列表内的最小正整数.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题如果没有理解题目就会跑偏了,题目要求<strong>找出不在列表内的最小正整数</strong>,也就是说如果1不在列表里,那1就是我们要找的那个最小正整数.</p>
<p>不管输入的列表有多少个数，我们都只需要在循环内从1开始比较，只要发现某个数不存在,那就输出这个数.</p>
<p>但是因为输入的数字列表是无序的,所以我们要将这些数字放入一个集合中.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">    HashSet&lt;<span class="keyword">string</span>&gt; inputsInfo = <span class="keyword">new</span> HashSet&lt;<span class="keyword">string</span>&gt;(Console.ReadLine().Split());</span><br><span class="line">    <span class="comment">//用hashset来接收输入的数据.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!inputsInfo.Contains(i.ToString()))<span class="comment">//从1开始,如果i不在集合内那就是要找的数.</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1140 Look-and-say Sequence</title>
    <url>/2019/05/09/1140-Look-and-say-Sequence/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Look-and-say sequence is a sequence of integers as the following:</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">D</span></span>, D1, D111, D113, D11231, D112213111, ...</span><br></pre></td></tr></table></figure>

<p>where <code>D</code> is in [0, 9] except 1. The (n+1)st number is a kind of description of the nth number. For example, the 2nd number means that there is one <code>D</code> in the 1st number, and hence it is <code>D1</code>; the 2nd number consists of one <code>D</code>(corresponding to <code>D1</code>) and one 1 (corresponding to 11), therefore the 3rd number is <code>D111</code>; or since the 4th number is <code>D113</code>, it consists of one <code>D</code>, two 1’s, and one 3, so the next number must be <code>D11231</code>. This definition works for <code>D</code> = 1 as well. Now you are supposed to calculate the Nth number in a look-and-say sequence of a given digit <code>D</code>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case, which gives <code>D</code> (in [0, 9]) and a positive integer N (≤ 40), separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>Print in a line the Nth number in a look-and-say sequence of <code>D</code>.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 8</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1123123111</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>外观序列是指通过将序列的每个数的数目都”说出来”而形成的序列</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">D</span><br><span class="line">D1 <span class="string">//D</span>有1个</span><br><span class="line">D111 <span class="string">//D</span>有1个,1有1个</span><br><span class="line">D113 <span class="string">//D</span>有1个,1有3个</span><br><span class="line">D11231 <span class="string">//D</span>有1个,1有2个,3有1个</span><br><span class="line">D112213111 <span class="string">//D</span>有1个,1有2个,2有1个,3有1个,1有1个</span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>现在输入一个数D和一个重复次数N,要求输出第N个重复序列.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于每一次循环的一个序列,比较当前的字符和上一个字符是否相同,如果相同那就让计数器+1,不一样的时候说明这个字符已经完结了,将这个答案拼接到一个临时结果上,最后将临时结果再次放入循环.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] lines = Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">string</span> input = lines[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">int</span>.Parse(lines[<span class="number">1</span>]);</span><br><span class="line">    System.Text.StringBuilder result = <span class="keyword">new</span> System.Text.StringBuilder(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">while</span> (--count &gt; <span class="number">0</span>)<span class="comment">//这里使用--count,即假设输入的是8,只需要循环7次,因为输入的D已经算是第一次了.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nowCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; input.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] == input[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nowCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result.Append(input[i - <span class="number">1</span>] + nowCount.ToString());</span><br><span class="line">                <span class="comment">//将result定义成StringBuilder可以大幅度降低花费的时间.</span></span><br><span class="line">                <span class="comment">//如果直接用string类型的result+=input[i - 1] + nowCount.ToString()来拼接结果,将会导致超时!!!</span></span><br><span class="line">                nowCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.Append(input[input.Length - <span class="number">1</span>] + nowCount.ToString());</span><br><span class="line">        input = result.ToString();<span class="comment">//将临时结果赋值给input进行下次循环.</span></span><br><span class="line">        result.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>100.相同的树</title>
    <url>/2019/05/08/100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入:       <span class="number">1</span>         <span class="number">1</span></span><br><span class="line">          / \       / \</span><br><span class="line">         <span class="number">2</span>   <span class="number">3</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入:      <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">          /           \</span><br><span class="line">         <span class="number">2</span>             <span class="number">2</span></span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>],     [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入:       <span class="number">1</span>         <span class="number">1</span></span><br><span class="line">          / \       / \</span><br><span class="line">         <span class="number">2</span>   <span class="number">1</span>     <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],   [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在leetcode上对于树的题目的解法,都可以尝试往递归方面去思考,因为树的特点就是根节点的叶子节点,也可能会成为下一个叶子的根,用递归的思想来解决会比较方便.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsSameTree</span>(<span class="params">TreeNode p, TreeNode q</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span> || p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.val != q.val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> IsSameTree(p.left, q.left) &amp;&amp; IsSameTree(p.right, q.right);<span class="comment">//递归判断两棵树的左右叶子节点.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>83.删除排序链表中的重复元素</title>
    <url>/2019/05/08/83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将下一个节点和当前节点进行比较,如果两者相等,那就将下下个节点接到这个节点的后面,相当于将重复的节点摘除了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">DeleteDuplicates</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val == node.val)</span><br><span class="line">        &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>70.爬楼梯</title>
    <url>/2019/05/08/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">2</span> 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是典型的动态规划题目,详细解释可以查看<a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" target="_blank" rel="noopener">这篇推文</a>,讲的非常好.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>动态规划:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ClimbStairs</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span> || n == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];<span class="comment">//定义一个数组,接收每一层楼梯的走法</span></span><br><span class="line">    r[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    r[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r[i] = r[i - <span class="number">1</span>] + r[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ClimbStairs</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>||n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ClimbStairs(n - <span class="number">1</span>) + ClimbStairs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>69.x的平方分根</title>
    <url>/2019/05/07/69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E5%88%86%E6%A0%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">8</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">说明: <span class="number">8</span> 的平方根是 <span class="number">2.82842</span>..., </span><br><span class="line">由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题看似简单,但是非常有意思,普通解法可以使用二分法来进行计算,但是这里使用一个更好用的解法:<a href="https://www.guokr.com/question/461510/" target="_blank" rel="noopener">牛顿迭代法</a>,通过逼近斜率来得到方程的解.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MySqrt</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> r = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)<span class="comment">//迭代次数,次数越多越精确.</span></span><br><span class="line">    &#123;</span><br><span class="line">        r = (r + x / r) / <span class="number">2</span>;<span class="comment">//牛顿迭代法的关键,建议直接背下来.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>67. 二进制求和</title>
    <url>/2019/05/07/67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">a</span> = <span class="string">"11"</span>, <span class="attr">b</span> = <span class="string">"1"</span></span><br><span class="line">输出: <span class="string">"100"</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">a</span> = <span class="string">"1010"</span>, <span class="attr">b</span> = <span class="string">"1011"</span></span><br><span class="line">输出: <span class="string">"10101"</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>又是字符串相加的题目,思路类似于上一题的数组加法,只要是要自己实现加法的,步骤都基本如下:</p>
<ul>
<li>定义一个进位变量flag.</li>
<li>如果长度不一致,将两者长度变成一致.</li>
<li>从右到左按位相加,如果产生了进位,进位就变成1.</li>
<li>循环结束后,如果flag仍为1,则说明还要加一.</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">AddBinary</span>(<span class="params"><span class="keyword">string</span> a, <span class="keyword">string</span> b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.Length &gt; b.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        b = b.PadLeft(a.Length, <span class="string">'0'</span>);<span class="comment">//用padleft这个方法来填充0.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = a.PadLeft(b.Length, <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">string</span> result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        result = (((<span class="keyword">int</span>)a[i] - <span class="number">48</span> + (<span class="keyword">int</span>)b[i] - <span class="number">48</span> + flag) % <span class="number">2</span>).ToString() + result;</span><br><span class="line">        flag = ((<span class="keyword">int</span>)a[i] - <span class="number">48</span> + (<span class="keyword">int</span>)b[i] - <span class="number">48</span> + flag) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag == <span class="number">1</span> ? flag + result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>66.加一</title>
    <url>/2019/05/07/66-%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释: 输入数组表示数字 <span class="number">123</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释: 输入数组表示数字 <span class="number">4321</span>。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题考察的是数组加法,数组加法的常规步骤为:</p>
<ul>
<li>定义一个记录进制信息的变量.</li>
<li>一个循环内按位相加得到每一位的和,和模10就是每一位的值,注意,如果是字符串数组,char要减去48才是int.</li>
<li>进位等于和除以10.</li>
<li>循环结束后如果进位仍然为1,则说明数组第一位仍然要添加1.</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">PlusOne</span>(<span class="params"><span class="keyword">int</span>[] digits</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> digitSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        digitSum = digits[i] + flag;</span><br><span class="line">        digits[i] = digitSum % <span class="number">10</span>;</span><br><span class="line">        flag = (digitSum + <span class="number">1</span> + flag) / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[digits.Length + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        digits.CopyTo(result, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>58.最后一个单词的长度</title>
    <url>/2019/05/06/58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p><strong>说明：</strong>一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: "Hello World"</span></span><br><span class="line"><span class="section">输出: 5</span></span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题要注意的一个点是,给定的字符串有可能是后面带有若干个空格的,所以要处理字符串之前先要用Trim()函数解决了头尾空格,然后就容易判断了.</p>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LengthOfLastWord</span>(<span class="params"><span class="keyword">string</span> s</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.Trim().Split()[s.Trim().Split().Length - <span class="number">1</span>].Length;<span class="comment">//trim用于消除头尾空格,split用于将字符串分割,然后取最后一个字符串得长度.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>53.最大子序和</title>
    <url>/2019/05/06/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>],</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求有最大和的连续子数组,如果添加数组的下一个数导致这个和成为了负数,说明这个序列能到达的最大的长度已经结束了,因为加上下一个数只会让和变得更小,新的序列应该从下一个数开始尝试.</p>
<p>所以我们可以设定一个最大值,每当一个序列结束时,我们就将这个序列的和与最大值进行比较,如果序列和大于最大值,就让这个序列和成为最大值.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubArray</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.Length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum &lt; <span class="number">0</span> ? <span class="number">0</span> : sum;<span class="comment">//如果sum&lt;0那这个sum就可以舍弃了,直接变为0;</span></span><br><span class="line">        sum += nums[i];</span><br><span class="line">        max = sum &gt; max ? sum : max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>35. 搜索插入位置</title>
    <url>/2019/05/06/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">5</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">7</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">0</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题很简单,就是在一个循环内将数组的每个数与目标值进行比较,如果目标值小于等于数组值,那就说明这个位置就是我们要找的位置.</p>
<p>如果一个循环下来都没有找到这个位置,说明这个位置在数组的最后.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SearchInsert</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.Length;<span class="comment">//如果前面的循环都找不到插入位置说明在最后面一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>28.实现strStr()</title>
    <url>/2019/05/06/28-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank" rel="noopener">strStr()</a> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  <strong>-1</strong>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">haystack</span> = <span class="string">"hello"</span>, <span class="attr">needle</span> = <span class="string">"ll"</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">haystack</span> = <span class="string">"aaaaa"</span>, <span class="attr">needle</span> = <span class="string">"bba"</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank" rel="noopener">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)" target="_blank" rel="noopener">indexOf()</a> 定义相符。</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接使用库函数解决.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrStr</span>(<span class="params"><span class="keyword">string</span> haystack, <span class="keyword">string</span> needle</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> haystack.IndexOf(needle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1136 A Delayed Palindrome</title>
    <url>/2019/05/06/1136-A-Delayed-Palindrome/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Consider a positive integer <em>N</em> written in standard notation with <em>k</em>+1 digits <em>ai</em> as <em>ak<em>⋯</em>a1</em> <em>a0</em> with 0≤<em>ai</em>&lt;10 for all <em>i</em> and <em>ak</em>&gt;0. Then <em>N</em> is <strong>palindromic</strong> if and only if <em>ai</em>=<em>ak<em>−</em>i</em> for all <em>i</em>. Zero is written 0 and is also palindromic by definition.</p>
<p>Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. Such number is called <strong>a delayed palindrome</strong>. (Quoted from <a href="https://en.wikipedia.org/wiki/Palindromic_number" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Palindromic_number</a> )</p>
<p>Given any positive integer, you are supposed to find its paired palindromic number.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which gives a positive integer no more than 1000 digits.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print line by line the process of finding the palindromic number. The format of each line is the following:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">A + <span class="keyword">B </span>= C</span><br></pre></td></tr></table></figure>

<p>where <code>A</code> is the original number, <code>B</code> is the reversed <code>A</code>, and <code>C</code> is their sum. <code>A</code> starts being the input number, and this process ends until <code>C</code> becomes a palindromic number – in this case we print in the last line <code>C is a palindromic number.</code>; or if a palindromic number cannot be found in 10 iterations, print <code>Not found in 10 iterations.</code> instead.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">97152</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">97152 + 25179 &#x3D; 122331</span><br><span class="line">122331 + 133221 &#x3D; 255552</span><br><span class="line">255552 is a palindromic number.</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">196</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">196 + 691 &#x3D; 887</span><br><span class="line">887 + 788 &#x3D; 1675</span><br><span class="line">1675 + 5761 &#x3D; 7436</span><br><span class="line">7436 + 6347 &#x3D; 13783</span><br><span class="line">13783 + 38731 &#x3D; 52514</span><br><span class="line">52514 + 41525 &#x3D; 94039</span><br><span class="line">94039 + 93049 &#x3D; 187088</span><br><span class="line">187088 + 880781 &#x3D; 1067869</span><br><span class="line">1067869 + 9687601 &#x3D; 10755470</span><br><span class="line">10755470 + 07455701 &#x3D; 18211171</span><br><span class="line">Not found in 10 iterations.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个不大于1000位的正整数A,尝试寻找一个回文数:</p>
<ol>
<li>如果这个数本身就是回文数,输出<code>A is a palindromic number.</code></li>
<li>如果这个数不是回文数,则寻找它的延迟回文数:<ul>
<li>将这个数A与它的反转数B相加,判断它们的和C是否为回文数,如果是,则C为延迟回文数,输出<code>C is a palindromic number.</code>.</li>
<li>如果C不是回文数,输出<code>A + B = C</code>,将C赋值给A,重复这个过程.</li>
<li>10步之内如果没有找到延迟回文数,则输出<code>Not found in 10 iterations.</code></li>
</ul>
</li>
<li>0也是回文数.</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题非常有意思,看似是考察回文数,但实际上是考察<strong>大数相加</strong>,因为输入的数有可能有好几百位的长度,绝对不能够用整型相加得到和,肯定会溢出的.</p>
<p>大数相加的操作比较简单,就是将两个数字都作为字符串来相加,因为它们的长度都是相同的,所以直接逐位相加就可以了,得到的结果仍作为字符串.</p>
<p>另一个比较坑的点,题目没有说如果输入是回文数那就可以直接输出了,我当时还以为还要再加一次才行,例如输入0,我还以为要输出:</p>
<blockquote>
<p>0+0=0<br>0 is a palindromic number.</p>
</blockquote>
<p>结果并不用,直接输出结果就可以了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先实现一个<a href="https://jiayaoo3o.github.io/2019/04/23/1069-The-Black-Hole-of-Numbers/">1069 The Black Hole of Numbers</a>就已经写过的反转字符串的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Reverse</span>(<span class="params"><span class="keyword">string</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] num = input.ToCharArray();</span><br><span class="line">    Array.Reverse(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">string</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再实现一个用于将大数相加的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">AddStrNumber</span>(<span class="params"><span class="keyword">string</span> input, <span class="keyword">string</span> reversed</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> sum = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//记录进位信息.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = input.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = (((<span class="keyword">int</span>)input[i] - <span class="number">48</span> + (<span class="keyword">int</span>)reversed[i] - <span class="number">48</span> + flag) % <span class="number">10</span>) + sum;</span><br><span class="line">        flag = ((<span class="keyword">int</span>)input[i] - <span class="number">48</span> + (<span class="keyword">int</span>)reversed[i] - <span class="number">48</span> + flag) / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag == <span class="number">1</span> ? <span class="string">"1"</span> + sum : sum;<span class="comment">//最终结果如果有进位得在前面加1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> input = Console.ReadLine();</span><br><span class="line">    <span class="keyword">string</span> sum = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> reversed;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        reversed = Reverse(input);</span><br><span class="line">        <span class="keyword">if</span> (input == reversed)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125; is a palindromic number."</span>, input);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = AddStrNumber(input, reversed);</span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125; + &#123;1&#125; = &#123;2&#125;"</span>, input, reversed, sum);</span><br><span class="line">        input = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">"Not found in 10 iterations."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1132 Cut Integer</title>
    <url>/2019/05/06/1132-Cut-Integer/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Cutting an integer means to cut a K digits lone integer Z into two integers of (K/2) digits long integers A and B. For example, after cutting Z = 167334, we have A = 167 and B = 334. It is interesting to see that Z can be devided by the product of A and B, as 167334 / (167 × 334) = 3. Given an integer Z, you are supposed to test if it is such an integer.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20). Then N lines follow, each gives an integer Z (10 ≤ Z &lt;2<sup>31</sup>). It is guaranteed that the number of digits of Z is an even number.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print a single line <code>Yes</code> if it is such a number, or <code>No</code> if not.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">167334</span><br><span class="line">2333</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个偶数位的整数,平均分割成两部分,如果这两部分相乘,可以被这个偶数位整数整除,则输出Yse,否则输出No.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题就体现出面向对象语言的优势了,直接字符串分割转整型就完事了,根本不需要除法逐位取数字.</p>
<p>判断的时候要注意一点0不能被模,所以首先要先把0排除了,而因为这个输入整数是大于等于10的,所以只有后半部分有可能是0.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">int</span> firstPart = <span class="keyword">int</span>.Parse(input.Substring(<span class="number">0</span>, input.Length / <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">int</span> secondPart = <span class="keyword">int</span>.Parse(input.Substring(input.Length / <span class="number">2</span>, input.Length / <span class="number">2</span>));</span><br><span class="line">        Console.WriteLine(secondPart != <span class="number">0</span> &amp;&amp; <span class="keyword">int</span>.Parse(input) % (firstPart * secondPart) == <span class="number">0</span> ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1128 N Queens Puzzle</title>
    <url>/2019/05/05/1128-N-Queens-Puzzle/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The “eight queens puzzle” is the problem of placing eight chess queens on an 8×8 chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general <em>N</em> queens problem of placing <em>N</em> non-attacking queens on an <em>N</em>×<em>N</em> chessboard. (From Wikipedia - “Eight queens puzzle”.)</p>
<p>Here you are NOT asked to solve the puzzles. Instead, you are supposed to judge whether or not a given configuration of the chessboard is a solution. To simplify the representation of a chessboard, let us assume that no two queens will be placed in the same column. Then a configuration can be represented by a simple integer sequence (<em>Q</em>1,<em>Q</em>2,⋯,<em>QN</em>), where <em>Qi</em> is the row number of the queen in the <em>i</em>-th column. For example, Figure 1 can be represented by (4, 6, 8, 2, 7, 1, 3, 5) and it is indeed a solution to the 8 queens puzzle; while Figure 2 can be represented by (4, 6, 7, 2, 8, 1, 9, 5, 3) and is NOT a 9 queens’ solution.</p>
<table>
<thead>
<tr>
<th align="center"><img src="https://images.ptausercontent.com/7d0443cf-5c19-4494-98a6-0f0f54894eaa.jpg" alt="8q.jpg"></th>
<th></th>
<th align="center"><img src="https://images.ptausercontent.com/d187e37a-4eb8-4215-8e2c-040a73c5c8d8.jpg" alt="9q.jpg"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Figure 1</td>
<td></td>
<td align="center">Figure 2</td>
</tr>
</tbody></table>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains several test cases. The first line gives an integer <em>K</em> (1&lt;<em>K</em>≤200). Then <em>K</em> lines follow, each gives a configuration in the format “<em>N</em> <em>Q</em>1 <em>Q</em>2 … <em>QN</em>“, where 4≤<em>N</em>≤1000 and it is guaranteed that 1≤<em>Qi<em>≤</em>N</em> for all <em>i</em>=1,⋯,<em>N</em>. The numbers are separated by spaces.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each configuration, if it is a solution to the <em>N</em> queens problem, print <code>YES</code> in a line; or <code>NO</code> if not.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">8 4 6 8 2 7 1 3 5</span><br><span class="line">9 4 6 7 2 8 1 9 5 3</span><br><span class="line">6 1 5 2 6 4 3</span><br><span class="line">5 1 3 5 2 4</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个棋盘序列,让你判断这个棋盘上的皇后位置是否符合正确摆放方法:</p>
<blockquote>
<p>棋盘的横,竖,对角线都没有重复的皇后.</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题如果想要用多重循环暴力解法,那肯定是走错路了,这里给一个另类的解法,使用哈希表.</p>
<p>我们知道,一旦一个棋盘的某一个位置放了一个皇后,那这个皇后所在的行,列,上对角线,下对角线就不能再次使用了,所以我们可以将行,列,对角线都作为哈希表,一旦某个棋子有了一个位置,那哈希表内对应的行,列,对角线都置为-1,下一个棋子只要判断自己所在的行,列,对角线的哈希表值是否为-1来判断自己是否已经重复.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先实现最关键的判断输入的棋盘是否符合正确摆放位置的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsNQueensPuzzleSolution</span>(<span class="params"><span class="keyword">string</span> chessInfo</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] chessBoard = chessInfo.Split();</span><br><span class="line">    <span class="keyword">int</span> queensCount = <span class="keyword">int</span>.Parse(chessBoard[<span class="number">0</span>].ToString());<span class="comment">//皇后的数量.</span></span><br><span class="line">    <span class="keyword">int</span>[] rows = <span class="keyword">new</span> <span class="keyword">int</span>[queensCount + <span class="number">1</span>];<span class="comment">//行哈希表,如果皇后在某行,哈希表内的位置即设置为-1.</span></span><br><span class="line">    <span class="keyword">int</span>[] columns = <span class="keyword">new</span> <span class="keyword">int</span>[queensCount + <span class="number">1</span>];<span class="comment">//题目已经明确列是不会重复的,所以这里可以不写列哈希表.</span></span><br><span class="line">    <span class="keyword">int</span>[] upDiagonal = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * queensCount];<span class="comment">//上对角线哈希表.</span></span><br><span class="line">    <span class="keyword">int</span>[] downDiagonal = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * queensCount + <span class="number">1</span>];<span class="comment">//下对角线哈希表.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chessBoard.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="keyword">int</span>.Parse(chessBoard[i].ToString());<span class="comment">//获取行号和列号.</span></span><br><span class="line">        <span class="keyword">int</span> column = i;</span><br><span class="line">        <span class="keyword">if</span> (rows[row] == <span class="number">-1</span> || columns[column] == <span class="number">-1</span> || upDiagonal[queensCount + row - column] == <span class="number">-1</span> || downDiagonal[row + column] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//上对角线的特点:行-列始终相等.</span></span><br><span class="line">            <span class="comment">//下对角线的特点:行+列始终相等.</span></span><br><span class="line">            <span class="comment">//因为row-column可能为负数,而下标不能为负,所以要加上queensCount让它始终为正.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rows[row] = <span class="number">-1</span>;</span><br><span class="line">            columns[column] = <span class="number">-1</span>;</span><br><span class="line">            upDiagonal[queensCount + (row - column)] = <span class="number">-1</span>;</span><br><span class="line">            downDiagonal[row + column] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lines = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> chessInfo = Console.ReadLine();</span><br><span class="line">        Console.WriteLine(IsNQueensPuzzleSolution(chessInfo) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>27.移除元素</title>
    <url>/2019/05/04/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 <em>nums</em> 和一个值 <em>val<em>，你需要*</em>原地**移除所有数值等于 *val</em> 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用双向指针来解决这道题,一个指针从头开始,一个指针从末尾开始,只要头指针等于val,就将尾指针不等于val的值放到头指针的位置,这样逐步扫过去,结果就是目标数组了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RemoveElement</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> val</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.Length;<span class="comment">//尾指针.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val)<span class="comment">//如果头指针对应位置等于val,就用尾指针覆盖.</span></span><br><span class="line">        &#123;</span><br><span class="line">            n--;</span><br><span class="line">            nums[i] = nums[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>26.删除排序数组中的重复项</title>
    <url>/2019/05/04/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span>。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用快慢指针来解决,定义两个指针,一个快一个慢,如果快的和慢的不相等,就让快的覆盖慢的.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RemoveDuplicates</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.Length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.Length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i])<span class="comment">//用快慢指针解决,后面的数覆盖前面的重复值.</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>21.合并两个有序链表</title>
    <url>/2019/05/04/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>创建一条新的链表,然后逐个比较两个链表的节点大小,谁的节点小就将这个节点接到新链表后面,然后往后移动.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">MergeTwoLists</span>(<span class="params">ListNode l1, ListNode l2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode head = node;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val)</span><br><span class="line">        &#123;</span><br><span class="line">            node.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    node.next = l1 != <span class="literal">null</span> ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1124 Raffle for Weibo Followers</title>
    <url>/2019/05/04/1124-Raffle-for-Weibo-Followers/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>John got a full mark on PAT. He was so happy that he decided to hold a raffle（抽奖） for his followers on Weibo – that is, he would select winners from every N followers who forwarded his post, and give away gifts. Now you are supposed to help him generate the list of winners.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives three positive integers M (≤ 1000), N and S, being the total number of forwards, the skip number of winners, and the index of the first winner (the indices start from 1). Then M lines follow, each gives the nickname (a nonempty string of no more than 20 characters, with no white space or return) of a follower who has forwarded John’s post.</p>
<p>Note: it is possible that someone would forward more than once, but no one can win more than once. Hence if the current candidate of a winner has won before, we must skip him/her and consider the next one.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print the list of winners in the same order as in the input, each nickname occupies a line. If there is no winner yet, print <code>Keep going...</code> instead.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 3 2</span><br><span class="line">Imgonnawin!</span><br><span class="line">PickMe</span><br><span class="line">PickMeMeMeee</span><br><span class="line">LookHere</span><br><span class="line">Imgonnawin!</span><br><span class="line">TryAgainAgain</span><br><span class="line">TryAgainAgain</span><br><span class="line">Imgonnawin!</span><br><span class="line">TryAgainAgain</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PickMe</span><br><span class="line">Imgonnawin!</span><br><span class="line">TryAgainAgain</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3 5</span><br><span class="line">Imgonnawin!</span><br><span class="line">PickMe</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Keep going...</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>john想在微博搞一个粉丝抽奖,现在要做一个抽奖程序,要求如下:</p>
<ul>
<li><p>先输入三个数M,N,S<br>M是指粉丝总人数.<br>N是指下一个粉丝所在的位置的间隔.<br>S是指第一个中奖的位置(从1开始数).<br>例如9 3 2是指粉丝一共9个人,第2个人就是第一个中奖的位置,间隔是3即第2个往后数3个人也就是第5个粉丝,第8个粉丝也中奖位置.</p>
</li>
<li><p>粉丝名单里面有的粉丝可能不止出现了一次,如果选中的粉丝已经中奖过了,则往后推一个位置.</p>
</li>
<li><p>如果没有粉丝中奖,则输出<code>Keep going...</code></p>
</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题难度不算高,要做的只是判断某个粉丝是否中过奖,中过了就跳到下一个就好了.这里可以有两个思路来判断粉丝是否中过奖,1可以用哈希表将中奖的粉丝设置为1,然后每次检查哈希表中的值是否为1来判断是否曾经中奖;2可以用泛型列表List的Contains()函数来判断粉丝是否已经存在于获奖名单里.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> line = Console.ReadLine();</span><br><span class="line">    <span class="keyword">int</span> totalForwards = <span class="keyword">int</span>.Parse(line.Split()[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> skipNumber = <span class="keyword">int</span>.Parse(line.Split()[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> firstWinner = <span class="keyword">int</span>.Parse(line.Split()[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (totalForwards &lt; firstWinner)<span class="comment">//没有中奖者的情况只有一种,那就是粉丝数比第一个获奖位置还要小.</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Keep going..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="keyword">string</span>&gt; winners = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();<span class="comment">//用来判断粉丝曾经是否已经获奖</span></span><br><span class="line">        <span class="keyword">string</span> follower;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totalForwards ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            follower = Console.ReadLine();</span><br><span class="line">            <span class="keyword">if</span> (i == firstWinner)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (winners.Contains(follower))<span class="comment">//如果粉丝已经获奖过,那就将位置+1;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    firstWinner += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    winners.Add(follower);<span class="comment">//如果没有获奖那就将他添加入获奖名单.</span></span><br><span class="line">                    Console.WriteLine(follower);</span><br><span class="line">                    firstWinner += skipNumber;<span class="comment">//将获奖位置向后挪动skipNumber个位置.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>windows10专业版激活</title>
    <url>/2019/05/03/windows10%E4%B8%93%E4%B8%9A%E7%89%88%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<h2 id="激活windows的原理"><a href="#激活windows的原理" class="headerlink" title="激活windows的原理"></a>激活windows的原理</h2><p>GitHub上的这个开源的<a href="https://github.com/Wind4/vlmcsd" target="_blank" rel="noopener">KMS模拟器项目</a>能够让你的服务器成为一台kms,所以只要你有一台服务器,在服务器上运行这个软件,即可用于激活Windows.</p>
<p>而你在服务器运行这个软件之后,需要激活的电脑只需要在命令行中输入几句激活的指令就可以连接到该服务器进行激活验证,<strong>这个过程不需要安装任何不安全的软件,和网上的所谓破解激活软件完全不一样</strong>.</p>
<p>如果你没有服务器,也可以用网上别人公开的服务器,理论上只要对方的服务器没有挂掉,你就可以一直激活使用,而且kms服务器只是一个激活服务器,并不能操作客户端,所以最多只是这个激活服务器不能用了,网上说的能用kms服务器控制你的电脑,那就是扯淡.</p>
<a id="more"></a>

<h2 id="激活Windows10专业版"><a href="#激活Windows10专业版" class="headerlink" title="激活Windows10专业版"></a>激活Windows10专业版</h2><ol>
<li><p>以管理员身份运行powershell</p>
</li>
<li><p>输入以下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">slmgr.vbs <span class="literal">-upk</span></span><br><span class="line">slmgr.vbs <span class="literal">-ipk</span> W269N<span class="literal">-WFGWX</span><span class="literal">-YVC9B</span><span class="literal">-4J6C9</span><span class="literal">-T83GX</span></span><br><span class="line">slmgr.vbs <span class="literal">-skms</span> <span class="number">119.29</span>.<span class="number">248.79</span></span><br><span class="line">slmgr.vbs <span class="literal">-ato</span></span><br><span class="line">slmgr.vbs <span class="literal">-dlv</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="激活Windows10企业版"><a href="#激活Windows10企业版" class="headerlink" title="激活Windows10企业版"></a>激活Windows10企业版</h2><ol>
<li><p>以管理员身份运行powershell</p>
</li>
<li><p>输入以下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">slmgr.vbs <span class="literal">-upk</span></span><br><span class="line">slmgr.vbs <span class="literal">-ipk</span> NPPR9<span class="literal">-FWDCX</span><span class="literal">-D2C8J</span><span class="literal">-H872K</span><span class="literal">-2YT43</span></span><br><span class="line">slmgr.vbs <span class="literal">-skms</span> <span class="number">119.29</span>.<span class="number">248.79</span></span><br><span class="line">slmgr.vbs <span class="literal">-ato</span></span><br><span class="line">slmgr.vbs <span class="literal">-dlv</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>1120 Friend Numbers</title>
    <url>/2019/05/03/1120-Friend-Numbers/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Two integers are called “friend numbers” if they share the same sum of their digits, and the sum is their “friend ID”. For example, 123 and 51 are friend numbers since 1+2+3 = 5+1 = 6, and 6 is their friend ID. Given some numbers, you are supposed to count the number of different frind ID’s among them.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N. Then N positive integers are given in the next line, separated by spaces. All the numbers are less than 10<sup>4</sup>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in the first line the number of different frind ID’s among the given integers. Then in the second line, output the friend ID’s in increasing order. The numbers must be separated by exactly one space and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">123 899 51 998 27 33 36 12</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 6 9 26</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>如果两个整数的各位数字之和相同,那这两个数字就是”友谊数”,他们的和叫做”友谊ID”.现在给定一个数字序列,让你输出他们的各个友谊ID的总数,并且在下一行从小到大输出各个友谊ID.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题很多人会直接用哈希表set来做,但是其实还有更简单的方法,因为这些输入的整数不会大于10000,也就是说最大也就是9999,而友谊id最大也就可能是4个9即36,所以我们完全可以直接用整型数组做哈希表而不用直接创建set.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先创建一个逐位数字求和的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetDigitsSum</span>(<span class="params"><span class="keyword">int</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (input != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result += input % <span class="number">10</span>;</span><br><span class="line">        input /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">    <span class="keyword">string</span>[] inputs = Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">int</span>[] friendIDs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];<span class="comment">//创建一个长度为40的整型数组做哈希表,其实只要33个位置就够了.</span></span><br><span class="line">    <span class="keyword">int</span> friendID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> input <span class="keyword">in</span> inputs)</span><br><span class="line">    &#123;</span><br><span class="line">        friendID = GetDigitsSum(<span class="keyword">int</span>.Parse(input));</span><br><span class="line">        <span class="keyword">if</span> (friendIDs[friendID] != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            friendIDs[friendID] = <span class="number">1</span>;<span class="comment">//将对应的ID位置数值值为1.</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; friendIDs.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (friendIDs[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count--;</span><br><span class="line">            Console.Write(count == <span class="number">0</span> ? i.ToString() : i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1116 Come on! Let&#39;s C</title>
    <url>/2019/05/03/1116-Come-on-Let-s-C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>“Let’s C” is a popular and fun programming contest hosted by the College of Computer Science and Technology, Zhejiang University. Since the idea of the contest is for fun, the award rules are funny as the following:</p>
<ul>
<li>0.The Champion will receive a “Mystery Award” (such as a BIG collection of students’ research papers…).</li>
<li>1.Those who ranked as a prime number will receive the best award – the Minions (小黄人)!</li>
<li>2.Everyone else will receive chocolates.</li>
</ul>
<p>Given the final ranklist and a sequence of contestant ID’s, you are supposed to tell the corresponding awards.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10<sup>4</sup>), the total number of contestants. Then N lines of the ranklist follow, each in order gives a contestant’s ID (a 4-digit number). After the ranklist, there is a positive integer K followed by K query ID’s.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each query, print in a line <code>ID: award</code> where the award is <code>Mystery Award</code>, or <code>Minion</code>, or <code>Chocolate</code>. If the ID is not in the ranklist, print <code>Are you kidding?</code>instead. If the ID has been checked before, print <code>ID: Checked</code>.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1111</span><br><span class="line">6666</span><br><span class="line">8888</span><br><span class="line">1234</span><br><span class="line">5555</span><br><span class="line">0001</span><br><span class="line">6</span><br><span class="line">8888</span><br><span class="line">0001</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">8888</span><br><span class="line">2222</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8888: Minion</span><br><span class="line">0001: Chocolate</span><br><span class="line">1111: Mystery Award</span><br><span class="line">2222: Are you kidding?</span><br><span class="line">8888: Checked</span><br><span class="line">2222: Are you kidding?</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个排名列表,再给定一个查询列表,输出查询列表中每个id对应的排名所能获得的奖品,规则如下:</p>
<ul>
<li>排名列表的排名从1开始</li>
<li>如果id排名第一,将获得<code>Mystery Award</code></li>
<li>如果id排名是素数,将获得<code>Minion</code></li>
<li>其他名次,将获得<code>Chocolate</code></li>
<li>如果查询用户没有名次,输出<code>Are you kidding?</code></li>
<li>如果查询的用户已经查询过了,输出<code>Checked</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是相对简单的一道题,用泛型字典做哈希表,存放用户id和对应的排名值,如果被查询过了,就将排名值改为-1.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先实现一个检查素数函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsPrime</span>(<span class="params"><span class="keyword">int</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.Sqrt(input); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (input % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; rankList = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rankList.Add(Console.ReadLine(), i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">string</span> queryID;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        queryID = Console.ReadLine();</span><br><span class="line">        <span class="keyword">if</span> (!rankList.ContainsKey(queryID))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125;: Are you kidding?"</span>, queryID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rankList[queryID] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"&#123;0&#125;: Checked"</span>, queryID);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rankList[queryID] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"&#123;0&#125;: Mystery Award"</span>, queryID);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (IsPrime(rankList[queryID]))</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"&#123;0&#125;: Minion"</span>, queryID);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"&#123;0&#125;: Chocolate"</span>, queryID);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rankList[queryID] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>20.有效的括号</title>
    <url>/2019/05/03/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 <code>(</code>，<code>)</code>，<code>{</code>，<code>}</code>，<code>[</code>，<code>]</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"(]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"([)]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题一个简洁的解法就是使用栈.只要属于左括号的,我们就将它入栈;只要是属于右括号的,我们就将栈中的元素取出,看看两者是不是一对,如果不是,说明不是有效的括号;</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValid</span>(<span class="params"><span class="keyword">string</span> s</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">char</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="keyword">char</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span> || s[i] == <span class="string">'&#123;'</span> || s[i] == <span class="string">'['</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.Push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.Count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> symbol = stack.Pop();</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">')'</span> &amp;&amp; symbol != <span class="string">'('</span> || s[i] == <span class="string">']'</span> &amp;&amp; symbol != <span class="string">'['</span> || s[i] == <span class="string">'&#125;'</span> &amp;&amp; symbol != <span class="string">'&#123;'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.Count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>14.最长公共前缀</title>
    <url>/2019/05/01/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code></p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用第一个字符串作为基准字符串,用剩下的字符串与之逐位比较.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">LongestCommonPrefix</span>(<span class="params"><span class="keyword">string</span>[] strs</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.Length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strs.Length == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].Length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.Length; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j].Length &lt;= i || strs[<span class="number">0</span>][i] != strs[j][i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].Substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>13.罗马数字转整数</title>
    <url>/2019/05/01/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: "III"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: "IV"</span></span><br><span class="line"><span class="section">输出: 4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: "IX"</span></span><br><span class="line"><span class="section">输出: 9</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"LVIII"</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: L = <span class="number">50</span>, V= <span class="number">5</span>, III = <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从右往左逐个比较,如果左边的数比右边的数大,那就加上这个数;如果左边的数比右边的数小,那就减去这个数.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RomanToInt</span>(<span class="params"><span class="keyword">string</span> s</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; romanNumber = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">        &#123; <span class="string">'I'</span>, <span class="number">1</span> &#125;,&#123; <span class="string">'V'</span>, <span class="number">5</span> &#125;,&#123; <span class="string">'X'</span>, <span class="number">10</span> &#125;,&#123; <span class="string">'L'</span>, <span class="number">50</span> &#125;,&#123; <span class="string">'C'</span>, <span class="number">100</span> &#125;,&#123; <span class="string">'D'</span>, <span class="number">500</span> &#125;,&#123; <span class="string">'M'</span>, <span class="number">1000</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> result = romanNumber[s[s.Length - <span class="number">1</span>]];<span class="comment">//先拿出倒数第一位的数.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.Length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//从倒数第二位开始.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (romanNumber[s[i]] &lt; romanNumber[s[i + <span class="number">1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            result -= romanNumber[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result += romanNumber[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>9.回文数</title>
    <url>/2019/05/01/9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">121</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">-121</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">解释:</span> <span class="string">从左向右读,</span> <span class="string">为</span> <span class="number">-121</span> <span class="string">。</span> <span class="string">从右向左读,</span> <span class="string">为</span> <span class="number">121</span><span class="bullet">-</span> <span class="string">。因此它不是一个回文数。</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">10</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">解释:</span> <span class="string">从右向左读,</span> <span class="string">为</span> <span class="number">01</span> <span class="string">。因此它不是一个回文数。</span></span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong></p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单的方法就是转化为字符串判断首尾是否一致.</p>
<p>不转化成字符串的方法就是用<a href="https://jiayaoo3o.github.io/2019/05/01/7-整数反转/">7.整数反转</a>里说到的方法将整数反转再判断是否相等.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>直接转化字符串:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPalindrome</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">string</span> str = x.ToString();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.Length / <span class="number">2</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (str[i] != str[str.Length - i - <span class="number">1</span>])</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反转整数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPalindrome</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num = x;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = result * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == x ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>7.整数反转</title>
    <url>/2019/05/01/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">123</span></span><br><span class="line">输出: <span class="number">321</span></span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">-123</span></span><br><span class="line">输出: <span class="number">-321</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">120</span></span><br><span class="line">输出: <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>关于反转类题目,千万不要一开始就想着转变成字符数组然后调用Array.Reverse(),应该用模得到余数,再逐次乘以10来获得反转数.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Reverse</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = n * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (result / <span class="number">10</span> != n)<span class="comment">//不等于n说明溢出了.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        n = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1.两数之和</title>
    <url>/2019/05/01/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>两重循环判断两数之和是否为目标值.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">TwoSum</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1112 Stucked Keyboard</title>
    <url>/2019/05/01/1112-Stucked-Keyboard/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>On a broken keyboard, some of the keys are always stucked. So when you type some sentences, the characters corresponding to those keys will appear repeatedly on screen for <em>k</em> times.</p>
<p>Now given a resulting string on screen, you are supposed to list all the possible stucked keys, and the original string.</p>
<p>Notice that there might be some characters that are typed repeatedly. The stucked key will always repeat output for a fixed <em>k</em> times whenever it is pressed. For example, when <em>k</em>=3, from the string <code>thiiis iiisss a teeeeeest</code> we know that the keys <code>i</code> and <code>e</code> might be stucked, but <code>s</code> is not even though it appears repeatedly sometimes. The original string could be <code>this isss a teest</code>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the 1st line gives a positive integer <em>k</em> (1&lt;<em>k</em>≤100) which is the output repeating times of a stucked key. The 2nd line contains the resulting string on screen, which consists of no more than 1000 characters from {a-z}, {0-9} and <code>_</code>. It is guaranteed that the string is non-empty.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the possible stucked keys, in the order of being detected. Make sure that each key is printed once only. Then in the next line print the original string. It is guaranteed that there is at least one stucked key.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">caseee1__thiiis_iiisss_a_teeeeeest</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ei</span><br><span class="line">case1__this_isss_a_teest</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一个坏掉的键盘上有一些按键是卡住的,所以当我们输入句子的时候,总有一些按键会固定重复出现K次,每按一下这个坏了的按键,字符就会重复出现K次,现在给定一个重复次数K,和给一个结果字符串,尝试找出粘键的按键和原始的字符串,每一个结果字符串保证至少有一个坏掉的按键.</p>
<p>注意,上面的例子中,e和i是坏掉的按键,因为每次按一下e和i,他们都会重复3次,但是s却不是,因为它并没有每按一次s就重复3次.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题需要记录每个按键是否坏掉,也就是说我们要记录字符串里每个字符的具体情况,所以可以使用哈希表.</p>
<p>哈希表内每个字符对应的位置的值,代表着这个按键的情况:</p>
<ul>
<li><p>如果还没判断,按键默认值就是0.</p>
</li>
<li><p>如果判断出这个按键没有坏,就将值设置为-1.</p>
</li>
<li><p>判断按键已经卡住了,就把按键设置为1.</p>
</li>
</ul>
<p>要如何判断按键是否卡住,可以设置一个变量为nowKey,表示现在正在判断的按键字符;再设置一个nowKeyCount变量表示这个正在判断的字符已经连续出现的次数,如果nowKeyCount%K==0表示这个nowKey重复出现了k的倍数次,是坏键;如果不等于0,说明nowKey出现的次数不是k的倍数,这个键不是坏键.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> repeatedlyTimes = <span class="keyword">int</span>.Parse(Console.ReadLine());<span class="comment">//重复次数.</span></span><br><span class="line">    <span class="keyword">string</span> str = Console.ReadLine();<span class="comment">//输入的结果字符串.</span></span><br><span class="line">    <span class="keyword">int</span>[] characters = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];<span class="comment">//哈希表.</span></span><br><span class="line">    <span class="keyword">char</span> nowKey = str[<span class="number">0</span>];<span class="comment">//当前判断的按键,先将它设置为字符串第一个字符.</span></span><br><span class="line">    <span class="keyword">int</span> nowKeyCount = <span class="number">0</span>;<span class="comment">//当前判断按键出现的次数.</span></span><br><span class="line">    <span class="keyword">string</span> brokenKeys = <span class="string">""</span>;<span class="comment">//坏掉的按键结果.</span></span><br><span class="line">    <span class="keyword">string</span> originalString = <span class="string">""</span>;<span class="comment">//原始字符串.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> character <span class="title">in</span> (<span class="params">str + <span class="string">" "</span></span>))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//for循环的每一个字符Character会比nowKey领先一个位置,为了保证最后一个字符的结果能得到比较,要在str字符串后面再加一个位置.</span></span><br><span class="line">        <span class="keyword">if</span> (character == nowKey)</span><br><span class="line">        &#123;</span><br><span class="line">            nowKeyCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nowKeyCount % repeatedlyTimes == <span class="number">0</span> &amp;&amp; characters[nowKey] != <span class="number">-1</span>)<span class="comment">//characters[nowKey] != -1是为了保证已经被判断没坏的字符不能被重新设置为坏了.</span></span><br><span class="line">            &#123;</span><br><span class="line">                characters[nowKey] = <span class="number">1</span>;<span class="comment">//坏了.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                characters[nowKey] = <span class="number">-1</span>;<span class="comment">//没坏.</span></span><br><span class="line">            &#125;</span><br><span class="line">            nowKey = character;<span class="comment">//判断结束,将新的character赋给nowKey,成为新的判断对象.</span></span><br><span class="line">            nowKeyCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (characters[str[i]] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!brokenKeys.Contains(str[i].ToString()))<span class="comment">//保证坏了的键只出现一次.</span></span><br><span class="line">            &#123;</span><br><span class="line">                brokenKeys += str[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i += repeatedlyTimes - <span class="number">1</span>;<span class="comment">//让i往后跳repeatedlyTimes - 1个位置,例如重复次数为3,那就让i往后跳2个位置,这样就可以保证按键只输出一次.</span></span><br><span class="line">            originalString += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            originalString += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(brokenKeys);</span><br><span class="line">    Console.WriteLine(originalString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1108 Finding Average</title>
    <url>/2019/04/30/1108-Finding-Average/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The basic task is simple: given <em>N</em> real numbers, you are supposed to calculate their average. But what makes it complicated is that some of the input numbers might not be legal. A <strong>legal</strong> input is a real number in [−1000,1000] and is accurate up to no more than 2 decimal places. When you calculate the average, those illegal numbers must not be counted in.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤100). Then <em>N</em> numbers are given in the next line, separated by one space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each illegal input number, print in a line <code>ERROR: X is not a legal number</code> where <code>X</code> is the input. Then finally print in a line the result: <code>The average of K numbers is Y</code> where <code>K</code> is the number of legal inputs and <code>Y</code> is their average, accurate to 2 decimal places. In case the average cannot be calculated, output <code>Undefined</code> instead of <code>Y</code>. In case <code>K</code> is only 1, output <code>The average of 1 number is Y</code> instead.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">5 -3.2 aaa 9999 2.3.4 7.123 2.35</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR: aaa is not a legal number</span><br><span class="line">ERROR: 9999 is not a legal number</span><br><span class="line">ERROR: 2.3.4 is not a legal number</span><br><span class="line">ERROR: 7.123 is not a legal number</span><br><span class="line">The average of 3 numbers is 1.38</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">aaa -9999</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR: aaa is not a legal number</span><br><span class="line">ERROR: -9999 is not a legal number</span><br><span class="line">The average of 0 numbers is Undefined</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>任务很简单,就是算所有数的平均数,但是要求是只算所有”合法”的数的平均数,规则为:</p>
<ul>
<li>输入的数如果不是有理数,不合法.</li>
<li>输入的数如果大于1000或者小于-1000,不合法.</li>
<li>输入的数如果小数点后超过2位,不合法.</li>
</ul>
<p>输出规则为:</p>
<ul>
<li>如果有不合法的数,那就先逐行依次输出 <code>ERROR: X is not a legal number</code></li>
<li>如果合法数为0,那就输出<code>The average of 0 numbers is Undefined</code></li>
<li>如果合法数为1,那就输出<code>The average of 1 number is Y</code>,注意这里的number没有加s.</li>
<li>剩余情况,就输出<code>The average of K numbers is Y</code>,注意,平均数规定要精确到小数点后两位.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题难度不高,我们要做的其实只有三件事情:</p>
<ul>
<li>判断输入的某个数是否合法.</li>
<li>把不合法的数收集起来,然后输出.</li>
<li>记录合法数的和与合法数的数量,求平均值.</li>
</ul>
<p>对于收集不合法的数,我们可以使用泛型队列,只要判断不合法,就将它入队,等到全部判断完了,再将不合法的数出队,这样可以保证顺序不出错.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先实现一个用于判断输入是否合法的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsLegalInput</span>(<span class="params"><span class="keyword">string</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">double</span>.TryParse(input, <span class="keyword">out</span> result))<span class="comment">//使用TryParse函数尝试转换,转换失败说明绝对不是合法数字,转换成功会将转换结果赋值给result.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">-1000</span> || result &gt; <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//到了这个位置,开始判断是否是在小数点后两位之内,如果字符串的长度减去小数点的下标位置大于3,说明小数点后面不止两位了.</span></span><br><span class="line">            <span class="comment">//这里要注意,要用input判断而是不result来判断,因为类似1.000000这种字符串转换成double型的result后会直接变成1,所以要直接用字符串来做判断.</span></span><br><span class="line">            <span class="comment">//如果indexOf('.')的结果是-1那说明没有小数点,肯定是合法数字.</span></span><br><span class="line">            <span class="keyword">if</span> (input.IndexOf(<span class="string">'.'</span>) &gt; <span class="number">0</span> &amp;&amp; input.ToString().Length - input.ToString().IndexOf(<span class="string">'.'</span>) &gt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">int</span> legalCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> legalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">string</span>[] inputs = Console.ReadLine().Split();</span><br><span class="line">    Queue&lt;<span class="keyword">string</span>&gt; illegalInput = <span class="keyword">new</span> Queue&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> input <span class="keyword">in</span> inputs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsLegalInput(input))</span><br><span class="line">        &#123;</span><br><span class="line">            legalSum += <span class="keyword">double</span>.Parse(input);</span><br><span class="line">            legalCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            illegalInput.Enqueue(input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (illegalInput.Count != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"ERROR: &#123;0&#125; is not a legal number"</span>, illegalInput.Dequeue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (legalCount == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"The average of 0 numbers is Undefined"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (legalCount == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"The average of 1 number is &#123;0&#125;"</span>, legalSum.ToString(<span class="string">"0.00"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (legalCount &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"The average of &#123;0&#125; numbers is &#123;1&#125;"</span>, legalCount, (legalSum / legalCount).ToString(<span class="string">"0.00"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1100 Mars Numbers</title>
    <url>/2019/04/29/1100-Mars-Numbers/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>People on Mars count their numbers with base 13:</p>
<ul>
<li>Zero on Earth is called “tret” on Mars.</li>
<li>The numbers 1 to 12 on Earth is called “jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec” on Mars, respectively.</li>
<li>For the next higher digit, Mars people name the 12 numbers as “tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou”, respectively.</li>
</ul>
<p>For examples, the number 29 on Earth is called “hel mar” on Mars; and “elo nov” on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (&lt;100). Then <em>N</em> lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each number, print in a line the corresponding number in the other language.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">29</span><br><span class="line">5</span><br><span class="line">elo nov</span><br><span class="line">tam</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hel mar</span><br><span class="line">may</span><br><span class="line">115</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>火星的数字是13进制的,并且他们的数字并不用0~9来表示,而是:</p>
<ul>
<li>当数字是1<del>12时,用jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec来表示1</del>12.</li>
<li>当数字超过12,有两位时,高位用tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou来表示1~12.</li>
<li>0用tret表示.</li>
<li>当数字是13,也即火星上的”10”时,只用一个”tam”表示,”20”用”hel”表示,也就是说,当火星数字是10,20,30这种整数时,后面的零不用写.</li>
</ul>
<p>现在要你设计一个翻译程序,如果输入的是地球整数,那就把它翻译成13进制的火星数字;如果输入是火星数字,就把它翻译成10进制的地球数字.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题要考虑的情况相当相当多,既要进制转换,又要字符替换,还要对不同长度的数字进行不同情况的分析.</p>
<p>用火星数字获取火星文字,可以直接使用字符串数组,下标表示火星数字,数组存放着火星对应的文字.</p>
<p>用火星文字获取火星数字,可以使用泛型字典,通过火星文字直接获得对应的火星数字.</p>
<p>而这道题明确告诉我们火星的文字只有高低两位,所以判断的时候就比较方便.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先我们先实现一个地球数字转换成火星文字的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">translateToMars</span>(<span class="params"><span class="keyword">int</span> EarthNumber</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (EarthNumber == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"tret"</span>;<span class="comment">//如果地球数字输入0直接返回,不用判断了.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">string</span>[] lowerDigits = &#123; <span class="string">"tret"</span>, <span class="string">"jan"</span>, <span class="string">"feb"</span>, <span class="string">"mar"</span>, <span class="string">"apr"</span>, <span class="string">"may"</span>, <span class="string">"jun"</span>, <span class="string">"jly"</span>, <span class="string">"aug"</span>, <span class="string">"sep"</span>, <span class="string">"oct"</span>, <span class="string">"nov"</span>, <span class="string">"dec"</span> &#125;;</span><br><span class="line">    <span class="keyword">string</span>[] higherDigit = &#123; <span class="string">""</span>, <span class="string">"tam"</span>, <span class="string">"hel"</span>, <span class="string">"maa"</span>, <span class="string">"huh"</span>, <span class="string">"tou"</span>, <span class="string">"kes"</span>, <span class="string">"hei"</span>, <span class="string">"elo"</span>, <span class="string">"syy"</span>, <span class="string">"lok"</span>, <span class="string">"mer"</span>, <span class="string">"jou"</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span>[] number = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;<span class="comment">//number用于存放10进制转换成13进制的结果,结果只有两位,高位和低位.</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (EarthNumber != <span class="number">0</span>)<span class="comment">//进行进制转换.</span></span><br><span class="line">    &#123;</span><br><span class="line">        number[i--] = EarthNumber % <span class="number">13</span>;</span><br><span class="line">        EarthNumber /= <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (number[<span class="number">0</span>] == <span class="number">0</span>)<span class="comment">//如果进制转换的结果的第一位是0,例如05,07,09</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> lowerDigits[number[<span class="number">1</span>]];<span class="comment">//那就直接返回低位number[1]对应的数字的火星文字.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果进制转换的结果第一位不是0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number[<span class="number">1</span>] == <span class="number">0</span>)<span class="comment">//如果第二位是0,例如10,20,30</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> higherDigit[number[<span class="number">0</span>]];</span><br><span class="line">            <span class="comment">//那就直接输出高位number[0]对应的数字的火星文字,因为火星文字的低位0是不输出的.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> higherDigit[number[<span class="number">0</span>]] + <span class="string">" "</span> + lowerDigits[number[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再实现一个火星文字转地球数字的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">translateToEarth</span>(<span class="params"><span class="keyword">string</span> MarsNumber</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先创建两个字典用于通过火星文字得到火星数字.</span></span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; lowerDigits = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;() &#123;</span><br><span class="line">        &#123;<span class="string">"tret"</span>,<span class="number">0</span>&#125;,&#123;<span class="string">"jan"</span>,<span class="number">1</span>&#125;,&#123;<span class="string">"feb"</span>,<span class="number">2</span>&#125;,&#123;<span class="string">"mar"</span>,<span class="number">3</span>&#125;,&#123;<span class="string">"apr"</span>,<span class="number">4</span>&#125;,&#123;<span class="string">"may"</span>,<span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"jun"</span>,<span class="number">6</span>&#125;,&#123;<span class="string">"jly"</span>,<span class="number">7</span>&#125;,&#123;<span class="string">"aug"</span>,<span class="number">8</span>&#125;,&#123;<span class="string">"sep"</span>,<span class="number">9</span>&#125;,&#123;<span class="string">"oct"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"nov"</span>,<span class="number">11</span>&#125;,&#123;<span class="string">"dec"</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; higherDigit = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;() &#123;</span><br><span class="line">        &#123;<span class="string">"tam"</span>,<span class="number">1</span>&#125;,&#123;<span class="string">"hel"</span>,<span class="number">2</span>&#125;,&#123;<span class="string">"maa"</span>,<span class="number">3</span>&#125;,&#123;<span class="string">"huh"</span>,<span class="number">4</span>&#125;,&#123;<span class="string">"tou"</span>,<span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"kes"</span>,<span class="number">6</span>&#125;,&#123;<span class="string">"hei"</span>,<span class="number">7</span>&#125;,&#123;<span class="string">"elo"</span>,<span class="number">8</span>&#125;,&#123;<span class="string">"syy"</span>,<span class="number">9</span>&#125;,&#123;<span class="string">"lok"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"mer"</span>,<span class="number">11</span>&#125;,&#123;<span class="string">"jou"</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">string</span>[] numbers = MarsNumber.Split();<span class="comment">//尝试将火星文字进行分割.</span></span><br><span class="line">    <span class="keyword">if</span> (numbers.Length == <span class="number">1</span>)<span class="comment">//如果长度是1,说明只输入了一个单词.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lowerDigits.ContainsKey(numbers[<span class="number">0</span>]))<span class="comment">//如果这个单词在低位字典里,那就返回对应数字.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lowerDigits[numbers[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> higherDigit[numbers[<span class="number">0</span>]] * <span class="number">13</span>;<span class="comment">//如果在高位字典里,那就返回13乘以这个数字.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果长度是2,那就说明输入了两个单词,那就高位的乘以13,低位的直接获取.</span></span><br><span class="line">        <span class="keyword">return</span> higherDigit[numbers[<span class="number">0</span>]] * <span class="number">13</span> + lowerDigits[numbers[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">while</span> (count-- != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span>.TryParse(input, <span class="keyword">out</span> result))<span class="comment">//尝试转换成整型,如果成功那就是地球数字,如果失败那就是火星文字.</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(translateToMars(result));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(translateToEarth(input));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1092 To Buy or Not to Buy</title>
    <url>/2019/04/28/1092-To-Buy-or-Not-to-Buy/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is <code>Yes</code>, please tell her the number of extra beads she has to buy; or if the answer is <code>No</code>, please tell her the number of beads missing from the string.</p>
<p>For the sake of simplicity, let’s use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. For example, the 3rd string in Figure 1 is the one that Eva would like to make. Then the 1st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2nd one is not since there is no black bead and one less red bead.</p>
<p><img src="https://images.ptausercontent.com/b7e2ffa6-8819-436d-ad79-a41263abe914.jpg" alt="Figure 1"></p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print your answer in one line. If the answer is <code>Yes</code>, then also output the number of extra beads Eva has to buy; or if the answer is <code>No</code>, then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ppRYYGrrYBR2258</span><br><span class="line">YrR8RrY</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes 8</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ppRYYGrrYB225</span><br><span class="line">YrR8RrY</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No 2</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>Eva想要买各种颜色的珠子做手链,但是商店老板只卖整条的,不肯单卖,所以现在要判断,老板提供的整条手链里面有没有我们需要的全部珠子:</p>
<ul>
<li>如果有,就输出<strong>Yes 剩下用不上的珠子的数目</strong>.</li>
<li>如果没有,就输出<strong>No 缺少了多少颗需要的珠子</strong>.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题很明显应该用哈希表来解决.老板有的珠子,我们就在哈希表对应的位置+1;我们需要的珠子,就在对应的哈希表位置-1.</p>
<p>最终哈希表内如果有负数,说明老板的珠子不能满足我们的需要,各个负数之和就是我们缺少的珠子的数目;</p>
<p>如果没有负数,说明老板的珠子能够满足我们的需求,哈希表内各个正数之和就是我们用不上的多余的珠子数目;</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> shopBeads = Console.ReadLine();</span><br><span class="line">    <span class="keyword">string</span> needBeads = Console.ReadLine();</span><br><span class="line">    <span class="keyword">int</span> missingBeads = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> extraBeads = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> bead <span class="keyword">in</span> shopBeads)</span><br><span class="line">    &#123;</span><br><span class="line">        colors[bead]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> bead <span class="keyword">in</span> needBeads)</span><br><span class="line">    &#123;</span><br><span class="line">        colors[bead]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> bead <span class="keyword">in</span> shopBeads + needBeads)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[bead] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            extraBeads += colors[bead];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            missingBeads += colors[bead];</span><br><span class="line">        &#125;</span><br><span class="line">        colors[bead] = <span class="number">0</span>;<span class="comment">//已经算过的哈希表位置要将它置零,避免重复计算.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (missingBeads &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"No &#123;0&#125;"</span>, <span class="number">0</span> - missingBeads);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Yes &#123;0&#125;"</span>, extraBeads);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1084 Broken Keyboard</title>
    <url>/2019/04/28/1084-Broken-Keyboard/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen.</p>
<p>Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or <code>_</code> (representing the space). It is guaranteed that both strings are non-empty.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7_This_is_a_test</span><br><span class="line">_hs_s_a_es</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7TI</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>键盘的某些按键坏了,导致你输入的和屏幕显示的结果不一样,现在要找出哪些键位坏了,规则如下:</p>
<ul>
<li>每一个输入字符串都只有大小写字母,数字和下划线.</li>
<li>要求输出的结果只输出大写字母,而且每个坏按键只输出一次.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是相当简单的一道题了,可以有两种解决思路:</p>
<ul>
<li>对于第一个字符串中的每一个字符,直接查询是否包含在第二个字符串中,如果没有,说明是坏了.</li>
<li>用第一个字符串建立一个哈希表,然后对于第二个字符串中的每一个字符,修改哈希表,剩下的没被修改的值就是坏了的按键.</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>方法一:直接查询.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> original = System.Console.ReadLine().ToUpper();</span><br><span class="line">    <span class="keyword">string</span> typedOut = System.Console.ReadLine().ToUpper();</span><br><span class="line">    <span class="keyword">string</span> result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> original)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!typedOut.Contains(item.ToString()) &amp;&amp; !result.Contains(item.ToString()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这个字符不仅要不存在第二个字符串中,还要不存在结果字符串中,否则有可能重复输出同一个按键</span></span><br><span class="line">            result += item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二:建立哈希表.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> original = System.Console.ReadLine().ToUpper();</span><br><span class="line">    <span class="keyword">string</span> typedOut = System.Console.ReadLine().ToUpper();</span><br><span class="line">    <span class="keyword">string</span> result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span>[] ascii = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> original)</span><br><span class="line">    &#123;</span><br><span class="line">        ascii[item] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> typedOut)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ascii[item] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ascii[item] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> original)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ascii[item] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result += item;</span><br><span class="line">            ascii[item] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1081 Rational Sum</title>
    <url>/2019/04/26/1081-Rational-Sum/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given <em>N</em> rational numbers in the form <code>numerator/denominator</code>, you are supposed to calculate their sum.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a positive integer <em>N</em> (≤100), followed in the next line <em>N</em> rational numbers <code>a1/b1 a2/b2 ...</code> where all the numerators and denominators are in the range of <strong>long int</strong>. If there is a negative number, then the sign must appear in front of the numerator.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output the sum in the simplest form <code>integer numerator/denominator</code> where <code>integer</code> is the integer part of the sum, <code>numerator</code> &lt;<code>denominator</code>, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2&#x2F;5 4&#x2F;15 1&#x2F;30 -2&#x2F;60 8&#x2F;3</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 1&#x2F;3</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4&#x2F;3 2&#x2F;3</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3:"></a>Sample Input 3:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1&#x2F;3 -1&#x2F;6 1&#x2F;8</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3:"></a>Sample Output 3:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7&#x2F;24</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>计算分数加法,要求如下:</p>
<ul>
<li>分数的结果一定要是最简分数.</li>
<li>分子如果大于分母,则要化简为带分数,即<strong>c又a分之b</strong>的整数和分数形式,.</li>
<li>当整数为0,只输出分数部分.</li>
<li>当分数为0,只输出整数部分.</li>
<li>当都为0.输出0.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题第一眼看到可能会觉得很乱,因为这个题不仅要求和,还要化简,化简之后还要判定分子是否大于分母,看起来觉得很乱,但是只要仔细思考,就知道,这道题的重点其实只有4个</p>
<ul>
<li>为了化简,我们需要约分,而约分要用到最大公因数,所以第一个问题是,怎么快速得到最大公因数.</li>
<li>如何进行分数的求和.</li>
<li>分子比分母大的假分数如何化简成整数和分数形式的带分数.</li>
<li>如何防止分子或者分母超出long int范围.</li>
</ul>
<p>第一个点,我们可以用<a href="https://zh.wikipedia.org/wiki/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95" target="_blank" rel="noopener">辗转相除法</a>获得最大公因数,得到了最大公因数,就可以对分数进行化简.</p>
<p>第二个点,我们直接使用分数加法公式,分子交叉相乘再相加得到分子的和,分母相乘通分.</p>
<p>第三个点,我们其实并不需要判断分子是否大于分母,只要将分子除以分母作为整数部分即可,如果分子比分母小,那分子除以分母的结果就是0,而分子%分母的结果,就是新分子.</p>
<p>第四个点,为了防止溢出,分数求和之后的结果要马上进行约分化简,而不能等到所有分数相加完了再化简.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先创建一个获得最大公因数的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">GetGreatestCommonDivisor</span>(<span class="params"><span class="keyword">long</span> numerator, <span class="keyword">long</span> denominator</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> denominator == <span class="number">0</span> ? Math.Abs(numerator) : GetGreatestCommonDivisor(denominator, numerator % denominator);</span><br><span class="line">    <span class="comment">//辗转相除法的递归形式.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建一个分数求和的函数,这个函数传入两个分数,返回一个<strong>已经化简了</strong>的分数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[] <span class="title">GetRationalSum</span>(<span class="params"><span class="keyword">long</span>[] rationalSum, <span class="keyword">long</span>[] rationalNumber</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> greatestCommonDivisor = GetGreatestCommonDivisor(rationalNumber[<span class="number">0</span>], rationalNumber[<span class="number">1</span>]);<span class="comment">//取得最大公约数.</span></span><br><span class="line">    rationalNumber[<span class="number">0</span>] = rationalNumber[<span class="number">0</span>] / greatestCommonDivisor;<span class="comment">//先将分数化简.</span></span><br><span class="line">    rationalNumber[<span class="number">1</span>] = rationalNumber[<span class="number">1</span>] / greatestCommonDivisor;</span><br><span class="line">    rationalSum[<span class="number">0</span>] = rationalSum[<span class="number">0</span>] * rationalNumber[<span class="number">1</span>] + rationalSum[<span class="number">1</span>] * rationalNumber[<span class="number">0</span>];<span class="comment">//分子交叉相乘</span></span><br><span class="line">    rationalSum[<span class="number">1</span>] = rationalSum[<span class="number">1</span>] * rationalNumber[<span class="number">1</span>];<span class="comment">//分母通分.</span></span><br><span class="line">    greatestCommonDivisor = GetGreatestCommonDivisor(rationalSum[<span class="number">0</span>], rationalSum[<span class="number">1</span>]);<span class="comment">//获得求和结果的最大公约数.</span></span><br><span class="line">    rationalSum[<span class="number">0</span>] = rationalSum[<span class="number">0</span>] / greatestCommonDivisor;<span class="comment">//将结果也化简.</span></span><br><span class="line">    rationalSum[<span class="number">1</span>] = rationalSum[<span class="number">1</span>] / greatestCommonDivisor;</span><br><span class="line">    <span class="keyword">return</span> rationalSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.ReadLine();<span class="comment">//第一个数字没用到.</span></span><br><span class="line">    <span class="keyword">string</span>[] inputs = Console.ReadLine().Split();<span class="comment">//用空格分割分数.</span></span><br><span class="line">    <span class="keyword">long</span>[] rationalSum = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>] &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;<span class="comment">//先初始化一个存放结果的分数为0/1.</span></span><br><span class="line">    <span class="keyword">long</span>[] rationalNumber = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> integer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> input <span class="keyword">in</span> inputs)</span><br><span class="line">    &#123;</span><br><span class="line">        rationalNumber[<span class="number">0</span>] = <span class="keyword">long</span>.Parse(input.Split(<span class="string">'/'</span>)[<span class="number">0</span>]);<span class="comment">//对于每个分数,用/分割分子分母.</span></span><br><span class="line">        rationalNumber[<span class="number">1</span>] = <span class="keyword">long</span>.Parse(input.Split(<span class="string">'/'</span>)[<span class="number">1</span>]);</span><br><span class="line">        rationalSum = GetRationalSum(rationalSum, rationalNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    integer = rationalSum[<span class="number">0</span>] / rationalSum[<span class="number">1</span>];<span class="comment">//获得整数部分.</span></span><br><span class="line">    rationalSum[<span class="number">0</span>] = rationalSum[<span class="number">0</span>] % rationalSum[<span class="number">1</span>];<span class="comment">//更新分子.</span></span><br><span class="line">    <span class="keyword">if</span> (integer == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rationalSum[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125;/&#123;1&#125;"</span>, rationalSum[<span class="number">0</span>], rationalSum[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rationalSum[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(integer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125; &#123;1&#125;/&#123;2&#125;"</span>, integer, rationalSum[<span class="number">0</span>], rationalSum[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1077 Kuchiguse</title>
    <url>/2019/04/26/1077-Kuchiguse/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker’s personality. Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle “nyan~” is often used as a stereotype for characters with a cat-like personality:</p>
<ul>
<li>Itai nyan~ (It hurts, nyan~)</li>
<li>Ninjin wa iyada nyan~ (I hate carrots, nyan~)</li>
</ul>
<p>Now given a few lines spoken by the same character, can you find her Kuchiguse?</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line is an integer <em>N</em> (2≤<em>N</em>≤100). Following are <em>N</em> file lines of 0~256 (inclusive) characters in length, each representing a character’s spoken line. The spoken lines are case sensitive.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all <em>N</em> lines. If there is no such suffix, write <code>nai</code>.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Itai nyan~</span><br><span class="line">Ninjin wa iyadanyan~</span><br><span class="line">uhhh nyan~</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nyan~</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Itai!</span><br><span class="line">Ninjinnwaiyada T_T</span><br><span class="line">T_T</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nai</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>这是我开始做PAT以来首次遇到的一道,看完完全不知道在说什么,用了谷歌翻译仍然不知道在说什么,去看了别人的博客解释才明白说的是什么的题目.直到现在,我也只是知道题目问的是什么,但是题目什么意思还没明白.</p>
<p>这道题要问的就是从字符串后面开始,最大的字符子串是什么,如果有就输出最大子串,没有就输出<strong>nai</strong>.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题写出代码比读懂题目简单多了,解决的思路很简单.</p>
<p>先建立一个记录最大子串的变量count.</p>
<p>将输入的几个字符串的第一个字符串,作为标准,将它翻转(因为翻转之后可以从头开始比较),然后对所有字符串进行翻转然后逐位字符比较,如果都一样了,count++.</p>
<p>如果比较不相等,说明最大字符子串结束,返回count.</p>
<p>这个时候就得到了最大字符子串的长度,然后用任意一个字符串s对(s.Length-count)进行截取,得到的就是字符子串了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先创建一个获取最大字符子串长度的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxLengthOfSubstring</span>(<span class="params"><span class="keyword">string</span>[] inputs</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] standard = inputs[<span class="number">0</span>].ToCharArray();<span class="comment">//建立一个标准串.</span></span><br><span class="line">    <span class="keyword">char</span>[] str;</span><br><span class="line">    Array.Reverse(standard);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; standard.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> input <span class="keyword">in</span> inputs)</span><br><span class="line">        &#123;</span><br><span class="line">            str = input.ToCharArray();</span><br><span class="line">            Array.Reverse(str);<span class="comment">//对每一个输入串进行翻转,然后比较.</span></span><br><span class="line">            <span class="keyword">if</span> (str[i] != standard[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">string</span>[] inputs = <span class="keyword">new</span> <span class="keyword">string</span>[count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        inputs[i] = Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">    count = MaxLengthOfSubstring(inputs);<span class="comment">//变量重复利用.</span></span><br><span class="line">    <span class="keyword">string</span> substring = inputs[<span class="number">0</span>].Substring(inputs[<span class="number">0</span>].Length - count);</span><br><span class="line">    Console.WriteLine(count == <span class="number">0</span> ? <span class="string">"nai"</span> : substring);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>windows10安装MySQL</title>
    <url>/2019/04/24/windows10%E5%AE%89%E8%A3%85MySQL/</url>
    <content><![CDATA[<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>使用<a href="https://jiayaoo3o.github.io/2019/01/30/windows%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8-scoop/">scoop</a>直接安装mysql:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scoop install mysql</span><br></pre></td></tr></table></figure>

<p>scoop会自动帮我们设置好环境变量.</p>
<a id="more"></a>

<h2 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h2><p>编辑mysql安装目录下的my.ini文件,对应位置添加如下数据:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir=<span class="string">C:</span><span class="regexp">/Users/</span>jiayao<span class="regexp">/scoop/</span>apps<span class="regexp">/mysql/</span>current</span><br><span class="line"><span class="keyword">default</span>-time-zone = <span class="string">'+8:00'</span></span><br></pre></td></tr></table></figure>

<p>因为scoop已经自动配置好了mysql,所以直接使用启动命令启动mysql即可:</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> mysql</span><br></pre></td></tr></table></figure>

<p>登录数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>不用输入密码直接回车,即可进入数据库.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Enter <span class="string">password:</span></span><br></pre></td></tr></table></figure>

<p>进入数据库之后,执行以下命令修改用户密码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</span><br></pre></td></tr></table></figure>

<p>刷新用户权限:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>关闭数据库,再重新启动:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">net <span class="built_in">stop</span> mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> mysql</span><br></pre></td></tr></table></figure>

<p>输入用户名和密码:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mysql -u root -p</span></span><br></pre></td></tr></table></figure>

<p>即可连上数据库.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>1069 The Black Hole of Numbers</title>
    <url>/2019/04/23/1069-The-Black-Hole-of-Numbers/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number <code>6174</code> – the <strong>black hole</strong> of 4-digit numbers. This number is named Kaprekar Constant.</p>
<p>For example, start from <code>6767</code>, we’ll get:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">7766</span> - <span class="number">6677</span> = <span class="number">1089</span></span><br><span class="line"><span class="number">9810</span> - <span class="number">0189</span> = <span class="number">9621</span></span><br><span class="line"><span class="number">9621</span> - <span class="number">1269</span> = <span class="number">8352</span></span><br><span class="line"><span class="number">8532</span> - <span class="number">2358</span> = <span class="number">6174</span></span><br><span class="line"><span class="number">7641</span> - <span class="number">1467</span> = <span class="number">6174</span></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p>Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which gives a positive integer <em>N</em> in the range (0,10<sup>4</sup>).</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>If all the 4 digits of <em>N</em> are the same, print in one line the equation <code>N - N = 0000</code>. Else print each step of calculation in a line until <code>6174</code> comes out as the difference. All the numbers must be printed as 4-digit numbers.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6767</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7766 - 6677 &#x3D; 1089</span><br><span class="line">9810 - 0189 &#x3D; 9621</span><br><span class="line">9621 - 1269 &#x3D; 8352</span><br><span class="line">8532 - 2358 &#x3D; 6174</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2222</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2222 - 2222 &#x3D; 0000</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>6174是一个黑洞数字,所有的4位数(除了4个数字一样的),经过降序,再减去升序,得到的结果再重复这个过程,最终的数字都会得到6174,现在要求把这个过程展现出来.</p>
<p>注意这里有一个坑,那就是不管你输入的数是不是4位数,展现过程中都必须显示为4位,也就是说不足4位的前面要补零.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的难点也不是很高,只是要知道上面说的那个坑,把所有的数都补足4位就行了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>创建一个给字符串降序排序的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">decreasingSort</span>(<span class="params"><span class="keyword">string</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (input.Length != <span class="number">4</span>)<span class="comment">//不足4位要先补0.</span></span><br><span class="line">    &#123;</span><br><span class="line">        input += <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] num = input.ToCharArray();</span><br><span class="line">    Array.Sort(num);<span class="comment">//直接升序排序.</span></span><br><span class="line">    Array.Reverse(num);<span class="comment">//再反转一次,就变成降序排序了.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">string</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个反转字符串的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Reverse</span>(<span class="params"><span class="keyword">string</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] num = input.ToCharArray();</span><br><span class="line">    Array.Reverse(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">string</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> input = System.Console.ReadLine();</span><br><span class="line">    <span class="keyword">string</span> result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> sortedInput = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> reversedInput = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (result != <span class="string">"6174"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sortedInput = decreasingSort(input);</span><br><span class="line">        reversedInput = Reverse(sortedInput);</span><br><span class="line">        result = (<span class="keyword">int</span>.Parse(sortedInput) - <span class="keyword">int</span>.Parse(reversedInput)).ToString();</span><br><span class="line">        <span class="keyword">if</span> (sortedInput == reversedInput)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125; - &#123;1&#125; = &#123;2&#125;"</span>, sortedInput, reversedInput, <span class="string">"0000"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125; - &#123;1&#125; = &#123;2&#125;"</span>, sortedInput, reversedInput, result.Length == <span class="number">4</span> ? result : <span class="string">"0"</span> + result);</span><br><span class="line">        input = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1065 A+B and C (64bit)</title>
    <url>/2019/04/23/1065-A-B-and-C-64bit/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given three integers <em>A</em>, <em>B</em> and <em>C</em> in [−2<sup>63</sup>,2<sup>63</sup>], you are supposed to tell whether <em>A</em>+<em>B</em>&gt;<em>C</em>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>The first line of the input gives the positive number of test cases, <em>T</em> (≤10). Then <em>T</em> test cases follow, each consists of a single line containing three integers <em>A</em>, <em>B</em> and <em>C</em>, separated by single spaces.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line <code>Case #X: true</code> if <em>A</em>+<em>B</em>&gt;<em>C</em>, or <code>Case #X: false</code> otherwise, where <em>X</em> is the case number (starting from 1).</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">9223372036854775807 -9223372036854775808 0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: false</span><br><span class="line">Case #2: true</span><br><span class="line">Case #3: false</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定三个大范围的整数A,B,C,要求判断A+B是否大于C</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题因为范围是64位的,所以肯定不能普通整型int的,而且哪怕你定义了64位的long,当两个数都超大时,相加结果仍然会溢出.</p>
<p>那怎么办呢?</p>
<p>128位的decimal莽就完事了,毫无技术含量.</p>
<p>当然这是一种投机取巧的方法,正规的方法是通过溢出判断.</p>
<p>定义了三个long,如果A&gt;0,B&gt;0,这个时候如果他们两个数都相当庞大,相加导致溢出,我们知道,不管相加结果是多少,只要溢出了,那就肯定比C大.</p>
<p>如果A&lt;0,B&lt;0,这个时候如果他们两个数都非常小,导致相加变得更小而溢出了,我们知道,不管结果如何,只要溢出了,那就肯定比C小.</p>
<p>而正数相加溢出,结果为负数;负数相加溢出,结果为正数,我们可以通过这样来判断,结果是否大于C.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>机智版</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">decimal</span> A, B, C;</span><br><span class="line">        <span class="keyword">string</span>[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">        A = <span class="keyword">decimal</span>.Parse(tokens[<span class="number">0</span>]);</span><br><span class="line">        B = <span class="keyword">decimal</span>.Parse(tokens[<span class="number">1</span>]);</span><br><span class="line">        C = <span class="keyword">decimal</span>.Parse(tokens[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (A + B &gt; C ? <span class="literal">true</span> : <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Case #&#123;0&#125;: true"</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Case #&#123;0&#125;: false"</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老实版</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> A, B, C;</span><br><span class="line">        <span class="keyword">string</span>[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">        A = <span class="keyword">long</span>.Parse(tokens[<span class="number">0</span>]);</span><br><span class="line">        B = <span class="keyword">long</span>.Parse(tokens[<span class="number">1</span>]);</span><br><span class="line">        C = <span class="keyword">long</span>.Parse(tokens[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">long</span> sum = A + B;</span><br><span class="line">        <span class="keyword">if</span> (A &gt; <span class="number">0</span> &amp;&amp; B &gt; <span class="number">0</span> &amp;&amp; sum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Case #&#123;0&#125;: true"</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A &lt; <span class="number">0</span> &amp;&amp; B &lt; <span class="number">0</span> &amp;&amp; sum &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Case #&#123;0&#125;: false"</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; C)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"Case #&#123;0&#125;: true"</span>, i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"Case #&#123;0&#125;: false"</span>, i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1061 Dating</title>
    <url>/2019/04/23/1061-Dating/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Sherlock Holmes received a note with some strange strings: <code>Let&#39;s date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm</code>. It took him only a minute to figure out that those strange strings are actually referring to the coded time <code>Thursday 14:04</code> – since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter <code>D</code>, representing the 4th day in a week; the second common character is the 5th capital letter <code>E</code>, representing the 14th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from <code>A</code> to <code>N</code>, respectively); and the English letter shared by the last two strings is <code>s</code> at the 4th position, representing the 4th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the decoded time in one line, in the format <code>DAY HH:MM</code>, where <code>DAY</code> is a 3-character abbreviation for the days in a week – that is, <code>MON</code>for Monday, <code>TUE</code> for Tuesday, <code>WED</code> for Wednesday, <code>THU</code> for Thursday, <code>FRI</code> for Friday, <code>SAT</code> for Saturday, and <code>SUN</code> for Sunday. It is guaranteed that the result is unique for each case.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3485djDkxh4hhGE </span><br><span class="line">2984akDfkkkkggEdsb </span><br><span class="line">s&amp;hgsfdk </span><br><span class="line">d&amp;Hyscvnm</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THU 14:04</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有人给了福尔摩斯一张小纸条,要跟他约会,但是约会时间已经被加密了,现在要通过以下规则解密:</p>
<ul>
<li>输入的4个字符串分为两组,第一组用来得出日期和小时,第二组得出分钟.</li>
<li>第一组中第一对位置相同的同一大写字母(A到G)代表了日期,A表示MON,G表示SUN.</li>
<li>第一组中第二对位置相同的同一数字或者大写字母(A到N)代表了小时,0表示0点,A表示10点,N表示23点.</li>
<li>第二组中第一对位置相同的同一大写或小写字母的位置代表分钟,下标0即第0分钟,下标4则第4分钟.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>又是一道因为题目规则没看明白浪费了一个上午的题,原来连题目都没看懂,真的烦,明白了规则其实这道题就比较简单了,就是相对位置一路比较过去就行了,但是一定要注意每个题目限定要求.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] tokens = <span class="keyword">new</span> <span class="keyword">string</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">string</span>[] result = &#123; <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">string</span>[] week = &#123; <span class="string">"MON"</span>, <span class="string">"TUE"</span>, <span class="string">"WED"</span>, <span class="string">"THU"</span>, <span class="string">"FRI"</span>, <span class="string">"SAT"</span>, <span class="string">"SUN"</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens[i] = System.Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens[<span class="number">0</span>].Length &amp;&amp; i &lt; tokens[<span class="number">1</span>].Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[<span class="number">0</span>][i] == tokens[<span class="number">1</span>][i] &amp;&amp; tokens[<span class="number">0</span>][i] &gt;= <span class="string">'A'</span> &amp;&amp; tokens[<span class="number">0</span>][i] &lt;= <span class="string">'G'</span>)<span class="comment">//规定1,一定要在A到G之间.</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[<span class="number">0</span>] = week[tokens[<span class="number">0</span>][i] - <span class="string">'A'</span>];</span><br><span class="line">            flag = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = flag; i &lt; tokens[<span class="number">0</span>].Length &amp;&amp; i &lt; tokens[<span class="number">1</span>].Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//规定2,i一定要在上一个循环结束的下一个位置开始,因为现在要找在第一对相同位置之后的第二对.</span></span><br><span class="line">        <span class="keyword">if</span> (tokens[<span class="number">0</span>][i] == tokens[<span class="number">1</span>][i] &amp;&amp; (tokens[<span class="number">0</span>][i] &gt;= <span class="string">'0'</span> &amp;&amp; tokens[<span class="number">0</span>][i] &lt;= <span class="string">'9'</span> || tokens[<span class="number">0</span>][i] &gt;= <span class="string">'A'</span> &amp;&amp; tokens[<span class="number">0</span>][i] &lt;= <span class="string">'N'</span>))</span><br><span class="line">        <span class="comment">//规定3,判定范围不能&gt;='0'&amp;&amp;&lt;='N'.</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[<span class="number">1</span>] = tokens[<span class="number">0</span>][i] &gt; <span class="string">'9'</span> ? (tokens[<span class="number">0</span>][i] - <span class="string">'7'</span>).ToString() : <span class="string">"0"</span> + tokens[<span class="number">0</span>][i];</span><br><span class="line">            <span class="comment">//规定4,不足10的数要在前面补个0.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens[<span class="number">2</span>].Length &amp;&amp; i &lt; tokens[<span class="number">3</span>].Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[<span class="number">2</span>][i] == tokens[<span class="number">3</span>][i] &amp;&amp; (tokens[<span class="number">2</span>][i] &gt;= <span class="string">'A'</span> &amp;&amp; tokens[<span class="number">2</span>][i] &lt;= <span class="string">'Z'</span> || tokens[<span class="number">2</span>][i] &gt;= <span class="string">'a'</span> &amp;&amp; tokens[<span class="number">2</span>][i] &lt;= <span class="string">'z'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            result[<span class="number">2</span>] = i &lt; <span class="number">10</span> ? <span class="string">"0"</span> + i : i.ToString();</span><br><span class="line">            Console.WriteLine(result[<span class="number">0</span>] + <span class="string">" "</span> + result[<span class="number">1</span>] + <span class="string">":"</span> + result[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1058 A+B in Hogwarts</title>
    <url>/2019/04/22/1058-A-B-in-Hogwarts/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>If you are a fan of Harry Potter, you would know the world of magic has its own currency system – as Hagrid explained it to Harry, “Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it’s easy enough.” Your job is to write a program to compute <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are given in the standard form of <code>Galleon.Sickle.Knut</code> (<code>Galleon</code> is an integer in [0,10<sup>7</sup>], <code>Sickle</code> is an integer in [0, 17), and <code>Knut</code> is an integer in [0, 29)).</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which occupies a line with <em>A</em> and <em>B</em> in the standard form, separated by one space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.2.1 10.16.27</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14.1.28</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>又是一道花里胡哨的题目,给你两个分成三个数的字符串,让你通过”霍格沃兹”进制来计算他们的和:最后一个数是29进制,中间那个数是17进制,第一个数是10进制.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题没什么好说的,就是进制算就完事了,尤其是这个数只有3份,甚至都不用循环,直接写就行了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">HogwartsAddition</span>(<span class="params"><span class="keyword">string</span> A, <span class="keyword">string</span> B</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] currencyA = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span>[] currencyB = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">string</span>[] strA = A.Split(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">string</span>[] strB = B.Split(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strA.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        currencyA[i] = <span class="keyword">int</span>.Parse(strA[i]);</span><br><span class="line">        currencyB[i] = <span class="keyword">int</span>.Parse(strB[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    result[<span class="number">2</span>] = (currencyA[<span class="number">2</span>] + currencyB[<span class="number">2</span>]) % <span class="number">29</span>;</span><br><span class="line">    flag = currencyA[<span class="number">2</span>] + currencyB[<span class="number">2</span>] &gt;= <span class="number">29</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    result[<span class="number">1</span>] = (currencyA[<span class="number">1</span>] + currencyB[<span class="number">1</span>] + flag) % <span class="number">17</span>;</span><br><span class="line">    flag = currencyA[<span class="number">1</span>] + currencyB[<span class="number">1</span>] + flag &gt;= <span class="number">17</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    result[<span class="number">0</span>] = currencyA[<span class="number">0</span>] + currencyB[<span class="number">0</span>] + flag;</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>] + <span class="string">"."</span> + result[<span class="number">1</span>] + <span class="string">"."</span> + result[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    Console.WriteLine(HogwartsAddition(tokens[<span class="number">0</span>], tokens[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1054 The Dominant Color</title>
    <url>/2019/04/22/1054-The-Dominant-Color/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Behind the scenes in the computer’s memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. A <strong>strictly</strong> dominant color takes more than half of the total area. Now given an image of resolution <em>M</em>by <em>N</em> (for example, 800×600), you are supposed to point out the strictly dominant color.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: <em>M</em> (≤800) and <em>N</em> (≤600) which are the resolutions of the image. Then <em>N</em> lines follow, each contains <em>M</em> digital colors in the range [0,2<sup>24</sup>). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, simply print the dominant color in a line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">0 0 255 16777215 24</span><br><span class="line">24 24 0 0 24</span><br><span class="line">24 0 24 24 24</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一张照片的分辨率为MxN,每一个像素点拥有一个颜色,任务是求出这张照片中一定存在的那个主颜色(颜色超过像素数目的一半).</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我真的差点就被这道题搞自闭了,这个题目考察的点是哈希表,通过将出现过的颜色放入哈希表,颜色每出现一次,就将哈希表对应的数值加一,当颜色出现的次数大于一半像素时,即为所求颜色.</p>
<p>但是当我用这个办法去解这道题时,其他测试案例都通过了,唯独最后一个测试案例却永远是错误的,哪怕我已经觉得我的代码和别人的都一样了,只是用C#语言翻译过来而已,都仍然不能够通过,最后我意识到了,还有唯一的一种情况我没有设想到,那就是只有一个像素点的时候.</p>
<p>幸好最后我在<a href="https://github.com/lynnprosper/ZJU_PAT/tree/master/Advanced_Level" target="_blank" rel="noopener">这个仓库</a>中看到了一个新的解法,把这道题过了.</p>
<p>这个巧妙的解法并没有用到哈希表,而是用一个全新的思路.因为我们已知,图片上肯定有一个主颜色,这个颜色的出现次数肯定大于剩下所有的颜色出现次数之和,也就是说,这个主颜色的出现次数减去剩下所有颜色出现的次数,都要大于0,所以可以定义两个变量,一个是当前颜色nowColor.</p>
<p>另一个是当前颜色出现的次数nowColorCount初始化为1.</p>
<p>如果输入颜色等于当前颜色,那就让nowColorCount++;</p>
<p>如果输入颜色不等于当前颜色,就让nowColorCount–;</p>
<p>如果nowColorCount自减成0,那说明nowColor还不是主颜色,那就将输入颜色设置为当前颜色nowColor.</p>
<p>这样到最后,nowColor肯定会成为主颜色,nowColorCount也肯定大于0.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">int</span> column = <span class="keyword">int</span>.Parse(tokens[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> row = <span class="keyword">int</span>.Parse(tokens[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> half = (column * row) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> nowColorCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> nowColor = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens = System.Console.ReadLine().Split();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> token <span class="keyword">in</span> tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (token == nowColor)</span><br><span class="line">            &#123;</span><br><span class="line">                nowColorCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nowColorCount--;</span><br><span class="line">                <span class="keyword">if</span> (nowColorCount == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nowColor = token;</span><br><span class="line">                    nowColorCount = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(nowColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是把我搞自闭的，用字典实现哈希功能的代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">int</span> column = <span class="keyword">int</span>.Parse(tokens[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> row = <span class="keyword">int</span>.Parse(tokens[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> half = (column * row) / <span class="number">2</span>;</span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; dict = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens = System.Console.ReadLine().Split();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> token <span class="keyword">in</span> tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict.ContainsKey(token))</span><br><span class="line">            &#123;</span><br><span class="line">                dict[token]++;</span><br><span class="line">                <span class="keyword">if</span> (dict[token] &gt; half)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(token);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dict.Add(token, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (dict[token] &gt; half)<span class="comment">//把我搞自闭的就是这个位置,如果像素点只有一个,那添加进来的时候就要判断了.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(token);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1050 String Subtraction</title>
    <url>/2019/04/22/1050-String-Subtraction/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given two strings <em>S</em>1 and <em>S</em>2, <em>S</em>=<em>S</em>1−<em>S</em>2 is defined to be the remaining string after taking all the characters in <em>S</em>2from <em>S</em>1. Your task is simply to calculate <em>S</em>1−<em>S</em>2 for any given strings. However, it might not be that simple to do it <strong>fast</strong>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case consists of two lines which gives <em>S</em>1 and <em>S</em>2, respectively. The string lengths of both strings are no more than 10<sup>4</sup>. It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print <em>S</em>1−<em>S</em>2 in one line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">They are students.</span><br><span class="line">aeiou</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thy r stdnts.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个字符串S1,S2,输出S1-S2的结果.注意题目特地提到了fast,所以这道题时间是关键.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题看似很简单,但是正是因为很简单,所以肯定不能用最简单的双重for循环来判定的,因为S1最大长度可能到达10<sup>4</sup>,直接循环肯定要超时的.</p>
<p>但是我们知道,这道题无论如何都是要循环S1一次的,因为总得要输出的嘛,所以这道题只能循环一次S1,否则就要超时了.</p>
<p>所以这次题目的要求是要在一次S1循环内直接验证S1的某个字符是否在S2中存在,要用哈希表来解决.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> S1 = System.Console.ReadLine();</span><br><span class="line">    <span class="keyword">string</span> S2 = System.Console.ReadLine();</span><br><span class="line">    <span class="keyword">bool</span>[] signals = <span class="keyword">new</span> <span class="keyword">bool</span>[<span class="number">127</span>];<span class="comment">//创建一个bool数组,长度是ascii表的长度,保证每一个字符都有自己的位置.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> signal <span class="keyword">in</span> S2)</span><br><span class="line">    &#123;</span><br><span class="line">        signals[signal] = <span class="literal">true</span>;<span class="comment">//将bool数组的对应位置设置为true.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> character <span class="keyword">in</span> S1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!signals[character])<span class="comment">//将S1字符串对逐个字符放入bool数组中进行验证,如果是true说明需要放弃,是false说明需要输出.</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(character);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1046 Shortest Distance</title>
    <url>/2019/04/20/1046-Shortest-Distance/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The task is really simple: given <em>N</em> exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer <em>N</em> (in [3,10<sup>5</sup>]), followed by <em>N</em> integer distances D<sub>1</sub> D<sub>2</sub> ⋯ D<sub>N</sub>, where D<sub>i</sub> is the distance between the <em>i</em> -th and the (<em>i</em>+1)-st exits, and D<sub>N</sub> is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M(≤10<sup>4</sup>), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 10<sup>7</sup>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print your results in <em>M</em> lines, each contains the shortest distance between the corresponding given pair of exits.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1 2 4 14 9</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">4 1</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一条环状高速公路上有很多节点,并且已知每个节点到下一个节点的距离,现在给定两个节点,要求求出节点的最近距离是多少.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我一开始的思路是直接顺时针求出A到B和B到A的距离,看看谁小,这样做思路并没有错,但是因为我求距离的方法是用一个for循环,获取每个节点上的距离,再累加,这样分别循环两次得到的结果,但是当测试案例有很多个节点的时候,这样做会太浪费时间,导致超时.</p>
<p>所以对于上面的超时,要进行的思路改进有两点:</p>
<ul>
<li><p>不应该顺时针循环算两遍,因为高速公路是一个圆,只要算出A到B的距离,然后用总距离减去A到B距离,结果就是B到A了.</p>
</li>
<li><p>算A到B距离,没必要用循环累加每个节点的距离这种方式,我们用数组保存节点距离的时候,没必要将<strong>节点与下一个节点的距离</strong>保存到数组中,而是应该将<strong>节点与第一个节点的距离</strong>保存在数组中,例如例子中的:</p>
<blockquote>
<p>1 2 4 14 9</p>
</blockquote>
<p>是指当前节点,到下一个节点的距离,而我们保存数据的时候,可以保存为:</p>
<blockquote>
<p>0 1 3 7 21</p>
</blockquote>
<p>这是指每一个点到第一个点的距离,这样的话我们算A到B的距离就不用循环了,直接是第A个节点减去地B个节点的距离(下标0是第一个节点).</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先实现一个获得最短路径的函数,这个函数传入4个参数,分别是:保存各个节点数据的数组,需要计算的开始节点,需要计算的结束节点,还有总距离.</p>
<p>我们要做的是比较开始节点到结束节点之间的距离和总距离减去两节点之间的距离,谁更小就取哪个值.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetShortestDistance</span>(<span class="params"><span class="keyword">int</span>[] nodes, <span class="keyword">int</span> beginNode, <span class="keyword">int</span> endNode, <span class="keyword">int</span> totalDistance</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> distance = beginNode &gt; endNode ? nodes[beginNode - <span class="number">1</span>] - nodes[endNode - <span class="number">1</span>] : nodes[endNode - <span class="number">1</span>] - nodes[beginNode - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> distance &lt; (totalDistance - distance) ? distance : (totalDistance - distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">int</span> nodesCount = <span class="keyword">int</span>.Parse(tokens[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span>[] nodes = <span class="keyword">new</span> <span class="keyword">int</span>[nodesCount];</span><br><span class="line">    <span class="keyword">int</span> totalDistance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes[i] = totalDistance;</span><br><span class="line">        totalDistance += <span class="keyword">int</span>.Parse(tokens[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pairsCount = <span class="keyword">int</span>.Parse(Console.ReadLine());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairsCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span>[] pairs = Console.ReadLine().Split();</span><br><span class="line">        Console.WriteLine(GetShortestDistance(nodes, <span class="keyword">int</span>.Parse(pairs[<span class="number">0</span>]), <span class="keyword">int</span>.Parse(pairs[<span class="number">1</span>]), totalDistance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我其实还是有一个对于PAT的疑惑的,按照题目所说,不是应该等输入完了所有的节点对之后,再输出三个最短距离结果吗?为什么现在是输入一个节点对,马上输出一个结果,这样也可以呢?不影响程序判定的吗?</p>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1042 Shuffling Machine</title>
    <url>/2019/04/19/1042-Shuffling-Machine/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ <strong>automatic shuffling machines</strong>. Your task is to simulate a shuffling machine.</p>
<p>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">S1</span></span>, S2, ..., S13, </span><br><span class="line"><span class="function"><span class="title">H1</span></span>, H2, ..., H13, </span><br><span class="line"><span class="function"><span class="title">C1</span></span>, C2, ..., C13, </span><br><span class="line"><span class="function"><span class="title">D1</span></span>, D2, ..., D13, </span><br><span class="line">J1, J2</span><br></pre></td></tr></table></figure>

<p>where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the <em>i</em>-th position is <em>j</em>, it means to move the card from position <em>i</em> to position <em>j</em>. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>K</em> (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一副顺序完整的扑克牌,要你按照一定的规则去洗牌.</p>
<p>例如给你5张牌:</p>
<blockquote>
<p>S3, H5, C1, D13, J2</p>
</blockquote>
<p>给你一个洗牌顺序:</p>
<blockquote>
<p>{4, 2, 5, 3, 1}</p>
</blockquote>
<p>那洗牌一次的结果就是,把对应位置的牌放到对应的洗牌顺序位置:</p>
<blockquote>
<p>J2, H5, D13, S3, C1</p>
</blockquote>
<p>再用这个规则洗牌一次,结果就是:</p>
<blockquote>
<p>C1, H5, S3, J2, D13</p>
</blockquote>
<p>现在要求给你一个洗牌次数K,再一个洗牌顺序,让你把按照洗牌顺序的54张洗牌结果输出.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题,只要创建三个数组:一个指令数组orders,一个扑克牌数组cards,一个洗牌结果数组result,然后将洗牌指令数组内的数据作为结果数组的下标,存放扑克牌就好了.即:</p>
<blockquote>
<p>result[orders[i] - 1] = cards[i];</p>
</blockquote>
<p>例如现在i=0,对于上面那五张牌,order[0]-1就是4-1=3,所以result[3]=cards[0],这就可以将第一张扑克牌S3放到第4位了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>创建一个洗牌数组,放入一个洗牌指令,放入一个扑克牌,返回洗牌结果.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span>[] <span class="title">ShufflingMachines</span>(<span class="params"><span class="keyword">int</span>[] orders, <span class="keyword">string</span>[] cards</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] result = <span class="keyword">new</span> <span class="keyword">string</span>[cards.Length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orders.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result[orders[i] - <span class="number">1</span>] = cards[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> repeatTimes = <span class="keyword">int</span>.Parse(System.Console.ReadLine());</span><br><span class="line">    <span class="keyword">string</span>[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">int</span>[] orders = <span class="keyword">new</span> <span class="keyword">int</span>[tokens.Length];</span><br><span class="line">    <span class="keyword">string</span>[] cards = <span class="keyword">new</span> <span class="keyword">string</span>[<span class="number">54</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">54</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        orders[i] = <span class="keyword">int</span>.Parse(tokens[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">13</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cards[i] = <span class="string">"S"</span> + (i + <span class="number">1</span>).ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">13</span> &amp;&amp; i &lt; <span class="number">26</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cards[i] = <span class="string">"H"</span> + (i % <span class="number">13</span> + <span class="number">1</span>).ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">26</span> &amp;&amp; i &lt; <span class="number">39</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cards[i] = <span class="string">"C"</span> + (i % <span class="number">13</span> + <span class="number">1</span>).ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">39</span> &amp;&amp; i &lt; <span class="number">52</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cards[i] = <span class="string">"D"</span> + (i % <span class="number">13</span> + <span class="number">1</span>).ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">52</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cards[i] = <span class="string">"J"</span> + (i % <span class="number">13</span> + <span class="number">1</span>).ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; repeatTimes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cards = ShufflingMachines(orders, cards);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cards.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != cards.Length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(cards[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(cards[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1041 Be Unique</title>
    <url>/2019/04/18/1041-Be-Unique/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1,10<sup>4</sup>]. The first one who bets on a unique number wins. For example, if there are 7 people betting on { 5 31 5 88 67 88 17 }, then the second one who bets on 31 wins.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a line which begins with a positive integer <em>N</em> (≤10<sup>5</sup>) and then followed by <em>N</em> bets The numbers are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the winning number in a line. If there is no winner, print <code>None</code> instead.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 5 31 5 88 67 88 17</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">31</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 888 666 666 888 888</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">None</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>我发现PAT的题目就不喜欢直接问你,而是搞成某个情景来体现这个算法,花里胡哨.</p>
<p>这道题的意思是火星上的人都喜欢追求独一无二,所以这里有个彩票游戏,就是大伙N人从1到10^4^数字范围内抽一个数字下注,下注完了之后,第一个抽到独一无二,没有和别人重复数字的人,就赢了.</p>
<p>给定的一串数字,第一个数是指人数N,后面的是指大家下注的数字,我们要找出第一个只出现一次的数字,例如第一个例子里的31,66,17都出现了一次,但是31是第一个出现的,所以31赢了.</p>
<p>如果没有独一无二的数字,就输出None.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是肯定不能直接用循环一次所有输入数字的方法来做的,因为这个人数N的上限是10^5^,循环完了肯定都超时了,所以要用到hash,直接定位到所选的数字,然后修改这个数字的次数,因为我们用的是数组,直接定位到数组的某个位置速度是很快的.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">int</span>.Parse(tokens[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[count];<span class="comment">//记录输入了哪些数字.</span></span><br><span class="line">    <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000</span>];<span class="comment">//记录所输入的这些数字的频率.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        numbers[i] = <span class="keyword">int</span>.Parse(tokens[i + <span class="number">1</span>]);</span><br><span class="line">        frequency[numbers[i]]++;<span class="comment">//如果numbers[i]是5,那frequency的第5个位置就+1.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (frequency[numbers[i]] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(numbers[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == count - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"None"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1035 Password</title>
    <url>/2019/04/18/1035-Password/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish <code>1</code> (one) from <code>l</code> (<code>L</code> in lowercase), or <code>0</code> (zero) from <code>O</code> (<code>o</code> in uppercase). One solution is to replace <code>1</code> (one) by <code>@</code>, <code>0</code> (zero) by <code>%</code>, <code>l</code> by <code>L</code>, and <code>O</code> by <code>o</code>. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a positive integer <em>N</em> (≤1000), followed by <em>N</em> lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print the number <em>M</em> of accounts that have been modified, then print in the following <em>M</em> lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line <code>There are N accounts and no account is modified</code> where <code>N</code> is the total number of accounts. However, if <code>N</code> is one, you must print <code>There is 1 account and no account is modified</code> instead.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Team000002 Rlsp0dfa</span><br><span class="line">Team000003 perfectpwd</span><br><span class="line">Team000001 R1spOdfa</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">Team000002 RLsp%dfa</span><br><span class="line">Team000001 R@spodfa</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">team110 abcdefg332</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">There is 1 account and no account is modified</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3:"></a>Sample Input 3:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">team110 abcdefg222</span><br><span class="line">team220 abcdefg333</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3:"></a>Sample Output 3:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">There are 2 accounts and no account is modified</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>让你按照给定的规则修改用户密码,修改完成之后输出修改的结果:</p>
<ul>
<li>1-&gt;@</li>
<li>0-&gt;%</li>
<li>l-&gt;L</li>
<li>O-&gt;o</li>
</ul>
<p>如果只有1个账户输入,而没有发生修改,输出:</p>
<blockquote>
<p>There is 1 account and no account is modified</p>
</blockquote>
<p>如果有N个账户输入,而没有发生修改,输出:</p>
<blockquote>
<p>There are N accounts and no account is modified</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题一开始我还打算用字典来存储用户名和密码,但是搞了好半天还不如直接用两个字符串数组.</p>
<p>创建一个字符串数组users用来存用户名,另一个字符串数组passwords用来存密码,两者位置一一对应</p>
<p>再创建一个存储修改位置的布尔数组modifiedInfo,哪个位置修改了密码,就在对应的布尔数组上置为true,最后做一个循环输出就行了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先写一个用来修改密码的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">ChangePassword</span>(<span class="params"><span class="keyword">char</span>[] password</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; password.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (password[i] == <span class="string">'0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            password[i] = <span class="string">'%'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password[i] == <span class="string">'1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            password[i] = <span class="string">'@'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password[i] == <span class="string">'l'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            password[i] = <span class="string">'L'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password[i] == <span class="string">'O'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            password[i] = <span class="string">'o'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">string</span>(password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> userCount = <span class="keyword">int</span>.Parse(System.Console.ReadLine());</span><br><span class="line">    <span class="keyword">int</span> modifiedCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span>[] modifiedInfo = <span class="keyword">new</span> <span class="keyword">bool</span>[userCount];</span><br><span class="line">    <span class="keyword">string</span>[] users = <span class="keyword">new</span> <span class="keyword">string</span>[userCount];</span><br><span class="line">    <span class="keyword">string</span>[] passwords = <span class="keyword">new</span> <span class="keyword">string</span>[userCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span>[] line = System.Console.ReadLine().Split();</span><br><span class="line">        users[i] = line[<span class="number">0</span>];</span><br><span class="line">        passwords[i] = line[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(ChangePassword(passwords[i].ToCharArray()) == passwords[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断旧密码和新密码是否一致.</span></span><br><span class="line">            modifiedInfo[i] = <span class="literal">true</span>;</span><br><span class="line">            passwords[i] = ChangePassword(passwords[i].ToCharArray());</span><br><span class="line">            modifiedCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modifiedCount == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (userCount != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"There are "</span> + userCount + <span class="string">" accounts and no account is modified"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"There is "</span> + userCount + <span class="string">" account and no account is modified"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(modifiedCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (modifiedInfo[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(users[i] + <span class="string">" "</span> + passwords[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1027 Colors in Mars</title>
    <url>/2019/04/18/1027-Colors-in-Mars/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for <code>Red</code>, the middle 2 digits for <code>Green</code>, and the last 2 digits for <code>Blue</code>. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which occupies a line containing the three decimal color values.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the Mars RGB value in the following format: first output <code>#</code>, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a <code>0</code> to its left.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 43 71</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#123456</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>地球人的rgb颜色是16进制的,火星的rgb是13进制的,现在给你三个10进制数,要转换成火星rgb模式,要求:</p>
<ul>
<li><p>每种颜色的13进制数占2位.</p>
</li>
<li><p>三个10进制数范围是0到168.</p>
</li>
<li><p>如果转换成13进制数只有1位,那剩下的那一位左边要.</p>
</li>
<li><p>结果按照#rrggbb输出.</p>
</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题考察的是进制转换,只要实现一个函数,对输入的10进制数转换成13进制,然后用一个字符串将3种颜色拼接在一起.</p>
<p>而10进制转换到任意进制的方法都是固定的,就是10进制数%目标进制的余数的拼接结果.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先实现一个10进制转换到任意进制的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">ConvertDecToTarget</span>(<span class="params"><span class="keyword">int</span> dec, <span class="keyword">int</span> target, <span class="keyword">int</span> length</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[length];<span class="comment">//length用来规定结果的长度.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result[i] = <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = dec;</span><br><span class="line">    <span class="keyword">int</span> index = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % target &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result[index--] = (<span class="keyword">char</span>)(n % target + <span class="number">55</span>);<span class="comment">//整型到char大写字母.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[index--] = (<span class="keyword">char</span>)(n % target + <span class="number">48</span>);<span class="comment">//整型到char数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        n /= target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">string</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">int</span> red = <span class="keyword">int</span>.Parse(tokens[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> green = <span class="keyword">int</span>.Parse(tokens[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> blue = <span class="keyword">int</span>.Parse(tokens[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">string</span> result = <span class="string">"#"</span>;</span><br><span class="line">    result += ConvertDecToTarget(red, <span class="number">13</span>, <span class="number">2</span>);</span><br><span class="line">    result += ConvertDecToTarget(green, <span class="number">13</span>, <span class="number">2</span>);</span><br><span class="line">    result += ConvertDecToTarget(blue, <span class="number">13</span>, <span class="number">2</span>);</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1023 Have Fun with Numbers</title>
    <url>/2019/04/17/1023-Have-Fun-with-Numbers/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!</p>
<p>Now you are suppose to check if there are more numbers with this property. That is, double a given number with <em>k</em> digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input contains one test case. Each case contains one positive integer with no more than 20 digits.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1234567899</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">2469135798</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>让你判断一个数,翻倍之后,是否还符合要求:</p>
<ul>
<li>翻倍之后的每一个数字,都要是没翻倍之前出现过的.</li>
<li>翻倍之后的每一个数字,出现的频率都要和没翻倍之前一样.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题最难的地方,是读懂题目,我就是因为没看明白原来还有频率要求,被卡好久了,只要明确了有这两个要求,就比较好办了.</p>
<p>另一点要注意的是,题目规定是20位之内的大数翻倍,所以不应该用整型长整型这些数据类型,而是应该用数组保存数据.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>既然要判断翻倍之后的数字是不是翻倍之前就存在的,那我们先创建一个用来判断某个数是不是在数组里面的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Contains</span>(<span class="params"><span class="keyword">char</span>[] input, <span class="keyword">char</span> index</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] == index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建一个函数,用来将整型数组翻倍:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] <span class="title">DoubleIntegerArray</span>(<span class="params"><span class="keyword">int</span>[] num</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> length = num.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num[length] != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[length] * <span class="number">2</span> &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num[length] = num[length] * <span class="number">2</span> % <span class="number">10</span> + flag;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            num[length] = num[length] * <span class="number">2</span> % <span class="number">10</span> + flag;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num[length] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个函数用来判断频率是不是已经全为0了,用来判断翻倍之后的数字和翻倍之前频率是否一致</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">FrequencyIsEmpty</span>(<span class="params"><span class="keyword">int</span>[] frequency</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> fre <span class="keyword">in</span> frequency)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fre != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] line = System.Console.ReadLine().ToCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">22</span>];</span><br><span class="line">    <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//用来判断新数字出来的频率和原数字是否一致.如果程序结束后frequency全为0则频率一致.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将数组置为-1;</span></span><br><span class="line">        num[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[num.Length - line.Length + i] = line[i] - <span class="string">'0'</span>;<span class="comment">//char转int要-48或者-'0'.</span></span><br><span class="line">        frequency[line[i] - <span class="string">'0'</span>]++;<span class="comment">//记录对应位置的频率.</span></span><br><span class="line">    &#125;</span><br><span class="line">    num = DoubleIntegerArray(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num.Length - <span class="number">1</span>; num[i] != <span class="number">-1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Contains(line, (<span class="keyword">char</span>)(num[i] + <span class="number">48</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果出现了不存在的数字,直接NO</span></span><br><span class="line">            Console.WriteLine(<span class="string">"No"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        frequency[num[i]]--;</span><br><span class="line">        <span class="keyword">if</span> (num[i - <span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FrequencyIsEmpty(frequency))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Yes"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"No"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1019 General Palindromic Number</title>
    <url>/2019/04/16/1019-General-Palindromic-Number/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A number that will be the same when it is written forwards or backwards is known as a <strong>Palindromic Number</strong>. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p>
<p>Now given any two positive integers <em>N</em> (&lt;10<sup>5</sup>) and <em>D</em> (1&lt;<em>D</em>≤10), you are supposed to tell if <em>N</em> is a reversible prime with radix <em>D</em>.</p>
<p>Given any positive decimal integer <em>N</em> and a base <em>b</em>, you are supposed to tell if <em>N</em> is a palindromic number in base <em>b</em>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case consists of two positive numbers <em>N</em> and <em>b</em>, where 0&lt;<em>N</em>≤10<sup>9</sup> is the decimal number and 2≤<em>b</em>≤10<sup>9</sup> is the base. The numbers are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in one line <code>Yes</code> if <em>N</em> is a palindromic number in base <em>b</em>, or <code>No</code> if not. Then in the next line, print <em>N</em> as the number in base <em>b</em> in the form “a<em>k</em> a<em>k−1</em> … <em>a</em>0”. Notice that there must be no extra space at the end of output.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">1 1 0 1 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">121 5</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No</span><br><span class="line">4 4 1</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>这一题和上一题1015有点相似,那一题是找素数,这一题是找回文,但是不是直接判断一个数是不是回文,而是要判断某个数N的b进制数是不是回文.</p>
<p>另一点要注意的是,如果N是0,那不管是多少进制,结果都是Yes,并且输出0.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题考的点主要还是两个,1是看你会不会进制转换,2是考你会不会判断回文.</p>
<p>所以我们可以先写一个判断回文的函数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsPalindromic</span>(<span class="params"><span class="keyword">int</span>[] input, <span class="keyword">int</span> index</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] != input[index - <span class="number">1</span> - i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再将已经转换了进制的整型数组放进去,判断是不是回文.</p>
<p>这里我们选择将N转换成b进制之后的结果放入一个整型数组,因为这样比较方便操作,但是要注意的是,因为一开始创建整型数组 <strong>int[ ] n</strong> 的时候,是不知道接下来要放进去的数据是多少位的,这就导致我们不知道整型数组结束的最后下标在哪,所以需要一个下标变量index确定末尾.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> line = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> ((line = System.Console.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span>[] tokens = line.Split();</span><br><span class="line">        <span class="keyword">int</span> N = <span class="keyword">int</span>.Parse(tokens[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> b = <span class="keyword">int</span>.Parse(tokens[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Yes"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (N != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n[index] = N % b;</span><br><span class="line">                N /= b;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IsPalindromic(n, index))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Yes"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"No"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = index - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(n[i] + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(n[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1015 Reversible Primes</title>
    <url>/2019/04/16/1015-Reversible-Primes/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A <strong>reversible prime</strong> in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.</p>
<p>Now given any two positive integers <em>N</em> (&lt;10<sup>5</sup>) and <em>D</em> (1&lt;<em>D</em>≤10), you are supposed to tell if <em>N</em> is a reversible prime with radix <em>D</em>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>The input file consists of several test cases. Each case occupies a line which contains two integers <em>N</em> and <em>D</em>. The input is finished by a negative <em>N</em>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line <code>Yes</code> if <em>N</em> is a reversible prime with radix <em>D</em>, or <code>No</code> if not.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">73 10</span><br><span class="line">23 2</span><br><span class="line">23 10</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>判断一个素数是不是可逆素数,这个题目稍微理解困难一点点的是,它并不是直接给你一个37,让你判断将它反转之后的73是不是素数,还有一个D,这个radix D是指基数,你也可以理解为进制,就是你要将N转换成D进制数,反转,再转换成10进制数,然后看它是不是可逆素数.</p>
<p>这道题的另一个让我困惑的点是,原来并不是让它输完了数据之后,再显示结果,而是直接输入完一行,就显示一行,所以上面那个例子,在程序里面,应该是:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">73</span> <span class="number">10</span></span><br><span class="line"><span class="literal">Yes</span></span><br><span class="line"><span class="number">23</span> <span class="number">2</span></span><br><span class="line"><span class="literal">Yes</span></span><br><span class="line"><span class="number">23</span> <span class="number">10</span></span><br><span class="line"><span class="literal">No</span></span><br><span class="line"><span class="number">-2</span></span><br></pre></td></tr></table></figure>

<p>这样子的.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我们为了让思维更加规整,先创建两个工具函数,一个用来判断某个数字是不是素数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsPrime</span>(<span class="params"><span class="keyword">int</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; input; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (input % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个函数用来反转素数:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Reverse</span>(<span class="params"><span class="keyword">int</span> prime, <span class="keyword">int</span> radix</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prime;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = result * radix + (n % radix);</span><br><span class="line">        n /= radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们只要获取到输入的数据,进行判断就行了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> line;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> D = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((line = System.Console.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span>[] tokens = line.Split();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span>.Parse(tokens[<span class="number">0</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            N = <span class="keyword">int</span>.Parse(tokens[<span class="number">0</span>]);</span><br><span class="line">            D = <span class="keyword">int</span>.Parse(tokens[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!IsPrime(Reverse(N, D)) || !IsPrime(<span class="keyword">int</span>.Parse(tokens[<span class="number">0</span>])))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"No"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Yes"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1011 World Cup Betting</title>
    <url>/2019/04/16/1011-World-Cup-Betting/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p>
<p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely <code>W</code> for win, <code>T</code> for tie, and <code>L</code> for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p>
<p>For example, 3 games’ odds are given as the following:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> W    T    L</span><br><span class="line"><span class="number">1.1</span>  <span class="number">2.5</span>  <span class="number">1.7</span></span><br><span class="line"><span class="number">1.2</span>  <span class="number">3.1</span>  <span class="number">1.6</span></span><br><span class="line"><span class="number">4.1</span>  <span class="number">1.2</span>  <span class="number">1.1</span></span><br></pre></td></tr></table></figure>

<p>To obtain the maximum profit, one must buy <code>W</code> for the 3rd game, <code>T</code> for the 2nd game, and <code>T</code> for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1×3.1×2.5×65%−1)×2=39.31 yuans (accurate up to 2 decimal places).</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to <code>W</code>, <code>T</code> and <code>L</code>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.1 2.5 1.7</span><br><span class="line">1.2 3.1 1.6</span><br><span class="line">4.1 1.2 1.1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T T W 39.31</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>就是说世界杯到了,赌球的时候也到了,现在有一种赌球玩法,有三个队伍,他们的获得W(胜利),T(平手),L(失败)的概率是表格里的数据,我们买的时候,分别买三个队伍里面概率最高的,每个买2元,就可以通过下面的公式算出我们的最大利润:</p>
<blockquote>
<p>(4.1×3.1×2.5×65%−1)×2=39.31</p>
</blockquote>
<p>现在给你三个队伍的数据,也是每个买2元,要你算出最大利润,并且要在输出结果时,分别说出你买了每个队的哪个情况,T T W 39.31是指第一个队伍买T,第二个队伍买T,第三个队伍买W,总利润39.31.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题也很简单了,给你三个数据,让你找出数据里面最大的数,然后代入公式就行了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] teams1 = System.Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">string</span>[] teams2 = System.Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">string</span>[] teams3 = System.Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">string</span>[] WTL = &#123; <span class="string">"W"</span>, <span class="string">"T"</span>, <span class="string">"L"</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span>[] t1 = <span class="keyword">new</span> <span class="keyword">double</span>[teams1.Length];</span><br><span class="line">    <span class="keyword">double</span>[] t2 = <span class="keyword">new</span> <span class="keyword">double</span>[teams2.Length];</span><br><span class="line">    <span class="keyword">double</span>[] t3 = <span class="keyword">new</span> <span class="keyword">double</span>[teams3.Length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i] = <span class="keyword">double</span>.Parse(teams1[i]);</span><br><span class="line">        t2[i] = <span class="keyword">double</span>.Parse(teams2[i]);</span><br><span class="line">        t3[i] = <span class="keyword">double</span>.Parse(teams3[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxindex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> socre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = t1[i];</span><br><span class="line">            maxindex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Write(WTL[maxindex] + <span class="string">" "</span>);</span><br><span class="line">    socre *= max;</span><br><span class="line">    max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t2.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t2[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = t2[i];</span><br><span class="line">            maxindex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Write(WTL[maxindex] + <span class="string">" "</span>);</span><br><span class="line">    socre *= max;</span><br><span class="line">    max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t3.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t3[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = t3[i];</span><br><span class="line">            maxindex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Write(WTL[maxindex] + <span class="string">" "</span>);</span><br><span class="line">    socre *= max;</span><br><span class="line">    socre = socre * <span class="number">0.65</span> * <span class="number">2</span> - <span class="number">2</span>;</span><br><span class="line">    Console.Write(socre.ToString(<span class="string">"0.00"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1008 Elevator</title>
    <url>/2019/04/16/1008-Elevator/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The highest building in our city has only one elevator. A request list is made up with <em>N</em> positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.</p>
<p>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a positive integer <em>N</em>, followed by <em>N</em> positive numbers. All the numbers in the input are less than 100.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the total time on a single line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 3 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">41</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一台电梯,有N层要停的楼,电梯从0层开始,上去一层要6s,下去一层要4s,每一层要停5s,到了最后的目的地之后就停在那,不用下来,求全程要花多少秒</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题也不难,只要判断当前的这一层比上一层高还是低就行了,但是这里有一个很坑的点,就是题目说:</p>
<blockquote>
<p>Each case contains a positive integer <em>N</em>, followed by <em>N</em> positive numbers.</p>
<p>每一个例子里包含一个整数N,后面跟着N个数字.</p>
</blockquote>
<p>也就是说,上面的例子</p>
<blockquote>
<p>3 2 3 1</p>
</blockquote>
<p>是指一共有3层,分别是2 3 1,第一个3只是告诉你有多少层,不算进层数里面的,一开始我用手算了很久都算不出来41,还以为哪里理解错了, 原来是 : (2x6+5)+(6+5)+(2x4+5)=41</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> before = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] floors = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">int</span>.Parse(tokens[<span class="number">0</span>])];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tokens.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        floors[i - <span class="number">1</span>] = <span class="keyword">int</span>.Parse(tokens[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; floors.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now = floors[i];</span><br><span class="line">        <span class="keyword">if</span> (now &gt; before)</span><br><span class="line">        &#123;</span><br><span class="line">            result += (now - before) * <span class="number">6</span> + <span class="number">5</span>;</span><br><span class="line">            before = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result += (before - now) * <span class="number">4</span> + <span class="number">5</span>;</span><br><span class="line">            before = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1005 Spell It Right</title>
    <url>/2019/04/16/1005-Spell-It-Right/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a non-negative integer <em>N</em>, your task is to compute the sum of all the digits of <em>N</em>, and output every digit of the sum in English.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies one line which contains an <em>N</em> (≤10100).</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one five</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一串数字,把各个位加起来,得到的结果,每一位用英文单词表达出来.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题比较简单,就是让你每一位求和,得到的结果再每一位去和英文单词匹配一下,这里要说一下,可以用两个方法去匹配单词,一可以直接用字符串数组,二可以用字典,但是我不知道用字典会慢多少.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int n = Convert.ToInt32(System.Console.ReadLine());</span></span><br><span class="line">    <span class="keyword">string</span> s = Console.ReadLine();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> num <span class="keyword">in</span> s)</span><br><span class="line">    &#123;</span><br><span class="line">		sum += System.Convert.ToInt32(num) - <span class="string">'0'</span>;</span><br><span class="line">		<span class="comment">//这里要注意不能直接用char转换成int,要减去48.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以用字典,也可以用数组.</span></span><br><span class="line">    <span class="comment">// Dictionary&lt;char, string&gt; dict = new Dictionary&lt;char, string&gt;();</span></span><br><span class="line">    <span class="comment">// dict.Add('0', "zero");</span></span><br><span class="line">    <span class="comment">// dict.Add('1', "one");</span></span><br><span class="line">    <span class="comment">// dict.Add('2', "two");</span></span><br><span class="line">    <span class="comment">// dict.Add('3', "three");</span></span><br><span class="line">    <span class="comment">// dict.Add('4', "four");</span></span><br><span class="line">    <span class="comment">// dict.Add('5', "five");</span></span><br><span class="line">    <span class="comment">// dict.Add('6', "six");</span></span><br><span class="line">    <span class="comment">// dict.Add('7', "seven");</span></span><br><span class="line">    <span class="comment">// dict.Add('8', "eight");</span></span><br><span class="line">    <span class="comment">// dict.Add('9', "nine");</span></span><br><span class="line">    <span class="keyword">string</span>[] dict = &#123; <span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>, <span class="string">"six"</span>, <span class="string">"seven"</span>, <span class="string">"eight"</span>, <span class="string">"nine"</span> &#125;;</span><br><span class="line">    s = sum.ToString();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		Console.Write(dict[s[i] - <span class="string">'0'</span>]);<span class="comment">//直接读取s[i]也是char,也要减去48.</span></span><br><span class="line">        <span class="keyword">if</span> (i != s.Length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1001 A+B Format</title>
    <url>/2019/04/16/1001-A-B-Format/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Calculate <em>a</em>+<em>b</em> and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where −10<sup>6</sup>≤<em>a</em>,<em>b</em>≤10<sup>6</sup>. The numbers are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1000000 9</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-999,991</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>把a和b两个数加起来,结果要用规定格式表示,规定格式是:从右往左数,每隔3位要加个逗号.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题如果直接从右往左硬撸会很不优雅,我一开始写的时候发现,怎么写都很啰嗦,结果在网上找到了<a href="https://www.liuchuo.net/archives/1888" target="_blank" rel="noopener">这篇答案</a>,发现里面有个判断逗号的方法相当巧妙:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">3</span> == s.Length % <span class="number">3</span> &amp;&amp; i != s.Length - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">     	Console.Write(<span class="string">","</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当我看到这个公式我就意识到我走错路了,不应该硬写,而是应该找其中的数学规律.</p>
<p>为什么当</p>
<blockquote>
<p>(i + 1) % 3 == s.Length % 3</p>
</blockquote>
<p>的时候,可以放一个逗号呢?</p>
<p>我们来尝试找一下规律:</p>
<ul>
<li>1,234,567 第<strong>1</strong>位,第<strong>4</strong>位后面加逗号,全长<strong>7</strong>位</li>
<li>12,234 第<strong>2</strong>位后面加逗号,全长<strong>5</strong>位</li>
<li>123,456 第<strong>3</strong>位后面加逗号,全长<strong>6</strong>位</li>
</ul>
<p>也就是说,除了第一个数的前面,和最后一个数的后面,我们从左往右数的第一个逗号应该在s.Length % 3这个位置,下一个逗号应该在这个位置往后走3位的位置,也就是说:</p>
<ul>
<li>第一个逗号:(i+1)==s.length%3</li>
<li>第二个逗号:(i+1)+3+3==s.length%3</li>
<li>第三个逗号:(i+1)+3+3+3==s.length%3</li>
<li>第n个逗号:(i+1)+3n==s.length%3</li>
</ul>
<p>这时候你会发现,加再多的3n结果再%3还是等于i+1,((i+1)+3n)%3==i+1,所以我们最后的公式就是:</p>
<blockquote>
<p>(i + 1) % 3 == s.Length % 3</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span>[] input = Console.ReadLine().Split(<span class="string">' '</span>);</span><br><span class="line">            <span class="keyword">int</span> a = Convert.ToInt32(input[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> b = Convert.ToInt32(input[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">string</span> s = (a + b).ToString();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(s[i]);</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">3</span> == s.Length % <span class="number">3</span> &amp;&amp; i != s.Length - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>开启windows的远程桌面功能</title>
    <url>/2019/04/09/%E5%BC%80%E5%90%AFwindows%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>微软的远程桌面功能从xp时代就已经有了,但是却很多人不知道要如何开启,下面就来介绍一下如何开启远程桌面功能</p>
<a id="more"></a>

<h2 id="确定Windows版本"><a href="#确定Windows版本" class="headerlink" title="确定Windows版本"></a>确定Windows版本</h2><p>这是一切的开始,微软的<strong>windows家庭版</strong>,<strong>教育版</strong>默认情况下:</p>
<ul>
<li>可以远程连接别的电脑</li>
<li>但是不能够被远程连接</li>
</ul>
<p>这是因为<strong>被远程连接</strong>这是一个高级功能,起码要专业版以上(专业版,企业版,服务器版)才行.教育版,家庭版虽然可以强行通过某些软件开启,但是并不是今天的主题,所以如果你的系统如果是家庭版,可以选择重装系统,或者强行升级成专业版,又或者去找别的教程看家庭版如何使用远程桌面.</p>
<h2 id="设置账号和密码"><a href="#设置账号和密码" class="headerlink" title="设置账号和密码"></a>设置账号和密码</h2><p>第一步,你的电脑必须要设置有密码,没有密码的话,远程桌面会连接失败</p>
<h2 id="开启远程桌面"><a href="#开启远程桌面" class="headerlink" title="开启远程桌面"></a>开启远程桌面</h2><ol>
<li>右键”我的电脑”,点击属性</li>
<li>点击左边的”远程设置”</li>
</ol>
<p><img src="https://i.loli.net/2019/04/09/5cabfc686b60a.png" alt=""></p>
<ol start="3">
<li>选择”允许远程连接到此电脑”</li>
</ol>
<p><img src="https://i.loli.net/2019/04/09/5cabfcfa741dc.png" alt=""></p>
<ol start="4">
<li>点击蓝色箭头的”选择用户”,这个时候你会看到你的账户已经可以进行远程连接了.</li>
</ol>
<p><img src="https://i.loli.net/2019/04/09/5cac0bb7bd5f1.png" alt=""></p>
<h2 id="进行远程连接-局域网"><a href="#进行远程连接-局域网" class="headerlink" title="进行远程连接(局域网)"></a>进行远程连接(局域网)</h2><h3 id="电脑连接电脑"><a href="#电脑连接电脑" class="headerlink" title="电脑连接电脑"></a>电脑连接电脑</h3><p>此时,只要是和你的电脑在<strong>同一个局域网</strong>(也可以说同一个路由器下)的设备,都可以使用”微软远程桌面”来远程连接到你的电脑</p>
<ul>
<li>winxp或者win7:可以直接在开始菜单-附件里面找到”远程桌面连接”</li>
<li>win10: 可以直接在搜索框搜索”远程桌面”,就可以打开远程桌面的设置界面了.(我这里只是设置了系统语言是英文,但是你打开的时候会是中文的)</li>
</ul>
<p><img src="https://i.loli.net/2019/04/09/5cac0cc664270.png" alt=""></p>
<p>要设置的其实只有两个地方,一个是上面图片的<strong>电脑</strong>和<strong>用户名</strong>,电脑是指被连接的电脑的ip地址,现在是你的电脑要被连接,所以就写上你自己电脑的局域网ip地址.用户名就是你的账号名称.</p>
<p><img src="https://i.loli.net/2019/04/09/5cac0e911bbf0.png" alt=""></p>
<p>另外一个可以设置的是红色箭头的体验选项,这里是你要告诉远程卓面这个软件,你的网络怎么样,如果网络好,就可以给你多一点动画效果,如果网络不好,那就少一点动画效果,这里建议取消勾选桌面背景和菜单动画,剩下的可以勾上.</p>
<p>点击连接,<strong>输入账号的密码</strong>,就可以在局域网下远程连接到电脑上了.</p>
<p><img src="https://i.loli.net/2019/04/09/5cac0fa8238e0.png" alt=""></p>
<h3 id="手机连接电脑"><a href="#手机连接电脑" class="headerlink" title="手机连接电脑"></a>手机连接电脑</h3><p>手机连接电脑和电脑连接电脑的步骤基本一样,只是电脑上都内置了”远程桌面连接”这个软件,而手机上要使用的话,要去下载一个”微软远程桌面”(也叫”RD Client”),这个软件默认是英文版的,但是单词都比较简单,或者评论区一般也会有发出汉化版地址的.</p>
<p>确保手机和电脑在同一个局域网下(同一个路由器),然后打开软件.</p>
<p><img src="https://i.loli.net/2019/04/09/5cac1128c4b31.jpg" alt=""></p>
<p>点击右上角的加号,添加一个远程电脑<br><img src="https://i.loli.net/2019/04/09/5cac1127e4b05.jpg" alt=""><br>点击ADD MANUAlLY</p>
<p><img src="https://i.loli.net/2019/04/09/5cac1128bf48c.jpg" alt=""></p>
<p>PC name输入电脑的ip地址</p>
<p>User name 点击 添加一个账户,输入电脑的用户名和密码,就可以了</p>
<p><img src="https://i.loli.net/2019/04/09/5cac1127e849a.png" alt=""></p>
<p><strong>在手机设置上取消”方向锁定”</strong>,有的手机叫”自动方向”,或者”自动旋转”,一定要让手机<strong>可以自动旋转</strong>,也就是指手机横屏时,软件也会横过来这个状态.取消方向锁定是因为这个app到现在对全面屏(刘海屏,水滴屏)的适配还没有到位,直接设置它的横屏模式会导致鼠标位置偏移等问题.</p>
<p><img src="https://i.loli.net/2019/04/09/5cac13959f4a3.jpg" alt=""></p>
<p>关闭了方向锁定之后,进入软件,点击连接,手机就可以连接到电脑上了.</p>
<p><img src="https://i.loli.net/2019/04/09/5cac1395849d7.jpg" alt=""></p>
<p>注意,现在这台被连接的电脑,同一时间内只能被一个账号连接,而一个账号只能在一台设备上连接,也就是说,你的A账号用手机连接电脑的时候,电脑会被踢下线,而电脑登录A账号的时候,手机就被踢下线,并且如果你的电脑有B账号,手机用B账号连接电脑,A账号也会被踢下线.</p>
<p>解决方法,请看这篇文章:</p>
<p><a href="https://jiayaoo3o.github.io/2019/04/09/%E8%A7%A3%E9%99%A4windows10%E5%A4%9A%E8%B4%A6%E6%88%B7%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E9%99%90%E5%88%B6/">解除windows10多账户远程桌面连接限制</a></p>
<h2 id="进行远程连接-内网穿透"><a href="#进行远程连接-内网穿透" class="headerlink" title="进行远程连接(内网穿透)"></a>进行远程连接(内网穿透)</h2><p>虽然现在可以使用远程连接,但是得让两个设备都在同一个路由器下面,功能上有局限性,而想要外网也能够远程连接,我们需要内网穿透,具体操作请看这篇文章:</p>
<p><a href="https://jiayaoo3o.github.io/2019/03/01/Sakura-Frp-%E5%85%8D%E8%B4%B9%E7%9A%84%E9%AB%98%E9%80%9F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/">Sakura frp–免费的高速内网穿透工具</a></p>
<p>进行了内网穿透之后,就可以按照这篇教程的操作继续连接了.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>windows10</tag>
        <tag>远程桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>解除windows10多账户远程桌面连接限制</title>
    <url>/2019/04/09/%E8%A7%A3%E9%99%A4windows10%E5%A4%9A%E8%B4%A6%E6%88%B7%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>从上一篇文章开启<a href="https://jiayaoo3o.github.io/2019/04/09/%E5%BC%80%E5%90%AFwindows%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8A%9F%E8%83%BD/">windows的远程桌面功能</a>我们说到,windows默认情况下只能同时登录一个账号,并且手机连上电脑,电脑就会退出登录,被踢下线,这是因为,能让多个账号远程连接到一个电脑,这个是服务器版才该有的功能,你想想,多个账号连接一台电脑,那这个电脑不应该就是服务器吗?所以想要让windows10支持多账户远程桌面连接,我们需要一点点设置.</p>
<a id="more"></a>

<h2 id="创建新的账户"><a href="#创建新的账户" class="headerlink" title="创建新的账户"></a>创建新的账户</h2><p>想要多账户连接到自己的电脑,那首先就得先创建一个新的账户,打开</p>
<blockquote>
<p>系统设置-账户-家庭&amp;其他用户</p>
</blockquote>
<p>点击<strong>添加一个其他用户</strong></p>
<p><img src="https://i.loli.net/2019/04/09/5cac4b60a2df4.png" alt=""></p>
<p>这个时候就可以输入新建用户名和密码,完成账户的添加.</p>
<p>给该用户远程连接权限</p>
<p>现在这个新建的用户只是一个普通账户,并不是管理员账户,所以并没有远程连接的默认权限,我们要去允许该账户进行远程连接</p>
<blockquote>
<p>右键我的电脑-属性-远程设置-选择用户</p>
</blockquote>
<p><img src="https://i.loli.net/2019/04/09/5cac0bb7bd5f1.png" alt=""></p>
<p>点击”添加”按钮,然后在框内输入你刚刚创建的用户名,点击”名字检查”,系统就会找到这个用户</p>
<p><img src="https://i.loli.net/2019/04/09/5cac4cfa32e64.png" alt=""></p>
<p>这个时候点击ok,这个用户就有了远程连接的权限了.</p>
<h2 id="配置本地组策略"><a href="#配置本地组策略" class="headerlink" title="配置本地组策略"></a>配置本地组策略</h2><p>虽然现在已经有了两个账号,但是在默认情况下,A账号登录B就会被踢下来,B登录A也会被踢下来,所以现在要设置组策略</p>
<p>在左下角搜索框中输入gp,系统就会自动帮你找到<strong>组策略编辑器</strong>,打开后,依次点击:</p>
<blockquote>
<p>管理模板-Windows组件-远程桌面服务-远程桌面会话主机-连接</p>
</blockquote>
<ol>
<li><p>双击右边的<strong>限制连接的数量</strong>,选择<strong>已启用</strong>,然后在下面选择你想开启的最大连接数,一般填个3都够用了.</p>
</li>
<li><p>双击右边的<strong>将远程桌面服务用户限制到单独的远程桌面服务会话</strong>,<em>这里很多的教程会建议改成<strong>已禁用</strong>,但是我的建议是把这里改成<strong>已启用</strong>!!!</em></p>
</li>
</ol>
<p>要知道为什么这么改,我们首先要知道这个设置是干嘛的.</p>
<p>将用户限制到单独的远程桌面服务,是指 : 如果我手机连上A账号,电脑就不能连上A账号,电脑连上了,手机就会掉线.</p>
<p>那为什么我们要启用这个功能?因为<strong>这时候手机和电脑使用的是同一个A账号的资源</strong>,举个例子,当你用手机连接电脑的A账号在远程看电影,这时候你的电脑用A账号登录,就会把手机踢下线,但是你会发现,电脑现在的界面就在播放着手机刚刚看的视频,因为这时候他们两个用的是同一个资源,所以会有一种无缝连接的感觉,远程桌面的内容,就是电脑本身的内容.</p>
<p>而你如果<strong>关闭</strong>了<strong>将远程桌面服务用户限制到单独的远程桌面服务会话</strong>这个功能,就会导致一个用户可以开启多个远程桌面服务会话,<strong>手机和电脑使用的是不同的A账号资源</strong>.这又是什么意思?</p>
<p>就是说,如果你电脑现在正在登录A账号,手机选择远程桌面登录A账号,<strong>此时电脑的A账号不会被踢下线,而是两个A账号同时工作</strong>!但是手机的A账户的资源是完全独立于电脑A账户的,电脑A账户打开了浏览器,但是手机A账户看不见,手机A账户远程打开电影,电脑A账户也看不见,两者互相独立的远程会话.</p>
<p>这样的问题在于,<strong>每次退出远程桌面连接都必须手动点击”注销”按钮</strong>,将你的远程A账户的资源清空掉,而不可以直接关闭远程桌面App,如果直接关闭App,这个单独的A账户就会显示”断开连接”,然后就一直孤零零的在后台消耗资源,直到你主动连接到这个资源,然后注销.</p>
<p>如果你的手机退出远程桌面连接,然后又重新连接一次,<strong>并不会连上刚刚的断开连接的A账号,而是重新分配一个全新的A账号资源给你</strong>,这样你的电脑就有3个A账号在工作,系统资源就会被严重浪费,直接卡爆.</p>
<p>因此,我建议是把这个功能<strong>启用着</strong>,会更合适一般人.</p>
<h2 id="开启多用户连接功能"><a href="#开启多用户连接功能" class="headerlink" title="开启多用户连接功能"></a>开启多用户连接功能</h2><p>虽然刚刚设置了最大连用户数,但是我们的系统本质上装的并不是服务器版本,所以到目前为止我们还是不能够多用户同时连接的,要去github上下载<a href="https://github.com/stascorp/rdpwrap/releases/download/v1.6.2/RDPWrap-v1.6.2.zip" target="_blank" rel="noopener">RDPWrap</a>这个软件(不要去csdn等地方下载来路不明的文件,直接去github原作者那下载是最好的).</p>
<p>解压之后我们右键选择用管理员依次运行这三个文件</p>
<ul>
<li>install.bat</li>
<li>update.bat</li>
<li>RDPConf.exe</li>
</ul>
<p>如果你的系统版本太新,那你很可能箭头这里依然会显示[not supported]</p>
<p><img src="https://i.loli.net/2019/04/09/5cac551aa9a44.png" alt=""></p>
<p>这时候<a href="https://github.com/stascorp/rdpwrap/files/2949950/rdpwrap.zip" target="_blank" rel="noopener">点击下载</a>这个文件,解压后将里面的rdpwrap.ini文件替换到</p>
<blockquote>
<p>C:\Program Files\RDP Wrapper</p>
</blockquote>
<p>再重复刚刚的步骤应该就可以看到[fully supported]的字眼了.</p>
<p>如果你的系统比1089还新,或者更换了rdpwrap.ini文件仍然不支持,就需要到这个代码仓库的<a href="https://github.com/stascorp/rdpwrap/issues" target="_blank" rel="noopener">issues</a>里面搜索你的系统版本(也就是上面的<strong>10.0.17763.292</strong>字眼),一般来说都会有人贴出新系统的配置信息,你只要把这个配置信息粘贴到刚刚那个rdpurap.ini文件的末尾就行了.例如下图:</p>
<p><img src="https://i.loli.net/2019/04/14/5cb29e742f1c9.png" alt=""></p>
<p>到这里,所有的步骤就都结束了,你的电脑现在可以让两个账户同时连接而不掉线了.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>windows10</tag>
        <tag>远程桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>优质软件集锦</title>
    <url>/2019/03/26/%E4%BC%98%E8%B4%A8%E8%BD%AF%E4%BB%B6%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="Windows10-1903"><a href="#Windows10-1903" class="headerlink" title="Windows10 1903+"></a><a href="https://jiayaoo3o.github.io/2019/03/11/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E7%BB%9D%E5%AF%B9%E7%BA%AF%E5%87%80%E7%9A%84Windows10%E9%95%9C%E5%83%8F/">Windows10</a> 1903+</h3><p>最好用的linux发行版</p>
<hr>
<h2 id="软件包管理器"><a href="#软件包管理器" class="headerlink" title="软件包管理器"></a>软件包管理器</h2><h3 id="scoop"><a href="#scoop" class="headerlink" title="scoop"></a><a href="https://jiayaoo3o.github.io/2019/01/30/windows%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8-scoop/">scoop</a></h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set-executionpolicy</span> remotesigned <span class="literal">-s</span> currentuser</span><br><span class="line">iex (<span class="built_in">new-object</span> net.webclient).downloadstring(<span class="string">'https://get.scoop.sh'</span>)</span><br><span class="line">scoop bucket add java</span><br><span class="line">scoop bucket add extras</span><br><span class="line">scoop bucket add Ash258 <span class="string">'https://github.com/Ash258/scoop-Ash258.git'</span></span><br><span class="line">scoop bucket add jetbrains</span><br></pre></td></tr></table></figure>
<hr>
<a id="more"></a>

<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3>  <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>python</span><br></pre></td></tr></table></figure>
<h3 id="dotnet-core"><a href="#dotnet-core" class="headerlink" title="dotnet core"></a>dotnet core</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>dotnet-sdk</span><br></pre></td></tr></table></figure>

<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>openjdk11</span><br><span class="line"><span class="keyword">scoop </span>isntall corretto8</span><br></pre></td></tr></table></figure>

<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>kotlin</span><br></pre></td></tr></table></figure>

<h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>maven</span><br></pre></td></tr></table></figure>

<h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>gradle</span><br></pre></td></tr></table></figure>

<h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>tomcat</span><br></pre></td></tr></table></figure>

<h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>gcc</span><br></pre></td></tr></table></figure>

<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>gdb</span><br></pre></td></tr></table></figure>

<h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>cmake</span><br></pre></td></tr></table></figure>

<h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>nodejs</span><br></pre></td></tr></table></figure>

<h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>go</span><br></pre></td></tr></table></figure>

<h3 id="android"><a href="#android" class="headerlink" title="android"></a>android</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span><span class="keyword">android-sdk</span></span><br></pre></td></tr></table></figure>

<h3 id="flutter"><a href="#flutter" class="headerlink" title="flutter"></a>flutter</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>flutter</span><br></pre></td></tr></table></figure>

<h3 id="dart"><a href="#dart" class="headerlink" title="dart"></a>dart</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>dart</span><br></pre></td></tr></table></figure>
<h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>mongodb</span><br></pre></td></tr></table></figure>

<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>mysql</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>宇宙第一编辑器</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>vscode-portable</span><br></pre></td></tr></table></figure>

<h3 id="Visual-Studio-2019"><a href="#Visual-Studio-2019" class="headerlink" title="Visual Studio 2019"></a><a href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener">Visual Studio 2019</a></h3><p>宇宙第一ide</p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a><a href="https://jiayaoo3o.github.io/2019/03/21/Git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/">git</a></h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>git</span><br></pre></td></tr></table></figure>

<h3 id="svn"><a href="#svn" class="headerlink" title="svn"></a>svn</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>tortoisesvn</span><br></pre></td></tr></table></figure>

<h3 id="android-studio"><a href="#android-studio" class="headerlink" title="android-studio"></a>android-studio</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span><span class="keyword">android-studio</span></span><br></pre></td></tr></table></figure>

<h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>IntelliJ-IDEA-portable</span><br></pre></td></tr></table></figure>

<h3 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>pycharm</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h2><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>命令行文本编辑器,退出请按esc,输入:!q</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>vim</span><br></pre></td></tr></table></figure>

<h3 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h3><p>体验优异的markdown编辑器</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>typora</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>cmder</span><br></pre></td></tr></table></figure>

<h3 id="terminus"><a href="#terminus" class="headerlink" title="terminus"></a>terminus</h3><p>高颜值命令行终端</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>terminus</span><br></pre></td></tr></table></figure>
<h3 id="WindowsTerminal"><a href="#WindowsTerminal" class="headerlink" title="WindowsTerminal"></a>WindowsTerminal</h3><p>微软新出的terminal工具</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>WindowsTerminal</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>chrome</span><br></pre></td></tr></table></figure>

<h3 id="firefox"><a href="#firefox" class="headerlink" title="firefox"></a>firefox</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>firefox</span><br></pre></td></tr></table></figure>
<h3 id="新edge"><a href="#新edge" class="headerlink" title="新edge"></a>新edge</h3><hr>
<h2 id="文件解压工具"><a href="#文件解压工具" class="headerlink" title="文件解压工具"></a>文件解压工具</h2><h3 id="bandizip"><a href="#bandizip" class="headerlink" title="bandizip"></a>bandizip</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span><span class="keyword">bandizip</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="文件搜索工具"><a href="#文件搜索工具" class="headerlink" title="文件搜索工具"></a>文件搜索工具</h2><h3 id="everything"><a href="#everything" class="headerlink" title="everything"></a>everything</h3><p>体验优异的文件搜索工具,请将everything开机启动并且一直放在后台</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>everything</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="软件卸载工具"><a href="#软件卸载工具" class="headerlink" title="软件卸载工具"></a>软件卸载工具</h2><h3 id="geekuninstaller"><a href="#geekuninstaller" class="headerlink" title="geekuninstaller"></a>geekuninstaller</h3><p>卸载软件后自动检测文件残留</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>geekuninstaller</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h2><h3 id="potplayer"><a href="#potplayer" class="headerlink" title="potplayer"></a>potplayer</h3><p>最好用的视频播放器</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>potplayer</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><h3 id="shadowsocksr"><a href="#shadowsocksr" class="headerlink" title="shadowsocksr"></a>shadowsocksr</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span><span class="keyword">shadowsocksr-csharp</span></span><br></pre></td></tr></table></figure>
<h3 id="V2rayN"><a href="#V2rayN" class="headerlink" title="V2rayN"></a>V2rayN</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>v2rayn</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><h3 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h3><p>多线程下载,但是bt种子该没速度还是没有</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>aria2</span><br></pre></td></tr></table></figure>

<h3 id="Free-Download-Manger"><a href="#Free-Download-Manger" class="headerlink" title="Free Download Manger"></a>Free Download Manger</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>freedownloadmanger</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="密码管理工具"><a href="#密码管理工具" class="headerlink" title="密码管理工具"></a>密码管理工具</h2><h3 id="bitwarden"><a href="#bitwarden" class="headerlink" title="bitwarden"></a><a href="https://bitwarden.com/" target="_blank" rel="noopener">bitwarden</a></h3><p>体验最好的开源密码管理器</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span><span class="keyword">bitwarden</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="影音制作"><a href="#影音制作" class="headerlink" title="影音制作"></a>影音制作</h2><h3 id="Adobe2019全家桶"><a href="#Adobe2019全家桶" class="headerlink" title="Adobe2019全家桶"></a><a href="https://jiayaoo3o.github.io/2019/03/22/AdobeCC2019%E6%BF%80%E6%B4%BB%E8%A1%A5%E4%B8%81/">Adobe2019全家桶</a></h3><h3 id="万兴神剪手"><a href="#万兴神剪手" class="headerlink" title="万兴神剪手"></a><a href="https://www.shencut.com/" target="_blank" rel="noopener">万兴神剪手</a></h3><p>适合新手入门的视频剪辑软件</p>
<h3 id="arctime"><a href="#arctime" class="headerlink" title="arctime"></a><a href="https://arctime.org/" target="_blank" rel="noopener">arctime</a></h3><p>强大的字幕软件</p>
<h3 id="格式工厂"><a href="#格式工厂" class="headerlink" title="格式工厂"></a>格式工厂</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">insatll </span>format-factory</span><br></pre></td></tr></table></figure>

<h3 id="screentogif"><a href="#screentogif" class="headerlink" title="screentogif"></a>screentogif</h3><p>将视频或录屏转换成gif</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">insatll </span><span class="keyword">screentogif</span></span><br></pre></td></tr></table></figure>

<h3 id="obs-studio"><a href="#obs-studio" class="headerlink" title="obs-studio"></a>obs-studio</h3><p>体验最好的直播软件与录屏软件</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">insatll </span>obs-studio</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h2><h3 id="微软远程桌面"><a href="#微软远程桌面" class="headerlink" title="微软远程桌面"></a>微软远程桌面</h3><p>性能最好的局域网远程桌面软件,外网远程控制需要<a href="https://jiayaoo3o.github.io/2019/03/01/Sakura-Frp-%E5%85%8D%E8%B4%B9%E7%9A%84%E9%AB%98%E9%80%9F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/">内网穿透</a>.</p>
<p>全面屏,刘海屏等非16:9手机请打开手机的自动旋转,等app横屏之后再关闭自动旋转,否则会有显示错位.</p>
<h3 id="teamviewer"><a href="#teamviewer" class="headerlink" title="teamviewer"></a>teamviewer</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>teamviewer</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h2><h3 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>snipaste</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="Diskgenius"><a href="#Diskgenius" class="headerlink" title="Diskgenius"></a>Diskgenius</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span><span class="keyword">diskgenius</span></span><br></pre></td></tr></table></figure>


<h3 id="SpaceSniffer"><a href="#SpaceSniffer" class="headerlink" title="SpaceSniffer"></a>SpaceSniffer</h3><p>直观的磁盘占用分析软件</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">insatll </span>SpaceSniffer</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="游戏管理"><a href="#游戏管理" class="headerlink" title="游戏管理"></a>游戏管理</h2><h3 id="steam"><a href="#steam" class="headerlink" title="steam"></a>steam</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>steam</span><br></pre></td></tr></table></figure>

<h3 id="uplay"><a href="#uplay" class="headerlink" title="uplay"></a>uplay</h3><p>免费游戏领取器</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">insatll </span>uplay</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>个人安利</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>AdobeCC2019激活补丁</title>
    <url>/2019/03/22/AdobeCC2019%E6%BF%80%E6%B4%BB%E8%A1%A5%E4%B8%81/</url>
    <content><![CDATA[<h1 id="请不要在任何商业活动中使用非正版Adobe全家桶"><a href="#请不要在任何商业活动中使用非正版Adobe全家桶" class="headerlink" title="请不要在任何商业活动中使用非正版Adobe全家桶"></a>请不要在任何商业活动中使用非正版Adobe全家桶</h1><p>有很多人想要用付费软件时,第一时间想到的是去各种软件下载站下载所谓的”破解版”,这是不应该的,因为很多软件并不需要”破解”,只要在官方下载的正版软件上输入一个注册码,或者改变一个激活文件就行了,而下载的”破解版”,你是不知道别人在里面更改了什么东西的,所以”正确”的激活方法,应该是去官网下载软件,安装之后自己激活,而不是去找”破解版”.</p>
<a id="more"></a>

<p>下面的软件,都可以去官网下载安装后激活而不需要找”破解版”:</p>
<ul>
<li>Adobe系列软件</li>
<li>office系列软件</li>
<li>windows系统系列</li>
<li>各种制图软件,3d建模软件系列</li>
</ul>
<p>adobe系列软件从2019版开始,改变了激活策略,以前用软件更换一个amtlib.dll的方法,只能激活19年以前的版本,现在已经不能用了.</p>
<p>但是好在现在依然能通过更换注册补丁的方法来激活,只是稍微复杂一点点而已,全部步骤如下:</p>
<ol>
<li><p>在<a href="https://www.adobe.com/cn/" target="_blank" rel="noopener">adobe官方网站</a>下载页面找到免费试用,开始下载和安装你需要的软件.</p>
</li>
<li><p>安装完你需要的软件之后,打开它,它应该会弹出一个”试用7天”的窗口的,这时候关闭软件.</p>
</li>
<li><p>[点击下载](<a href="https://www6.zippyshare.com/d/3jRFC4r7/419067/Zer0Cod3" target="_blank" rel="noopener">https://www6.zippyshare.com/d/3jRFC4r7/419067/Zer0Cod3</a> End October Cracks 30-10-2018.zip)Zer0Cod3制作的AdobeCC2019激活补丁,文件大小224M,下载完成之后解压到任意一个文件夹<img src="https://i.loli.net/2019/03/22/5c94a2ec822e9.png" alt=""></p>
</li>
<li><p>找到你需要激活的软件的补丁压缩包,双击解压,例如AE2019,解压后的.dll文件,就是我们需要的激活补丁了,现在要把这两个激活补丁放到他们应该在的地方,所以接下来我们要找到他们原本所在文件夹<img src="https://i.loli.net/2019/03/22/5c94a3342b898.png" alt=""></p>
</li>
<li><p>打开安装Adobe的文件目录,一般所有Adobe软件都装在C:\Program Files\Adobe文件夹内,例如AE的安装目录是:</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">C:<span class="symbol">\P</span>rogram Files<span class="symbol">\A</span>dobe<span class="symbol">\A</span>dobe After Effects CC 2019</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开软件的文件夹之后,在<strong>右上方的搜索框</strong>分别搜索刚刚的补丁的名字,在找到的结果上<strong>右键</strong>,选择<strong>打开文件所在位置</strong><img src="https://i.loli.net/2019/03/22/5c94a4f1f0b9d.png" alt=""></p>
</li>
<li><p>将同名的激活补丁粘贴到这个文件的所在目录,替换掉原来的文件<img src="https://i.loli.net/2019/03/22/5c94a5639843a.png" alt=""></p>
</li>
<li><p>再次打开Adobe的软件,应该就已经激活成功了.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Adobe</tag>
      </tags>
  </entry>
  <entry>
    <title>Git操作手册</title>
    <url>/2019/03/21/Git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h2>  <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh-keygen</span></span><br></pre></td></tr></table></figure>

<h2 id="查看git配置信息"><a href="#查看git配置信息" class="headerlink" title="查看git配置信息"></a>查看git配置信息</h2>  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--list</span><br></pre></td></tr></table></figure>

<h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2>  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global : 当前用户</span><br><span class="line">git<span class="built_in"> config </span>--system : 整个系统</span><br><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"jiayao"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.email jiayao3.14@outlook.com</span><br><span class="line">git<span class="built_in"> config </span>--global core.editor vim : 设置默认编辑器</span><br><span class="line">git<span class="built_in"> config </span>--global alias.alias full_name : 设置别名</span><br></pre></td></tr></table></figure>

<h2 id="初始化git仓库"><a href="#初始化git仓库" class="headerlink" title="初始化git仓库"></a>初始化git仓库</h2>  <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="添加文件到仓库-暂存已修改文件"><a href="#添加文件到仓库-暂存已修改文件" class="headerlink" title="添加文件到仓库/暂存已修改文件"></a>添加文件到仓库/暂存已修改文件</h2>  <figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> &lt;file&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="取消暂存"><a href="#取消暂存" class="headerlink" title="取消暂存"></a>取消暂存</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span> &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="取消修改"><a href="#取消修改" class="headerlink" title="取消修改"></a>取消修改</h2><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">-- &lt;file&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h2>  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> -m "massage"</span><br><span class="line">git <span class="keyword">commit</span> -a : 跳过使用暂存区,直接将修改的文件提交</span><br><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend : 重新提交来覆盖上一次操作</span></span><br></pre></td></tr></table></figure>

<h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2>  <figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">&lt;url</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h2>  <figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git status -s : 紧凑输出</span><br><span class="line">?? : 未跟踪</span><br><span class="line">A : 新添加到暂存区</span><br><span class="line">左M : 修改并且加入暂存区</span><br><span class="line">右M : 修改但未加入暂存区</span><br><span class="line">MM : 修改后加入暂存区又被修改</span><br></pre></td></tr></table></figure>

<h2 id="忽略文件-gitignore"><a href="#忽略文件-gitignore" class="headerlink" title="忽略文件.gitignore"></a>忽略文件.gitignore</h2><p>github的<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">忽略文件列表</a>,忽略文件应该在仓库创建后马上添加,因为已经提交了的文件,哪怕后来被加入了忽略列表,也并不会自动忽略.</p>
<h2 id="比较文件差异"><a href="#比较文件差异" class="headerlink" title="比较文件差异"></a>比较文件差异</h2>  <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">diff </span>: 比较当前已修改和已暂存文件的差异</span><br><span class="line">git <span class="keyword">diff </span>--staged : 比较已暂存和已提交的文件差异</span><br><span class="line">git <span class="keyword">diff </span>--<span class="keyword">cached</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">diff </span>--check : 查找空白错误</span><br></pre></td></tr></table></figure>

<h2 id="删除已跟踪文件"><a href="#删除已跟踪文件" class="headerlink" title="删除已跟踪文件"></a>删除已跟踪文件</h2>  <figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">rm</span> --cached &lt;<span class="keyword">file</span>&gt; : 会将文件移除暂存区但是不会删除文件本身</span><br><span class="line">git <span class="keyword">rm</span> &lt;<span class="keyword">file</span>&gt; : 会将文件移出仓库并且删除</span><br></pre></td></tr></table></figure>

<h2 id="更改文件名称"><a href="#更改文件名称" class="headerlink" title="更改文件名称"></a>更改文件名称</h2>  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">mv file_from file_to : 等于下面三个命令</span></span><br><span class="line"><span class="attr">mv</span> <span class="string">file_from file_to</span></span><br><span class="line"><span class="attr">git</span> <span class="string">rm file_from</span></span><br><span class="line"><span class="attr">git</span> <span class="string">add file_to</span></span><br></pre></td></tr></table></figure>

<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2>  <figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> -p <span class="number">-2</span> : 添加-p显示每次提交的差异,<span class="number">-2</span>表示最近两次</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--stat : 查看每次提交的简略统计信息</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--since : 从什么时候开始</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--until : 直到什么时候</span></span><br></pre></td></tr></table></figure>

<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">add</span> <span class="symbol">&lt;shortname&gt;</span> <span class="symbol">&lt;url&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">show</span> [remote-<span class="type">name</span>]</span><br></pre></td></tr></table></figure>
<h2 id="拉取远程仓库"><a href="#拉取远程仓库" class="headerlink" title="拉取远程仓库"></a>拉取远程仓库</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">fetch</span> [remote-<span class="type">name</span>] : 只是拉取,但是不会自动合并</span><br><span class="line">git pull [remote-<span class="type">name</span>] : 拉取并且合并到当前分支</span><br></pre></td></tr></table></figure>

<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git push [remote-<span class="built_in">name</span>] [branch-<span class="built_in">name</span>]</span><br></pre></td></tr></table></figure>

<h2 id="移除远程仓库"><a href="#移除远程仓库" class="headerlink" title="移除远程仓库"></a>移除远程仓库</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> remote rm<span class="meta"> [remote-name]</span></span><br></pre></td></tr></table></figure>

<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git branch &lt;<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout &lt;name&gt; : 可以切换分支,或者<span class="type">HEAD</span>移动到某个提交</span><br><span class="line">git checkout -b &lt;name&gt; : 创建并且切换到新建分支</span><br></pre></td></tr></table></figure>

<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git merge <span class="tag">&lt;<span class="name">target_branch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git rebase target : 把自身分支变基到target分支,此时切换到target分支进行merge会产生快速合并</span><br><span class="line">git rebase --onto master<span class="built_in"> server client </span>: 取出<span class="built_in"> client </span>分支，找出处于<span class="built_in"> client </span>分支和<span class="built_in"> server </span>分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍</span><br><span class="line">git rebase [basebranch] [topicbranch] : 可以省略切换分支再变基的步骤</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>小米手机刷机教程</title>
    <url>/2019/03/19/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>小米作为为数不多的还愿意开放bootloader锁的厂家,刷机其实是比较简单的,总的来说可以归纳为以下4步:</p>
<ol>
<li>为自己的小米账号申请解锁权限.</li>
<li>用该账号解锁自己的手机</li>
<li>刷机(可选卡刷或者线刷).</li>
<li>(可选)刷magisk获得root权限.</li>
</ol>
<p>第一次刷机需要准备的东西比较多,但是只要第一次成功了,以后刷机只需要更换一个刷机包就行了,其他都是现成不变的,而且失败了也没关系,手机没这么容易坏,还是能救回来的,哪怕真的刷坏了也没关系,小米依然保修的.</p>
<p>接下来详细讲解各个步骤.</p>
<a id="more"></a>

<h2 id="申请解锁权限"><a href="#申请解锁权限" class="headerlink" title="申请解锁权限"></a>申请解锁权限</h2><p>进入miui网站的<a href="http://www.miui.com/unlock/index.html" target="_blank" rel="noopener">申请解锁页面</a>,用自己的账号登录来申请解锁权限,注意:</p>
<ol>
<li>此时有可能需要0到360个小时的审核时间,有的账号申请马上可以过,有的账号要等15天,这个是小米决定的.</li>
<li>不要借别人的账号给自己的手机解锁,因为现在解锁要求手机和电脑同时登录同一个账号,而让自己的手机登录别人的账号是十分不安全的.</li>
<li>单个账号,一个月内只能解锁同一台设备,即你的A手机一个月内可以反复解锁,但是要等一个月后才能解锁你的B手机.</li>
<li>解锁权限获得之后一直有效,不需要再次申请.</li>
</ol>
<h2 id="解锁你的手机"><a href="#解锁你的手机" class="headerlink" title="解锁你的手机"></a>解锁你的手机</h2><p>(警告,<strong>解锁</strong>会<strong>删除你的手机内的所有数据,格式化整个手机</strong>,请做好备份)</p>
<p>申请成功之后,<a href="http://miuirom.xiaomi.com/rom/u1106245679/3.3.1212.33/miflash_unlock-3.3.1212.33.zip" target="_blank" rel="noopener">下载解锁工具</a>,开始解锁你的手机,步骤如下:</p>
<ol>
<li><p>手机登录该账号.</p>
</li>
<li><p>手机关机,按住<strong>音量下键+开机键</strong>,会进入fastboot界面,如果失败请反复尝试.</p>
<p><img src="http://www.miui.com/unlock/images/bl_apply_2.png" alt=""></p>
</li>
<li><p>电脑端启动解锁工具,用同一个账号登录,开始解锁.<img src="https://i.loli.net/2019/03/19/5c9106a03faff.png" alt=""></p>
</li>
<li><p>解锁完成后,手机会重启,<strong>恢复出厂设置</strong>.<br>(再次警告,解锁会<strong>删除你的手机内的所有数据,格式化整个手机</strong>,请做好备份)</p>
</li>
</ol>
<h2 id="开始刷机"><a href="#开始刷机" class="headerlink" title="开始刷机"></a>开始刷机</h2><p> 刷机分为两种模式,一种叫<strong>线刷</strong>,即手机用数据线连接到电脑,用电脑刷机;另一种叫<strong>卡刷</strong>,即把刷机包放在手机里,用手机刷机(当年是用内存卡的,所以叫卡刷).</p>
<p>接下来分别介绍.</p>
<h3 id="1-线刷刷机"><a href="#1-线刷刷机" class="headerlink" title="1.线刷刷机"></a>1.线刷刷机</h3><ol>
<li><p>在<a href="http://www.miui.com/shuaji-393.html" target="_blank" rel="noopener">线刷包下载页面</a>下载属于你手机的系统刷机包,注意线刷包都带有<strong>fastboot</strong>字眼的.</p>
<p>小米的系统分为开发板和稳定版,开发板基本每周更新,稳定版大约一个月更新一次.</p>
<p>下载完成之后,解压该刷机包.</p>
</li>
<li><p>手机关机,按住<strong>音量下键+开机键</strong>,进入fastboot界面,手机连接电脑.</p>
</li>
<li><p>下载<a href="http://bigota.d.miui.com/tools/MiFlash2018-5-28-0.zip" target="_blank" rel="noopener">小米线刷刷机工具MiFlash</a>,解压,打开该软件.</p>
<p><img src="https://i.loli.net/2019/03/20/5c911352c2331.png" alt=""></p>
<p>点击蓝色框的<strong>加载设备</strong>,会加载已经连接的手机设备.</p>
<p>点击红色框的<strong>选择</strong>,选择刚刚解压的线刷包.</p>
<p>点击黄色框的三个选项中的一个,其中:</p>
<ul>
<li><strong>全部删除</strong>会删除手机的所有数据,不会有任何残留,不需要再次解锁.</li>
<li><strong>全部删除并且lock</strong>在删除的基础上,会锁定你的手机,即下次刷机还得用账号解锁一次.</li>
<li><strong>保留用户数据</strong>会保留用户的文件和所安装的app,不需要再次解锁.</li>
</ul>
<p>建议选择全部删除.</p>
</li>
<li><p>确定无误之后,点击绿色框的<strong>刷机</strong>,即可开始刷机,刷机过程只要进度条没有红色警告就是正常现象,刷机完成后手机会自动重启.</p>
</li>
</ol>
<p>注意,线刷是一个非常底层的操作,所以只要手机能进入fastboot界面,都能通过线刷救回来,线刷也是最彻底,最干净的一种刷机方式,<strong>但是一定要注意备份资料</strong>.</p>
<hr>
<h3 id="2-卡刷刷机"><a href="#2-卡刷刷机" class="headerlink" title="2.卡刷刷机"></a>2.卡刷刷机</h3><p>卡刷相对于线刷会更快,也更灵活,步骤如下:</p>
<ol>
<li><p>在小米<a href="http://www.miui.com/download.html" target="_blank" rel="noopener">miui官网</a>下载你手机的卡刷包(文件名中没有fastboot字眼,以.zip结尾).</p>
</li>
<li><p>在<a href="https://twrp.me/Devices/Xiaomi/" target="_blank" rel="noopener">TWRP官网</a>或者小米论坛,下载你手机的第三方recovery(也叫第三方re)镜像(文件后缀名是.img).</p>
<p>这里要解释一下什么是第三方recovery.</p>
<p>recovery的作用是给手机恢复出厂设置,更新系统,备份系统的,但是由于官方recovery功能太少,限制太多,所以我们要刷入第三方的recovery,而<a href="https://zh.wikipedia.org/wiki/TWRP" target="_blank" rel="noopener">twrp</a>就是一个开源的,成熟的第三方re.</p>
<p>注意:如果你是在小米论坛下载的第三方re,那他们一般会顺便提供一个叫”<strong>电脑端一键刷入recovery.bat</strong>“的文件,此时你只要手机进入fastboot界面,连接电脑,双击该文件,然后按照指示下一步就行了,不需要下面345步.</p>
</li>
<li><p>点击下载<a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip" target="_blank" rel="noopener">fastboot工具</a>,解压到某个文件夹中,将刚刚下载的img文件也放到该文件夹.</p>
</li>
<li><p>电脑按住shift键,鼠标在该文件夹右键,打开powershell.</p>
</li>
<li><p>输入以下命令:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\fastboot.exe flash recovery twrp<span class="literal">-3</span>.<span class="number">2.3</span><span class="literal">-0</span><span class="literal">-gemini</span>.img (最后一个文件填你刚刚下载的文件的名称)</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\fastboot.exe boot twrp<span class="literal">-3</span>.<span class="number">2.3</span><span class="literal">-0</span><span class="literal">-gemini</span>.img (最后一个文件填你刚刚下载的文件的名称)</span><br></pre></td></tr></table></figure>

<p>手机就已经成功刷入第三方re,并且会重新启动进入第三方re界面.</p>
<p>刷入了第三方re之后,关机状态下按住<strong>音量上键+电源键</strong>即可再次进入,以后卡刷就都在第三方re里面刷了,不需要电脑.</p>
</li>
<li><p>这时你的手机进入了第三方re界面,应该是长这样的:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/TWRP_2.7.0.0.png/360px-TWRP_2.7.0.0.png" alt=""></p>
<p>点击Settings进入设置,点击最右边的一项设置语言,找到中文(Chinese),点击设置,即可设置成中文.</p>
</li>
<li><p>再返回到主页,点击<strong>清除</strong>,滑动按钮恢复出厂设置</p>
<p>注意,这里的恢复出厂设置,和在fastboot里线刷删除所有数据不一样,<strong>这里的恢复出厂设置,不会删除你手机上存储文件</strong>.</p>
</li>
<li><p>再返回到主页,将手机连接到电脑,将刚刚下载的刷机包复制到手机上(如果你是用手机下载的刷机包,那就不需要复制了).</p>
<p>点击<strong>安装</strong>,选择刚刚的刷机包,开始刷机.</p>
<p>刷机完成之后点击重启,即可刷机成功.</p>
<hr>
<h2 id="可选-刷入magisk获得root权限"><a href="#可选-刷入magisk获得root权限" class="headerlink" title="(可选)刷入magisk获得root权限"></a>(可选)刷入magisk获得root权限</h2><p>经过刚刚的步骤,刷机就已经完成了,如果想要进一步体验强大的<a href="https://sspai.com/post/53043" target="_blank" rel="noopener">magisk</a>,可以继续以下步骤,非常简单.</p>
<ol>
<li><p>进入<a href="https://github.com/topjohnwu/Magisk/releases" target="_blank" rel="noopener">magisk下载页面</a>,分别下载下载最新的magisk和magisk manager.</p>
<p>这里要解释一下,magisk分成两部分,一部分是magisk本身,另一部分是magisk manager这个管理magisk的app,刷入了magisk之后,手机再安装这个app就可以正常安装模块了.</p>
</li>
<li><p>关机状态下,音量上键+开机键,进入第三方re,不需要清除数据,<strong>直接点击安装</strong>,选择刚刚下载的magisk文件.</p>
</li>
<li><p>重启之后,安装magisk manager这个app,就可以正常使用,并且手机现在已经有了root权限了.<img src="https://i.loli.net/2019/03/20/5c91e7e69e316.png" alt=""></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是刷机的全部步骤了,总的来说,只要按照步骤来基本都不会失败,而且哪怕是失败了,手机也不会轻易坏掉的,只要能进入fastboot界面,总是能救回来的,但是要注意,<strong>一定一定要记得备份自己的资料,资料没了就真的没了</strong>.<img src="https://i.loli.net/2019/03/21/5c93791231408.jpg" alt=""></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>备忘</tag>
        <tag>刷机</tag>
        <tag>小米</tag>
      </tags>
  </entry>
  <entry>
    <title>下载vs2017离线安装包</title>
    <url>/2019/03/19/%E4%B8%8B%E8%BD%BDvs2017%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85/</url>
    <content><![CDATA[<ol>
<li><p>前往微软<a href="https://visualstudio.microsoft.com/zh-hans/downloads/" target="_blank" rel="noopener">VisualStudio官网</a>下载vs2017在线安装器,下载完成后的文件名字应该是类似这样的:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">vs_community__1377279628</span><span class="selector-class">.1540623861</span><span class="selector-class">.exe</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将该exe文件复制到准备要下载离线安装包的目录,例如D:\vs2017.</p>
</li>
<li><p>按住shift键,鼠标在当前文件夹下右键点击在此处打开powershell.</p>
</li>
<li><p>输入:</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="string">.</span><span class="comment">\vs_community__1377279628</span><span class="string">.</span><span class="comment">1540623861</span><span class="string">.</span><span class="comment">exe</span> --<span class="comment">layout</span> <span class="comment">D:\vs2017</span> --<span class="comment">lang</span> <span class="comment">zh</span><span class="literal">-</span><span class="comment">CN</span></span><br></pre></td></tr></table></figure>

<p>即可开始下载,大小应该是20G起步,所以注意网络环境,而且下载时最好科学上网,不然某些组件会下载失败.</p>
</li>
<li><p>下载完成后,双击运行下载目录下的vs_community.exe即可进入安装界面开始安装.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>备忘</tag>
        <tag>VisualStudio2017</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统后如何恢复使用scoop</title>
    <url>/2019/03/19/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E4%BD%BF%E7%94%A8scoop/</url>
    <content><![CDATA[<p>重装系统之后,如果把原有的scoop文件夹粘贴回去user文件夹,然后在powershell中再次输入<a href="https://jiayaoo3o.github.io/2019/01/30/windows%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8-scoop/">windows下的软件管理神器:scoop</a>文章中的安装命令,会得到一个<strong>Scoop is already installed</strong>错误,要想正确恢复scoop,根据<a href="https://github.com/lukesampson/scoop/issues/2894" target="_blank" rel="noopener">官方回答</a>,请按照以下步骤:</p>
<a id="more"></a>

<ol>
<li><p>重装系统之前,先完整复制用户目录下的scoop文件夹到别的地方</p>
</li>
<li><p>重装系统之后,将scoop文件夹粘贴回去用户目录</p>
</li>
<li><p>在环境变量设置中,新建一个用户变量,名字为scoop,值为当前scoop文件夹的地址,即:</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\x</span>xxx<span class="symbol">\s</span>coop</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许脚本执行:</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set-executionpolicy</span> <span class="string">remotesigned </span>-s <span class="string">currentuser</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>双击用户变量中的path,新建一个路径,填入scoop文件夹下的shims文件夹的地址,即:</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\x</span>xxx<span class="symbol">\s</span>coop<span class="symbol">\s</span>hims</span><br></pre></td></tr></table></figure>
</li>
<li><p>powershell中运行:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scoop reset *</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>即可恢复所有软件的正常使用.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>scoop</tag>
      </tags>
  </entry>
  <entry>
    <title>突破微软远程桌面帧率限制</title>
    <url>/2019/03/19/%E7%AA%81%E7%A0%B4%E5%BE%AE%E8%BD%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%B8%A7%E7%8E%87%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>根据微软的<a href="https://support.microsoft.com/zh-cn/help/2885213/frame-rate-is-limited-to-30-fps-in-windows-8-and-windows-server-2012-r" target="_blank" rel="noopener">这一篇文章</a>所说,想要更改远程桌面帧率限制,可以采取以下步骤:</p>
<ol>
<li><p>win+R键打开运行窗口,输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">regedit</span></span><br></pre></td></tr></table></figure>

<p>进入注册表编辑器</p>
<a id="more"></a>
</li>
<li><p>找到并且单击以下的注册表子项:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="string">\</span></span><br><span class="line">SYSTEM<span class="string">\</span></span><br><span class="line">CurrentControlSet<span class="string">\</span></span><br><span class="line">Control<span class="string">\</span></span><br><span class="line">Terminal Server<span class="string">\</span></span><br><span class="line">WinStations</span><br></pre></td></tr></table></figure>
</li>
<li><p>右键,点击新建,选择<strong>DWORD(32-bit)</strong>,输入文件名:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">DWMFRAMEINTERVAL</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/03/19/5c90b478429f4.png" alt=""></p>
</li>
<li><p>右键该文件选择修改,点击<strong>十进制</strong>,在<strong>数值数据</strong>中输入<strong>15</strong>,点击确定<img src="https://i.loli.net/2019/03/19/5c90b5c463d20.png" alt=""></p>
</li>
<li><p>注意,修改完成后只是理论上能到达60fps,实际上能不能到达该帧率由多方面因素决定,尤其是网络延迟,建议在千兆局域网内进行测试.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>如何下载绝对纯净的Windows10镜像</title>
    <url>/2019/03/11/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E7%BB%9D%E5%AF%B9%E7%BA%AF%E5%87%80%E7%9A%84Windows10%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="1-在微软官网下载windows10镜像"><a href="#1-在微软官网下载windows10镜像" class="headerlink" title="1. 在微软官网下载windows10镜像"></a>1. 在微软官网下载windows10镜像</h1><p>很多人要下载一个windows10镜像时,都会尝试去<a href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank" rel="noopener">微软的官网</a>,但是微软的官网是不直接提供下载镜像的途径的,因为当你使用windows系统下的浏览器去访问微软官网时,微软检测到你正在使用windows,并不提供下载镜像而是倾向于让你下载一个升级工具,让你用升级工具去升级系统:</p>
<p><img src="https://i.loli.net/2019/03/11/5c867a7439291.png" alt=""></p>
<a id="more"></a>

<p>这个时候只要将浏览器模拟成非windows系统,就可以直接得到下载地址了:</p>
<ol>
<li><p>chrome键盘按F12,进入开发者模式</p>
</li>
<li><p>按照如图的步骤,进行操作</p>
<p><img src="https://i.loli.net/2019/03/11/5c867d03951f9.png" alt=""></p>
</li>
<li><p>刷新网页</p>
<p>此时可以看到,网页已经发生改变,可以选择下载的版本了</p>
<p><img src="https://i.loli.net/2019/03/11/5c867db499a30.png" alt=""></p>
<p>这个方法的优点是,下载的镜像绝对100%是纯净,安全,可靠的,不可能出现任何问题,但是缺点是,下载速度不一定能保证.</p>
<h1 id="2-在-MSDN-I-tell-you-下载"><a href="#2-在-MSDN-I-tell-you-下载" class="headerlink" title="2. 在 MSDN I tell you 下载"></a>2. 在 MSDN I tell you 下载</h1><p><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN I tell you</a>是一个广为人知的运营了多年的windows资源下载网站,该网站致力于提供纯净,安全的镜像给大家免费下载.</p>
<p>进入网站之后,找到自己需要的系统镜像,复制下载链接,打开下载工具即可下载.</p>
<p>这个站唯一的缺点就是只提供ed2k下载链接,必须要使用下载工具而没法直接用浏览器下载.</p>
<p><img src="https://i.loli.net/2019/03/11/5c867f4e237f2.png" alt=""></p>
<h1 id="3-使用Techbench-下载"><a href="#3-使用Techbench-下载" class="headerlink" title="3. 使用Techbench 下载"></a>3. 使用Techbench 下载</h1><p><a href="https://tb.rg-adguard.net/public.php?lang=zh-CN" target="_blank" rel="noopener">Techbench</a>不仅能提供纯净的windows镜像,还能顺便下载Office和其他微软家的工具,</p>
<p>进入网站,选择想要下载的系统镜像参数,即可下载纯净的系统镜像.</p>
<p><img src="https://i.loli.net/2019/03/11/5c8680b4b72b4.png" alt=""></p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10开启ssh服务器功能</title>
    <url>/2019/03/04/Windows10%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="为什么要用ssh连接windows10"><a href="#为什么要用ssh连接windows10" class="headerlink" title="为什么要用ssh连接windows10"></a>为什么要用ssh连接windows10</h1><p>一般来说,想要远程连接并且使用windows10的命令行有两种方法:</p>
<ol>
<li>使用微软自带的远程桌面(RDP)或者其他第三方远程桌面控制软件(teamviewer等)远程控制windows10,然后在软件控制界面使用命令行.</li>
<li>使用ssh连接到Windows10,然后使用命令行.</li>
</ol>
<p>而如果电脑没有公网ip,可以参考上一篇文章 <a href="https://jiayaoo3o.github.io/2019/03/01/Sakura-Frp-%E5%85%8D%E8%B4%B9%E7%9A%84%E9%AB%98%E9%80%9F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/">Sakura frp–免费的高速内网穿透工具</a>进行内网穿透,从而在外网访问本地电脑.</p>
<a id="more"></a>

<h1 id="使用PowerShell安装OpenSSH"><a href="#使用PowerShell安装OpenSSH" class="headerlink" title="使用PowerShell安装OpenSSH"></a>使用PowerShell安装OpenSSH</h1><p>要使用PowerShell安装OpenSSH前，请首先以管理员身份启动PowerShell.</p>
<ol>
<li><p>在powershell中输入:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-WindowsCapability</span> <span class="literal">-Online</span> | ? Name <span class="operator">-like</span> <span class="string">'OpenSSH*'</span></span><br></pre></td></tr></table></figure>

<p>此时powershell应该会显示可返回的结果:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Name  : OpenSSH.Client~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br><span class="line">State : NotPresent</span><br><span class="line">Name  : OpenSSH.Server~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br><span class="line">State : NotPresent</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别输入以下命令安装ssh客户端与ssh服务器端:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Add-WindowsCapability</span> <span class="literal">-Online</span> <span class="literal">-Name</span> OpenSSH.Client~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Add-WindowsCapability</span> <span class="literal">-Online</span> <span class="literal">-Name</span> OpenSSH.Server~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<p>此时powershell会显示如下返回结果:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Path          :</span><br><span class="line">Online        : True</span><br><span class="line">RestartNeeded : False</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="使用powershell卸载openssh"><a href="#使用powershell卸载openssh" class="headerlink" title="使用powershell卸载openssh"></a>使用powershell卸载openssh</h1><p>输入以下两条命令即可卸载刚刚安装的ssh客户端与ssh服务器:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Remove-WindowsCapability</span> <span class="literal">-Online</span> <span class="literal">-Name</span> OpenSSH.Client~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br><span class="line"><span class="built_in">Remove-WindowsCapability</span> <span class="literal">-Online</span> <span class="literal">-Name</span> OpenSSH.Server~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<h1 id="初始化ssh服务器"><a href="#初始化ssh服务器" class="headerlink" title="初始化ssh服务器"></a>初始化ssh服务器</h1><p>仍然以管理员身份启动powershell,输入以下命令:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Start-Service</span> sshd</span><br><span class="line"><span class="comment"># 以下命令可选,但是建议启用:</span></span><br><span class="line"><span class="built_in">Set-Service</span> <span class="literal">-Name</span> sshd <span class="literal">-StartupType</span> <span class="string">'Automatic'</span></span><br><span class="line"><span class="built_in">Get-NetFirewallRule</span> <span class="literal">-Name</span> *ssh*</span><br></pre></td></tr></table></figure>

<p>初始化完成后,电脑上就已经启用了ssh服务器了,其他电脑或者手机设备输入以下命令:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">ssh -p 服务器端口 远程ssh服务器用户名<span class="meta">@远程ssh服务器IP</span></span><br></pre></td></tr></table></figure>

<p>就能用ssh连上该设备了,如果在外网则需要内网穿透之后才能连上.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Sakura frp--免费的高速内网穿透工具</title>
    <url>/2019/03/01/Sakura-Frp-%E5%85%8D%E8%B4%B9%E7%9A%84%E9%AB%98%E9%80%9F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="什么是Sakurafrp"><a href="#什么是Sakurafrp" class="headerlink" title="什么是Sakurafrp?"></a>什么是Sakurafrp?</h1><p><a href="https://www.natfrp.org" target="_blank" rel="noopener">Skaura frp</a>是一款免费的,基于 <a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a> 封装的可用于内网穿透的高性能的反向代理应用,通过frp,没有公网ip的用户也能够远程访问自己的电脑.</p>
<a id="more"></a>

<h1 id="Sakurafrp的优点"><a href="#Sakurafrp的优点" class="headerlink" title="Sakurafrp的优点"></a>Sakurafrp的优点</h1><p>相对于传统的frp,Sakura frp有以下优点:</p>
<ol>
<li>最大的优点,Sakura frp免费提供了frp服务器给广大用户,使得用户不需要自己购买,维护公网服务器便能享受frp带来的便捷.</li>
<li>Sakura frp在传统的frp程序上进行封装,不需要用户配置frp客户端,只要输入用户名和密码,选择适合自己的服务器即可,做到快捷上手,简单易用,门槛降低.</li>
</ol>
<h1 id="使用Sakurafrp进行远程桌面控制"><a href="#使用Sakurafrp进行远程桌面控制" class="headerlink" title="使用Sakurafrp进行远程桌面控制"></a>使用Sakurafrp进行远程桌面控制</h1><p>既然frp主打的功能是内网穿透,在这里就用windows的远程桌面来展示如何使用Sakura frp.</p>
<h2 id="1-注册并登录Sakurafrp"><a href="#1-注册并登录Sakurafrp" class="headerlink" title="1.注册并登录Sakurafrp"></a>1.注册并登录Sakurafrp</h2><p>首先先在<a href="https://www.natfrp.org" target="_blank" rel="noopener">Sakurafrp</a>官网注册账号并登录</p>
<p><img src="https://i.loli.net/2019/03/01/5c7951fdd3276.png" alt=""></p>
<h2 id="2-创建内网穿透映射"><a href="#2-创建内网穿透映射" class="headerlink" title="2.创建内网穿透映射"></a>2.创建内网穿透映射</h2><p>登录之后,选择左边的映射列表,创建一个新的映射</p>
<p><img src="https://i.loli.net/2019/03/01/5c795275e01ad.png" alt=""></p>
<p>这里可以看到,Sakurafrp 已经内置了几种常用的内网穿透映射,这里点击远程桌面,注意远程端口要自己填一个数字,但是这个数字不能跟其他用户已经选择的数字冲突,所以可能要多试几个端口,直到成功为止.</p>
<h2 id="3-下载Sakurafrp客户端"><a href="#3-下载Sakurafrp客户端" class="headerlink" title="3.下载Sakurafrp客户端"></a>3.下载Sakurafrp客户端</h2><p>创建成功之后,点击左侧的客户软件选择适合自己的客户端进行<a href="https://s1.tcotp.cn/cdn/SakurafrpClient-2.3/Sakura_frpc_windows_amd64.exe" target="_blank" rel="noopener">下载</a>,如果没有需求不需要下载图形版本.</p>
<p><img src="https://i.loli.net/2019/03/01/5c79537c0ba50.png" alt=""></p>
<h2 id="4-运行Sakurafrp客户端"><a href="#4-运行Sakurafrp客户端" class="headerlink" title="4.运行Sakurafrp客户端"></a>4.运行Sakurafrp客户端</h2><p>运行Sakurafrp客户端的方法有3种:</p>
<ol>
<li>直接双击下载的Sakurafrp,输入账号和密码,再输入服务器ID,选择合适自己的服务器</li>
</ol>
<p><img src="https://i.loli.net/2019/03/01/5c79555656732.png" alt=""></p>
<p>就已经内网穿透成功了,其他电脑打开微软远程桌面,或者手机安装微软远程桌面app,电脑ip地址位置输入</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">所选服务器地址:远程端口号</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/03/02/5c795d2a2f194.png" alt=""></p>
<p>例如你选了台湾百兆服务器,远程端口是10010,则输入:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">s21</span><span class="selector-class">.natfrp</span><span class="selector-class">.org</span><span class="selector-pseudo">:10010</span></span><br></pre></td></tr></table></figure>

<p>账号密码则输入运行了Sakurafrp的,被控制的电脑的账号与密码,点击连接,手机或者其他电脑就可以远程控制这台电脑了.</p>
<p>这个方法适合临时使用Sakurafrp进行内网穿透,关闭软件窗口即断开连接服务器.</p>
<ol start="2">
<li><p>在powershell等终端软件中打开Sakurafrp,这种方法可以免去每次手动输入账户名,密码,服务器ID.只要在Sakurafrp客户端所在的文件夹中,按住Shift键,选择打开powershell,然后在powershell中输入:</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./Sakura_frpc_windows_amd64.exe</span> <span class="params">--su=</span><span class="string">"你的用户名"</span> <span class="params">--sp=</span><span class="string">"你的密码"</span> <span class="params">--sid=</span><span class="string">"服务器ID"</span></span><br></pre></td></tr></table></figure>

<p>即可自动登录并且选择服务器.</p>
</li>
<li><p>开机自启动Sakurafrp.虽然上面两种方法可以使用,但是会在任务栏上显示出来,而且软件不能关闭,只要关闭就会断掉,所以第三种方法是将Sakurafrp放在后台,自动开机启动.</p>
<p>首先在Sakurafrp所在的文件夹新建一个文本文件,命名为:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Sakura_frpc</span>.</span></span>bat</span><br></pre></td></tr></table></figure>

<p>右键该文件,选择编辑,输入:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Sakura_frpc_windows_amd64.exe -<span class="literal">-su</span>=<span class="string">"你的用户名"</span> -<span class="literal">-sp</span>=<span class="string">"你的密码"</span> -<span class="literal">-sid</span>=<span class="string">"服务器ID"</span></span><br></pre></td></tr></table></figure>

<p>并且保存.</p>
<p>再在Sakurafrp所在的文件夹新建一个文本文件,命名为:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Sakura_frpc</span>.</span></span>vbs</span><br></pre></td></tr></table></figure>
<p>右键该文件,选择编辑,输入:</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> ws=WScript.<span class="built_in">CreateObject</span>(<span class="string">"WScript.Shell"</span>) </span><br><span class="line">ws.Run <span class="string">"Sakura_frpc.bat /start"</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>并且保存.</p>
<p>这时,我们只要双击这个Sakura_frpc.vbs,软件就会在后台启动了,在任务栏是看不到的,但是在任务管理器中能够看到.</p>
<p>此时,我们右键Sakura_frpc.vbs,选择创建快捷方式</p>
<p>然后键盘Win+R键,输入</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="bash">:startup</span></span><br></pre></td></tr></table></figure>

<p>打开开机启动文件夹,把快捷方式放进去.</p>
<p>Sakurafrp就已经能够开机启动了.</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Sakurafrp是我昨天晚上无意中发现的一个项目,本来我用frp做内网穿透是用自己的腾讯云1M小水管用作公网服务器的,但是没想到Sakurafrp竟然这么良心,免费提供8M的服务器给别人使用,所以我觉得得写一个教程来感恩一下,感谢Sakurafrp,💉 💧 🐮 🍺</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下的软件管理神器:scoop</title>
    <url>/2019/01/30/windows%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8-scoop/</url>
    <content><![CDATA[<h1 id="scoop是什么"><a href="#scoop是什么" class="headerlink" title="scoop是什么"></a>scoop是什么</h1><p><a href="https://scoop.sh/" target="_blank" rel="noopener">Scoop</a>是一款windows下的命令行软件管理工具,类似于ubuntu下的apt,它存在的意义,就是为了解决Windows下没有一个统一包管理器的痛点,有了scoop,在windows下也能一条命令直接安装,升级,卸载,切换软件的不同版本等</p>
<a id="more"></a>

<hr>
<h1 id="安装scoop"><a href="#安装scoop" class="headerlink" title="安装scoop"></a>安装scoop</h1><p>scoop的使用与安装都要依赖PowerShell,所以电脑系统最好是windows10的.安装方法很简单,以下命令都在PowerShell中输入:</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set-executionpolicy</span> <span class="string">remotesigned </span>-s <span class="string">currentuser</span></span><br></pre></td></tr></table></figure>

<p>会提示是否允许执行远程脚本,输入a同意全部.</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">iex (<span class="built_in">new-object</span> net.webclient).downloadstring(<span class="string">'https://get.scoop.sh'</span>)</span><br></pre></td></tr></table></figure>

<p>运行上面这条命令,scoop就会安装在你的C:\Users\ 用户名\scoop目录中,这时候在PowerShell中输入</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scoop help</span><br></pre></td></tr></table></figure>

<p>就会显示出scoop的基本操作命令</p>
<p><img src="https://i.loli.net/2019/01/31/5c528038a674b.png" alt=""></p>
<hr>
<h1 id="使用scoop"><a href="#使用scoop" class="headerlink" title="使用scoop"></a>使用scoop</h1><p>scoop的用法与一般的Linux软件类似,都是</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span>操作 对象软件</span><br></pre></td></tr></table></figure>

<h2 id="查找软件"><a href="#查找软件" class="headerlink" title="查找软件"></a>查找软件</h2><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">scoop <span class="built_in">search</span> 软件名</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">scoop <span class="built_in">search</span> <span class="keyword">vim</span></span><br></pre></td></tr></table></figure>

<p>如果后面不跟软件名,直接输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scoop search</span></span><br></pre></td></tr></table></figure>

<p>那scoop会直接显示仓库目前有的所有软件,可以一个一个慢慢看</p>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>软件名</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>vim</span><br><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>python</span><br><span class="line"><span class="keyword">scoop </span><span class="keyword">install </span>nodejs</span><br></pre></td></tr></table></figure>

<p>即可安装vim</p>
<h2 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span>uninstall 软件名</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scoop uninstall vim</span></span><br></pre></td></tr></table></figure>

<h2 id="升级软件"><a href="#升级软件" class="headerlink" title="升级软件"></a>升级软件</h2><p>如果想要查看今天仓库更新了哪些软件,输入:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scoop update</span></span><br></pre></td></tr></table></figure>

<p>就会显示所有今天升级更新的软件</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span>update 软件名</span><br></pre></td></tr></table></figure>

<p>即可更新对应软件</p>
<p>如果想要直接升级所有软件,输入:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span>update *</span><br></pre></td></tr></table></figure>

<p>即可升级所有软件</p>
<h2 id="检查软件状态"><a href="#检查软件状态" class="headerlink" title="检查软件状态"></a>检查软件状态</h2><p>如果想要知道自己有哪些软件可以升级,输入:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scoop status</span></span><br></pre></td></tr></table></figure>

<p>如果想要查看scoop是否出现了问题,输入:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scoop checkup</span></span><br></pre></td></tr></table></figure>

<h2 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h2><p>每当scoop下载了软件之后,再卸载这个软件,当初下载的这个软件包文件还会存在,所以下一次安装就不用再下载了,想要清理缓存,可以输入:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">cache </span>rm 软件名</span><br></pre></td></tr></table></figure>

<p>想要清除所有缓存,可以输入:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">cache </span>rm *</span><br></pre></td></tr></table></figure>

<h2 id="删除软件旧版本"><a href="#删除软件旧版本" class="headerlink" title="删除软件旧版本"></a>删除软件旧版本</h2><p>每当scoop升级了软件之后,旧版本仍会保留在电脑上,以便于切换到旧版本,想要删除软件旧版本,输入</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">scoop <span class="keyword">cleanup</span> 软件名</span><br></pre></td></tr></table></figure>

<p>想要删除所有软件的所有旧版本,输入</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">scoop <span class="keyword">cleanup</span> *</span><br></pre></td></tr></table></figure>

<h2 id="查看软件主页"><a href="#查看软件主页" class="headerlink" title="查看软件主页"></a>查看软件主页</h2><p>如果你想了解仓库中的某一个软件,输入</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">scoop <span class="built_in">home</span> 软件名</span><br></pre></td></tr></table></figure>

<p>即可打开软件的主页</p>
<h2 id="切换软件版本"><a href="#切换软件版本" class="headerlink" title="切换软件版本"></a>切换软件版本</h2><p>如果同时安装了某个软件的不同大版本,例如python(默认的python是python3)和python27,或者同时安装了java8和java11,可以通过:</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">scoop <span class="built_in">reset</span> 想要使用的版本名称</span><br></pre></td></tr></table></figure>

<p>进行切换</p>
<hr>
<h1 id="添加额外的仓库bucket"><a href="#添加额外的仓库bucket" class="headerlink" title="添加额外的仓库bucket"></a>添加额外的仓库bucket</h1><p>scoop中的仓库被叫做bucket,安装好的scoop默认会带有一个主仓库,名字就叫Scoop,主仓库里面的软件,有很多,但是基本都是比较适合程序员的软件,更重要的一点是,要入选主仓库的软件,都是没有GUI的,也就是说都是命令行软件,而scoop官方还有一个第三方bucket,里面有更多的常用软件,所以我们要添加额外的仓库</p>
<h2 id="查看可添加仓库"><a href="#查看可添加仓库" class="headerlink" title="查看可添加仓库"></a>查看可添加仓库</h2><p>想要查看可添加仓库,输入:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">bucket </span>known</span><br></pre></td></tr></table></figure>

<p>即可显示仓库列表</p>
<p><img src="https://i.loli.net/2019/01/31/5c529f03b26cc.png" alt=""></p>
<p>一般来说,比较有用的仓库如下,要添加仓库,输入:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">bucket </span><span class="keyword">add </span><span class="keyword">extras</span></span><br><span class="line"><span class="keyword">scoop </span><span class="keyword">bucket </span><span class="keyword">add </span><span class="keyword">java</span></span><br><span class="line"><span class="keyword">scoop </span><span class="keyword">bucket </span><span class="keyword">add </span><span class="keyword">jetbrains</span></span><br></pre></td></tr></table></figure>

<p>添加了java库之后,就可以安装各个版本的jdk了,而且scoop会帮你自动设置好环境变量,真正做到了开箱即用,爽翻.</p>
<p>如果想要添加不在上述列表的非官方仓库的话,输入:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">bucket </span><span class="keyword">add </span>仓库名 仓库的github地址</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">scoop bucket <span class="keyword">add</span><span class="bash"> Ash258 <span class="string">'https://github.com/Ash258/scoop-Ash258.git'</span></span></span><br></pre></td></tr></table></figure>

<p>即可添加非官方仓库</p>
<h2 id="查看已经添加的仓库"><a href="#查看已经添加的仓库" class="headerlink" title="查看已经添加的仓库"></a>查看已经添加的仓库</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">bucket </span>list</span><br></pre></td></tr></table></figure>

<h2 id="删除已经添加的仓库"><a href="#删除已经添加的仓库" class="headerlink" title="删除已经添加的仓库"></a>删除已经添加的仓库</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">scoop </span><span class="keyword">bucket </span>rm 仓库名</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Scoop的本地文件目录"><a href="#Scoop的本地文件目录" class="headerlink" title="Scoop的本地文件目录"></a>Scoop的本地文件目录</h1><p>上面已经说了,scoop是安装在用户目录下的,目录格式为:</p>
<p><img src="https://i.loli.net/2019/01/31/5c52a47d6b568.png" alt=""></p>
<p>这里最值得称道的是persist文件夹,因为我们知道,scoop安装的所有软件都是安装在scoop文件夹下的,那如果软件升级了的话,以前旧软件的设置和数据是不是全部清除了呢?例如vscode上的设置和安装的插件,是不是升级了之后,都没有了呢?不是的,因为scoop会将各个软件的设置数据,例如vscode软件的data文件夹(vscode的设置和插件都放在data文件夹),单独放到persist文件夹中,在用软链接链接到软件所在的文件夹,这样,每次升级软件,persist文件夹的各个软件的设置数据都会保持不变,从而保存设置.</p>
<p>另一个需要注意的是,所有的对scoop操作都不要在文件夹中进行,因为有可能会破坏scoop的文件结构,想要对scoop进行任何操纵,都需要在命令行中进行</p>
<hr>
<h1 id="scoop的优缺点分析"><a href="#scoop的优缺点分析" class="headerlink" title="scoop的优缺点分析"></a>scoop的优缺点分析</h1><p>scoop作为一款windows下的包管理器,意义是非凡的,尤其是对于程序员而言,它极大地解决了程序员安装各种开发环境的麻烦,一键自动设置环境变量,包括:</p>
<ul>
<li>dotnet core</li>
<li>java</li>
<li>python</li>
<li>nodejs</li>
<li>go</li>
<li>kotlin</li>
<li>ruby</li>
</ul>
<p>各种软件,包括:</p>
<ul>
<li>idea</li>
<li>vscode</li>
<li>vim</li>
<li>git</li>
<li>pycharm</li>
<li>maven</li>
<li>make</li>
<li>gcc</li>
<li>gdb</li>
<li>mysql</li>
<li>gradle</li>
<li>android-sdk</li>
</ul>
<p>等,可以说,scoop真的是每一个程序员的必备神器</p>
<h2 id="scoop的优点"><a href="#scoop的优点" class="headerlink" title="scoop的优点"></a>scoop的优点</h2><ol>
<li>干净,不会污染系统,保持最高度清洁.scoop安装的所有软件都会放在用户目录的scoop文件夹下</li>
<li>简单,一句命令即可安装软件,开箱即用,不用再去各个软件的官网下载软件</li>
<li>省心,升级软件及时,软件数量多,解决问题快</li>
</ol>
<h2 id="scoop的缺点"><a href="#scoop的缺点" class="headerlink" title="scoop的缺点"></a>scoop的缺点</h2><p>虽然scoop这么强大,但是它还是有缺点的</p>
<ol>
<li>网络问题,因为scoop是外国人发明的,而且scoop里面的软件有一些也是外国软件,并且scoop的每一个软件下载地址都是软件的官网,所以有时候必须要科学上网才能下载,并且下载速度也不稳定,有一些软件很快,有一些软件却很慢</li>
<li>安装问题,scoop的安装会有一个问题,就是如果你安装某个软件失败了,再安装一次,这时候scoop会提示你软件已经安装过了,但是安装失败又用不了,所以这个时候要先执行一次scoop uninstall卸载刚刚失败的软件,再安装</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>scoop可以说是我2018年遇到的最好用,对我帮助最大的软件,我第一次用这个软件的时候,马上拿出信用卡进行捐赠了,希望你也能喜欢这一款神器,💉 💧 🐮 🍺</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>windows10</tag>
        <tag>包管理器</tag>
        <tag>scoop</tag>
      </tags>
  </entry>
  <entry>
    <title>广东海洋大学三种路由器上网方式</title>
    <url>/2019/01/28/%E5%B9%BF%E4%B8%9C%E6%B5%B7%E6%B4%8B%E5%A4%A7%E5%AD%A6%E4%B8%89%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>2019.2.30更新:从2019年学期开始,电信在服务端进行了调整,每次登录的存活期只有9个小时,也就是说,不管你用任何方法上网,9个小时之后都必须打开天翼app重新登录一次,以前的方法是登录一次用一天,现在是登录一次用9个小时,其他不变</strong>.</p>
<hr>
<h2 id="海大电信限制学生使用路由器的原因"><a href="#海大电信限制学生使用路由器的原因" class="headerlink" title="海大电信限制学生使用路由器的原因"></a>海大电信限制学生使用路由器的原因</h2><p>为了赚钱,其他任何理由都是扯淡. 所以电信选择限制学生使用路由器,每个账号只能登录一台手机和一台电脑,迫使大家每个人都开通一个账号.</p>
<h2 id="海大电信限制学生使用路由器的原理"><a href="#海大电信限制学生使用路由器的原理" class="headerlink" title="海大电信限制学生使用路由器的原理"></a>海大电信限制学生使用路由器的原理</h2><p>海大电信是通过验证学生登录设备的ip地址来确保单账号单设备登录的,一台手机或电脑在海大想要上网,会经过以下几个步骤:</p>
<a id="more"></a>

<ol>
<li>手机或电脑连接到已经<strong>关闭了DHCP</strong>的路由器</li>
<li>这台手机根据自己的<strong>mac地址</strong>,获得从海大电信分配的以<strong>10.8开头的ip地址</strong></li>
<li>手机打开天翼校园app,准备登录账号</li>
<li>天翼校园app<strong>检查手机的ip地址是否是以10.8开头</strong>的<strong>经由海大电信分配的合法ip地址</strong></li>
<li>点击登录,登录成功</li>
<li>手机可以持续上网,期间电信的服务器会持续检测该设备是否有数据传输,如果长时间没有数据传输,则判断为设备掉线,需要重新登录.</li>
</ol>
<p>可以看到,电信想要获取学生设备的ip地址分配权,第一步就是<strong>要求学生将自己的路由器关闭DHCP</strong>,只有关闭了路由器的DHCP,电信才能从上一级直接分配ip给每一台学生设备.</p>
<hr>
<h2 id="方法1-电信官方允许的使用路由器上网方式"><a href="#方法1-电信官方允许的使用路由器上网方式" class="headerlink" title="方法1:电信官方允许的使用路由器上网方式"></a>方法1:电信官方允许的使用路由器上网方式</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>基本不需要任何额外的操作,按照官方的指导,只需要一台路由器即可</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>只能进行<strong>单账号单客户</strong>端登录,<strong>即一个账号只能允许登录一台手机,一台电脑</strong>,所以基本全宿舍每人都需要一个账号</li>
<li>电脑需要安装<strong>极其恶心</strong>的天翼校园软件,并且要让该软件一直运行</li>
<li>如果掉线了需要再次重复登录</li>
<li>电脑客户端毛病极多,经常随机抽风</li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>手机或电脑连接已经通电的路由器,输入路由器管理界面的地址进入路由器管理界面(一般是192.168.1.1,不同的路由器一般地址不一样,可以查看路由器底部,一般会有)</li>
<li>关闭路由器的DHCP功能</li>
<li>将外网线(即学校提供的,连接到外部上网的网线)插入路由器的<a href="https://www.192ly.com/qiu-zhu/wan-lan-qb.html" target="_blank" rel="noopener">LAN口</a></li>
<li>手机连上该路由器,打开天翼校园app,即可登录上网</li>
</ol>
<hr>
<h2 id="方法2-单路由器的mac克隆上网方式"><a href="#方法2-单路由器的mac克隆上网方式" class="headerlink" title="方法2:单路由器的mac克隆上网方式"></a>方法2:单路由器的mac克隆上网方式</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>只需要一台路由器即可</li>
<li>每天只需一次登录(因为海大每晚断网),即可全天<strong>单账号,多设备</strong>登录,意味着全宿舍公用一个账号成为可能</li>
<li>因为路由器自身总是会有极小量数据与服务器传输,所以可以做到全天不掉线</li>
<li>该方法由于只需要手机登录账号,所以电脑并不需要安装天翼校园软件</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>由于只有一个路由器,所以操作步骤略微繁琐,需要一定动手能力</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>该方法是通过将路由器的mac地址克隆成登录手机的mac地址,从而欺骗电信服务器,让服务器将路由器误以为是手机设备,所以可以上网</p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>手机打开wifi高级设置,找到手机的<strong>mac地址</strong></li>
<li>电脑连接路由器,进入路由器管理界面,找到<strong>mac地址克隆设置</strong>,输入刚刚手机的mac地址,保存</li>
<li>关闭路由器的DHCP(此时请务必不要刷新网页,保持页面不要动,因为关闭了DHCP之后,电脑没有了ip地址,是无法直接连接到路由器管理界面的,但是没有关闭的旧路由器管理界面仍能进行操作,所以不能刷新页面,刷新了直接就进不去了)</li>
<li>外网线接入LAN口</li>
<li>手机连接路由器,打开天翼校园app进行登录</li>
<li>登录成功之后,电脑在网页端打开DHCP</li>
<li>将外网线从LAN口拔出,插入WAN口(此时已经登陆成功,并且由于手机和路由器mac地址相同,所以服务器会误以为路由器是手机)</li>
<li><strong>手机清除天翼校园app后台</strong>,关闭手机wifi再重新打开WiFi</li>
</ol>
<p>此时整个过程都已经完成,路由器已经能够正常上网了</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>可以看到,以上的步骤,除了输入mac地址那一步,<strong>其他的每一天都要操作一次</strong>,过程要用到电脑,还要拔网线,所以说稍微有点繁琐,并且如果你使用的是<a href="http://www.mercurycom.com.cn/" target="_blank" rel="noopener">水星mercury路由器</a>,步骤会更加麻烦,因为水星的辣鸡低端路由器自身固件原因,关闭了DHCP再打开之后,是不能够自动获取IP地址的,所以步骤会变成</p>
<ol>
<li><p>关闭路由器DHCP</p>
</li>
<li><p>外网线接入LAN口</p>
</li>
<li><p>手机连接路由器,打开天翼校园app进行登录</p>
</li>
<li><p>登录成功之后,电脑在网页端打开DHCP</p>
</li>
<li><p>查看手机的WiFi高级设置,看看手机现在的<strong>ip地址,子网掩码,网关(路由器)</strong>是什么</p>
</li>
<li><p>在路由器管理界面选择<strong>手动输入ip地址</strong>(有的路由器也叫静态ip),填入上方的三个数据</p>
</li>
<li><p>将外网线从LAN口拔出,插入WAN口</p>
</li>
<li><p>手机清除天翼校园app后台,关闭手机wifi再重新打开WiFi</p>
<p>可以看到,使用水星路由器会使得整个过程变得更加繁琐,所以建议不要使用水星路由器</p>
</li>
</ol>
<hr>
<h2 id="方法3-双路由器的mac克隆上网方式"><a href="#方法3-双路由器的mac克隆上网方式" class="headerlink" title="方法3:双路由器的mac克隆上网方式"></a>方法3:双路由器的mac克隆上网方式</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ol>
<li>操作步骤大大减少,简单快捷</li>
<li>参考单路由器方法</li>
</ol>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>需要两个路由器,这是最大的缺点了,如果你没有两个路由器,可能需要额外购买一个</li>
</ol>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>双路由器的本质原理和单路由器是一样的,但是单路由器上网方法之所以会繁琐,是因为在这些步骤中,有”关闭DHCP,打开DHCP”这一个操作,而只要使用两个路由器,就可以让一个路由器打开DHCP,另一个路由器DHCP关闭,这样就能减少很多个步骤了.</p>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><p>我们将两个路由器分别叫做<strong>1号路由器,2号路由器</strong></p>
<ol>
<li><strong>1号路由器</strong>关闭DHCP</li>
<li><strong>2号路由器</strong>找到mac克隆选项,输入手机的mac地址,保存</li>
<li>将外网线插入<strong>1号路由器</strong>的LAN口</li>
<li>找来一根短短的网线,将<strong>1号路由器的LAN口</strong>和<strong>2号路由器的WAN口</strong>连接,此时的路由器接线应该是下面那样的<br><img src="https://i.loli.net/2019/01/29/5c500a6ab700a.png" alt="路由器接线方式"></li>
<li>手机连上<strong>1号路由器</strong>的WiFi,登录天翼校园app</li>
<li>手机清除天翼校园app后台,并且连上<strong>2号路由器</strong>,此时<strong>2号路由器</strong>已经能够正常上网了.</li>
</ol>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>上面的步骤只是第一次设置的时候需要做的,以后每天上网只需要3步</p>
<ol>
<li>手机连接1号路由器</li>
<li>登录app</li>
<li>清除app后台,连接2号路由器正常上网</li>
</ol>
<p>上面的操作对路由器的品牌没有限制,<strong>但是水星路由器由于无法自动获取ip地址,所以不建议水星路由器充当2号路由器</strong>,而且如果两个路由器中一个性能很强,一个很垃圾,建议用垃圾路由器充当1号路由器,用性能强的作为2号路由器.</p>
<h2 id="mac克隆能成功的原理"><a href="#mac克隆能成功的原理" class="headerlink" title="mac克隆能成功的原理"></a>mac克隆能成功的原理</h2><p>可以观看下方的视频解释为什么可以用mac克隆方法对电信服务器进行欺骗</p>
<iframe src="//player.bilibili.com/player.html?aid=21369496&cid=35146763&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="480"> </iframe>


]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>路由器上网</tag>
        <tag>mac欺骗</tag>
        <tag>广东海洋大学</tag>
      </tags>
  </entry>
</search>
