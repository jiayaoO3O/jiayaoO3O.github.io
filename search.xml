<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.两数之和</title>
    <url>/2019/05/01/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>两重循环判断两数之和是否为目标值.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] TwoSum(int[] nums, int target)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; nums.Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] + nums[j] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                return new int[] &#123; i, j &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new int[] &#123; 0, 0 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>100.相同的树</title>
    <url>/2019/05/08/100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>在leetcode上对于树的题目的解法,都可以尝试往递归方面去思考,因为树的特点就是根节点的叶子节点,也可能会成为下一个叶子的根,用递归的思想来解决会比较方便.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsSameTree(TreeNode p, TreeNode q)</span><br><span class="line">&#123;</span><br><span class="line">    if (p == null &amp;&amp; q == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p == null &amp;&amp; q != null || p != null &amp;&amp; q == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p.val != q.val)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return IsSameTree(p.left, q.left) &amp;&amp; IsSameTree(p.right, q.right);//递归判断两棵树的左右叶子节点.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1001 A+B Format</title>
    <url>/2019/04/16/1001-A-B-Format/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Calculate <em>a</em>+<em>b</em> and output the sum in standard format -- that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where −10<sup>6</sup>≤<em>a</em>,<em>b</em>≤10<sup>6</sup>. The numbers are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1000000 9</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-999,991</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>把a和b两个数加起来,结果要用规定格式表示,规定格式是:从右往左数,每隔3位要加个逗号.</p>
<h2 id="思路">思路</h2>
<p>这道题如果直接从右往左硬撸会很不优雅,我一开始写的时候发现,怎么写都很啰嗦,结果在网上找到了<a href="https://www.liuchuo.net/archives/1888">这篇答案</a>,发现里面有个判断逗号的方法相当巧妙:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ((i + 1) % 3 == s.Length % 3 &amp;&amp; i != s.Length - 1)</span><br><span class="line">	&#123;</span><br><span class="line">     	Console.Write(&quot;,&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当我看到这个公式我就意识到我走错路了,不应该硬写,而是应该找其中的数学规律.</p>
<p>为什么当</p>
<blockquote>
<p>(i + 1) % 3 == s.Length % 3</p>
</blockquote>
<p>的时候,可以放一个逗号呢?</p>
<p>我们来尝试找一下规律:</p>
<ul>
<li>1,234,567 第<strong>1</strong>位,第<strong>4</strong>位后面加逗号,全长<strong>7</strong>位</li>
<li>12,234 第<strong>2</strong>位后面加逗号,全长<strong>5</strong>位</li>
<li>123,456 第<strong>3</strong>位后面加逗号,全长<strong>6</strong>位</li>
</ul>
<p>也就是说,除了第一个数的前面,和最后一个数的后面,我们从左往右数的第一个逗号应该在s.Length % 3这个位置,下一个逗号应该在这个位置往后走3位的位置,也就是说:</p>
<ul>
<li>第一个逗号:(i+1)==s.length%3</li>
<li>第二个逗号:(i+1)+3+3==s.length%3</li>
<li>第三个逗号:(i+1)+3+3+3==s.length%3</li>
<li>第n个逗号:(i+1)+3n==s.length%3</li>
</ul>
<p>这时候你会发现,加再多的3n结果再%3还是等于i+1,((i+1)+3n)%3==i+1,所以我们最后的公式就是:</p>
<blockquote>
<p>(i + 1) % 3 == s.Length % 3</p>
</blockquote>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            string[] input = Console.ReadLine().Split(&#x27; &#x27;);</span><br><span class="line">            int a = Convert.ToInt32(input[0]);</span><br><span class="line">            int b = Convert.ToInt32(input[1]);</span><br><span class="line">            string s = (a + b).ToString();</span><br><span class="line">            for (int i = 0; i &lt; s.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(s[i]);</span><br><span class="line">                if (s[i] == &#x27;-&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((i + 1) % 3 == s.Length % 3 &amp;&amp; i != s.Length - 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(&quot;,&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1002 A+B for Polynomials</title>
    <url>/2019/05/10/1002-A-B-for-Polynomials/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>This time, you are supposed to find <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p>
<p><em>K</em> <em>N1</em> <em>aN1</em> <em>N2</em> <em>aN2</em> ... <em>NK</em> <em>aNK</em></p>
<p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>Ni</em> and <em>aNi</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10，0≤<em>NK</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 2.4 0 3.2</span><br><span class="line">2 2 1.5 1 0.5</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2 1.5 1 2.9 0 3.2</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>计算两个多项式的和,注意这里每一个输入的多项式最多只会有10项,但是多项式最大的项能到第1000项.</p>
<h2 id="思路">思路</h2>
<p>用一个长度为1001的整型数组作为哈希表,下标表示第几项,值代表系数的值.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string[] A = Console.ReadLine().Split();</span><br><span class="line">    string[] B = Console.ReadLine().Split();</span><br><span class="line">    double[] polynomialInfo = new double[1001];//定义一个用于存放系数信息的哈希表.</span><br><span class="line">    for (int i = 1; i &lt; A.Length - 1; i = i + 2)</span><br><span class="line">    &#123;</span><br><span class="line">        polynomialInfo[int.Parse(A[i])] = double.Parse(A[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; B.Length - 1; i += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        polynomialInfo[int.Parse(B[i])] += double.Parse(B[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    string result = &quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; polynomialInfo.Length; i++)//这里的循环1000个位置只有最多10个是有用的,但是没有必要进行优化,因为我试了,时间都差不多.</span><br><span class="line">    &#123;</span><br><span class="line">        if (polynomialInfo[i] != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            result = &quot; &quot; + i + &quot; &quot; + polynomialInfo[i].ToString(&quot;0.0&quot;) + result;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Write(count + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1005 Spell It Right</title>
    <url>/2019/04/16/1005-Spell-It-Right/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Given a non-negative integer <em>N</em>, your task is to compute the sum of all the digits of <em>N</em>, and output every digit of the sum in English.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case occupies one line which contains an <em>N</em> (≤10100).</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12345</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one five</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给你一串数字,把各个位加起来,得到的结果,每一位用英文单词表达出来.</p>
<h2 id="思路">思路</h2>
<p>这道题比较简单,就是让你每一位求和,得到的结果再每一位去和英文单词匹配一下,这里要说一下,可以用两个方法去匹配单词,一可以直接用字符串数组,二可以用字典,但是我不知道用字典会慢多少.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    //int n = Convert.ToInt32(System.Console.ReadLine());</span><br><span class="line">    string s = Console.ReadLine();</span><br><span class="line">    int sum = 0;</span><br><span class="line">    foreach (var num in s)</span><br><span class="line">    &#123;</span><br><span class="line">		sum += System.Convert.ToInt32(num) - &#x27;0&#x27;;</span><br><span class="line">		//这里要注意不能直接用char转换成int,要减去48.</span><br><span class="line">    &#125;</span><br><span class="line">    //可以用字典,也可以用数组.</span><br><span class="line">    // Dictionary&lt;char, string&gt; dict = new Dictionary&lt;char, string&gt;();</span><br><span class="line">    // dict.Add(&#x27;0&#x27;, &quot;zero&quot;);</span><br><span class="line">    // dict.Add(&#x27;1&#x27;, &quot;one&quot;);</span><br><span class="line">    // dict.Add(&#x27;2&#x27;, &quot;two&quot;);</span><br><span class="line">    // dict.Add(&#x27;3&#x27;, &quot;three&quot;);</span><br><span class="line">    // dict.Add(&#x27;4&#x27;, &quot;four&quot;);</span><br><span class="line">    // dict.Add(&#x27;5&#x27;, &quot;five&quot;);</span><br><span class="line">    // dict.Add(&#x27;6&#x27;, &quot;six&quot;);</span><br><span class="line">    // dict.Add(&#x27;7&#x27;, &quot;seven&quot;);</span><br><span class="line">    // dict.Add(&#x27;8&#x27;, &quot;eight&quot;);</span><br><span class="line">    // dict.Add(&#x27;9&#x27;, &quot;nine&quot;);</span><br><span class="line">    string[] dict = &#123; &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot; &#125;;</span><br><span class="line">    s = sum.ToString();</span><br><span class="line">    for (int i = 0; i &lt; s.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		Console.Write(dict[s[i] - &#x27;0&#x27;]);//直接读取s[i]也是char,也要减去48.</span><br><span class="line">        if (i != s.Length - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1006 Sign In and Sign Out</title>
    <url>/2019/05/28/1006-Sign-In-and-Sign-Out/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer <em>M</em>, which is the total number of records, followed by <em>M</em> lines, each in the format:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID_number Sign_in_time Sign_out_time</span><br></pre></td></tr></table></figure>
<p>where times are given in the format <code>HH:MM:SS</code>, and <code>ID_number</code> is a string with no more than 15 characters.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p>
<p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">CS301111 15:30:28 17:00:10</span><br><span class="line">SC3021234 08:00:00 11:25:25</span><br><span class="line">CS301133 21:45:00 21:58:40</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SC3021234 CS301133</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定一些签到信息,你要找出谁是最早来负责开门的人和谁是最晚来负责关门的人.</p>
<h2 id="思路">思路</h2>
<p>这道题的重点是如何简单快捷地判断给定的时间大小,这里用C#的DateTime类型会非常简单,只要将两个时间字符串转换成DateTime型就可以比较大小了.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int count = int.Parse(Console.ReadLine());</span><br><span class="line">    string[] recordsID = new string[count];</span><br><span class="line">    string[] signInRecords = new string[count];</span><br><span class="line">    string[] signOutRecords = new string[count];</span><br><span class="line">    int firstPerson = 0;</span><br><span class="line">    int lastPerson = 0;</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string recode = Console.ReadLine();</span><br><span class="line">        recordsID[i] = recode.Split()[0];</span><br><span class="line">        signInRecords[i] = recode.Split()[1];</span><br><span class="line">        signOutRecords[i] = recode.Split()[2];</span><br><span class="line">        if (DateTime.Parse(signInRecords[i]) &lt; DateTime.Parse(signInRecords[firstPerson]))</span><br><span class="line">        &#123;</span><br><span class="line">            firstPerson = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if (DateTime.Parse(signOutRecords[i]) &gt; DateTime.Parse(signOutRecords[lastPerson]))</span><br><span class="line">        &#123;</span><br><span class="line">            lastPerson = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(recordsID[firstPerson] + &quot; &quot; + recordsID[lastPerson]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1007 Maximum Subsequence Sum</title>
    <url>/2019/05/28/1007-Maximum-Subsequence-Sum/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Given a sequence of <em>K</em> integers { <em>N1</em>, <em>N2</em>, ..., <em>NK</em> }. A continuous subsequence is defined to be { <em>Ni</em>, <em>Ni</em>+<em>1</em>, ..., <em>Nj</em> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>
<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em>numbers, separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定一个整型序列,要求出这个序列的最大子序和,最大子序和的开始和结束这三个元素.</p>
<p>注意,如果整个序列全部元素都为负数,那就最大子序和为0,开始和结束分别分该序列的起始和结束.</p>
<h2 id="思路">思路</h2>
<p>这道题和leetcode的这道<a href="https://jiayaoo3o.github.io/2019/05/06/53-最大子序和/">53.最大子序和</a>解法基本是一致的,如果添加数组的下一个数导致这个和成为了负数,说明这个序列能到达的最大的长度已经结束了,因为加上下一个数只会让和变得更小,新的序列应该从下一个数开始尝试.</p>
<p>但是这一道题的另一个不一样的点是还要记录最大子序和的起始和结束.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int count = int.Parse(Console.ReadLine());</span><br><span class="line">    string[] lines = Console.ReadLine().Split();</span><br><span class="line">    int[] inputs = new int[count];</span><br><span class="line">    int begin = 0, end = 0, temp = 0;//temp用来记录新的子串的起始位置.</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int max = -1;//max的初值设置为负数.</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        inputs[i] = int.Parse(lines[i]);</span><br><span class="line">        sum = sum + inputs[i];</span><br><span class="line">        if (sum &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = 0;</span><br><span class="line">            temp = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (sum &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = sum;</span><br><span class="line">                begin = temp;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (max &lt; 0)//用max&lt;0来判断是否全为负数是因为只要max不小于0,那说明整个序列里面起码得有一个非负数的元素.</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, 0, inputs[0], inputs[count - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, max, inputs[begin], inputs[end]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1008 Elevator</title>
    <url>/2019/04/16/1008-Elevator/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>The highest building in our city has only one elevator. A request list is made up with <em>N</em> positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.</p>
<p>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case contains a positive integer <em>N</em>, followed by <em>N</em> positive numbers. All the numbers in the input are less than 100.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the total time on a single line.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2 3 1</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">41</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>有一台电梯,有N层要停的楼,电梯从0层开始,上去一层要6s,下去一层要4s,每一层要停5s,到了最后的目的地之后就停在那,不用下来,求全程要花多少秒</p>
<h2 id="思路">思路</h2>
<p>这一题也不难,只要判断当前的这一层比上一层高还是低就行了,但是这里有一个很坑的点,就是题目说:</p>
<blockquote>
<p>Each case contains a positive integer <em>N</em>, followed by <em>N</em> positive numbers.</p>
<p>每一个例子里包含一个整数N,后面跟着N个数字.</p>
</blockquote>
<p>也就是说,上面的例子</p>
<blockquote>
<p>3 2 3 1</p>
</blockquote>
<p>是指一共有3层,分别是2 3 1,第一个3只是告诉你有多少层,不算进层数里面的,一开始我用手算了很久都算不出来41,还以为哪里理解错了, 原来是 : (2x6+5)+(6+5)+(2x4+5)=41</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    string[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    int result = 0;</span><br><span class="line">    int before = 0;</span><br><span class="line">    int now = 0;</span><br><span class="line">    int[] floors = new int[int.Parse(tokens[0])];</span><br><span class="line">    for (int i = 1; i &lt; tokens.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        floors[i - 1] = int.Parse(tokens[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; floors.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now = floors[i];</span><br><span class="line">        if (now &gt; before)</span><br><span class="line">        &#123;</span><br><span class="line">            result += (now - before) * 6 + 5;</span><br><span class="line">            before = now;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            result += (before - now) * 4 + 5;</span><br><span class="line">            before = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1009 Product of Polynomials</title>
    <url>/2019/05/28/1009-Product-of-Polynomials/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>This time, you are supposed to find <em>A</em>×<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p>
<p><em>K</em> <em>N1</em> <em>aN1</em> <em>N2</em> <em>aN2</em> ... <em>NK</em> <em>aNK</em></p>
<p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>Ni</em> and <em>aNi</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10, 0≤<em>NK</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case you should output the product of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be <strong>NO</strong> extra space at the end of each line. Please be accurate up to 1 decimal place.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 2.4 0 3.2</span><br><span class="line">2 2 1.5 1 0.5</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 3.6 2 6.0 1 1.6</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定两个多项式,其中N是指数,aNi是对应的系数,现在要算两个多项式的乘积.</p>
<p>系数精确到小数点后一位.</p>
<h2 id="思路">思路</h2>
<p>这道题要说难吧,其实不难,只要将两个多项式用泛型字典存起来,再定义一个排序的泛型字典接收他们相乘的结果就可以了.</p>
<p>但是里面有坑,尤其是第0个测试点,就是一个坑,因为题目要求精确到小数点的后1位,但是假如有两个系数分别是double类型的0.1和0.4,那他们相乘的结果是0.04保留一位有效数字那就是0.0了,所以虽然这个乘积不是0,但是是要被四舍五入舍去的,所以我们最后还要有一步判断最后的值是否&gt;=0.05.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    Dictionary&lt;int, double&gt; A = new Dictionary&lt;int, double&gt;();</span><br><span class="line">    Dictionary&lt;int, double&gt; B = new Dictionary&lt;int, double&gt;();</span><br><span class="line">    var product = new SortedDictionary&lt;int, double&gt;();//注意这里定义了一个排序字典,会自动帮我们把里面的数据排序.</span><br><span class="line">    string[] inputsA = Console.ReadLine().Split();</span><br><span class="line">    string[] inputsB = Console.ReadLine().Split();</span><br><span class="line">    string result = &quot;&quot;;</span><br><span class="line">    for (int i = 1; i &lt; inputsA.Length - 1; i += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        A.Add(int.Parse(inputsA[i]), double.Parse(inputsA[i + 1]));</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; inputsB.Length - 1; i += 2)</span><br><span class="line">        //这里其实可以不需要B字典,直接在循环里面计算A多项式的每个项与inputB相乘也是可以的.</span><br><span class="line">        //但是我发现速度相差不大,就直接定义两个字典了,反正代码更容易读.</span><br><span class="line">    &#123;</span><br><span class="line">        B.Add(int.Parse(inputsB[i]), double.Parse(inputsB[i + 1]));</span><br><span class="line">    &#125;</span><br><span class="line">    foreach (var a in A)</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (var b in B)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!product.ContainsKey(a.Key + b.Key))</span><br><span class="line">            &#123;</span><br><span class="line">                product.Add(a.Key + b.Key, a.Value * b.Value);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                product[a.Key + b.Key] += a.Value * b.Value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    foreach (var p in product)</span><br><span class="line">    &#123;</span><br><span class="line">        if (Math.Abs(p.Value) &gt;= 0.05)</span><br><span class="line">            //注意这里用到了绝对值,因为如果系数是-0.1和0.5相乘结果是-0.05也是要保留的.</span><br><span class="line">        &#123;</span><br><span class="line">            result = &quot; &quot; + p.Key + &quot; &quot; + p.Value.ToString(&quot;0.0&quot;) + result;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(count + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>101. 对称二叉树</title>
    <url>/2019/05/09/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>上回说到,遇到树的题目,往递归方面靠会比较合适,要判断这个二叉树是否对称,相当于递归判断每一个节点的左右节点的子节点是否成为镜像.</p>
<h2 id="代码">代码</h2>
<p>先实现一个递归函数,用来判断一个树的左右两个节点是否镜像对称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsSymmetricTree(TreeNode p, TreeNode q)</span><br><span class="line">&#123;</span><br><span class="line">    if (p != null &amp;&amp; q == null || p == null &amp;&amp; q != null)//如果左null右非null或者右null左非null,说明一定不是对称的.</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return (p == null &amp;&amp; q == null) || (p.val == q.val) &amp;&amp; IsSymmetricTree(p.left, q.right) &amp;&amp; IsSymmetricTree(p.right, q.left);</span><br><span class="line">        //先判断是不是都为null,然后再判断左右两个值是否相等,再递归判断左右子节点.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsSymmetric(TreeNode root)</span><br><span class="line">&#123;</span><br><span class="line">    return IsSymmetricTree(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1011 World Cup Betting</title>
    <url>/2019/04/16/1011-World-Cup-Betting/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p>
<p>Chinese Football Lottery provided a "Triple Winning" game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results -- namely <code>W</code> for win, <code>T</code> for tie, and <code>L</code> for lose. There was an odd assigned to each result. The winner's odd would be the product of the three odds times 65%.</p>
<p>For example, 3 games' odds are given as the following:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> W    T    L</span><br><span class="line">1.1  2.5  1.7</span><br><span class="line">1.2  3.1  1.6</span><br><span class="line">4.1  1.2  1.1</span><br></pre></td></tr></table></figure>
<p>To obtain the maximum profit, one must buy <code>W</code> for the 3rd game, <code>T</code> for the 2nd game, and <code>T</code> for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1×3.1×2.5×65%−1)×2=39.31 yuans (accurate up to 2 decimal places).</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to <code>W</code>, <code>T</code> and <code>L</code>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.1 2.5 1.7</span><br><span class="line">1.2 3.1 1.6</span><br><span class="line">4.1 1.2 1.1</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T T W 39.31</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>就是说世界杯到了,赌球的时候也到了,现在有一种赌球玩法,有三个队伍,他们的获得W(胜利),T(平手),L(失败)的概率是表格里的数据,我们买的时候,分别买三个队伍里面概率最高的,每个买2元,就可以通过下面的公式算出我们的最大利润:</p>
<blockquote>
<p>(4.1×3.1×2.5×65%−1)×2=39.31</p>
</blockquote>
<p>现在给你三个队伍的数据,也是每个买2元,要你算出最大利润,并且要在输出结果时,分别说出你买了每个队的哪个情况,T T W 39.31是指第一个队伍买T,第二个队伍买T,第三个队伍买W,总利润39.31.</p>
<h2 id="思路">思路</h2>
<p>这一题也很简单了,给你三个数据,让你找出数据里面最大的数,然后代入公式就行了.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    string[] teams1 = System.Console.ReadLine().Split();</span><br><span class="line">    string[] teams2 = System.Console.ReadLine().Split();</span><br><span class="line">    string[] teams3 = System.Console.ReadLine().Split();</span><br><span class="line">    string[] WTL = &#123; &quot;W&quot;, &quot;T&quot;, &quot;L&quot; &#125;;</span><br><span class="line">    double[] t1 = new double[teams1.Length];</span><br><span class="line">    double[] t2 = new double[teams2.Length];</span><br><span class="line">    double[] t3 = new double[teams3.Length];</span><br><span class="line">    for (int i = 0; i &lt; t1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i] = double.Parse(teams1[i]);</span><br><span class="line">        t2[i] = double.Parse(teams2[i]);</span><br><span class="line">        t3[i] = double.Parse(teams3[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    double max = 0;</span><br><span class="line">    int maxindex = 0;</span><br><span class="line">    double socre = 1;</span><br><span class="line">    for (int i = 0; i &lt; t1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (t1[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = t1[i];</span><br><span class="line">            maxindex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Write(WTL[maxindex] + &quot; &quot;);</span><br><span class="line">    socre *= max;</span><br><span class="line">    max = 0;</span><br><span class="line">    for (int i = 0; i &lt; t2.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (t2[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = t2[i];</span><br><span class="line">            maxindex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Write(WTL[maxindex] + &quot; &quot;);</span><br><span class="line">    socre *= max;</span><br><span class="line">    max = 0;</span><br><span class="line">    for (int i = 0; i &lt; t3.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (t3[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = t3[i];</span><br><span class="line">            maxindex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Write(WTL[maxindex] + &quot; &quot;);</span><br><span class="line">    socre *= max;</span><br><span class="line">    socre = socre * 0.65 * 2 - 2;</span><br><span class="line">    Console.Write(socre.ToString(&quot;0.00&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1015 Reversible Primes</title>
    <url>/2019/04/16/1015-Reversible-Primes/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>A <strong>reversible prime</strong> in any number system is a prime whose "reverse" in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.</p>
<p>Now given any two positive integers <em>N</em> (&lt;10<sup>5</sup>) and <em>D</em> (1&lt;<em>D</em>≤10), you are supposed to tell if <em>N</em> is a reversible prime with radix <em>D</em>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>The input file consists of several test cases. Each case occupies a line which contains two integers <em>N</em> and <em>D</em>. The input is finished by a negative <em>N</em>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line <code>Yes</code> if <em>N</em> is a reversible prime with radix <em>D</em>, or <code>No</code> if not.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">73 10</span><br><span class="line">23 2</span><br><span class="line">23 10</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>判断一个素数是不是可逆素数,这个题目稍微理解困难一点点的是,它并不是直接给你一个37,让你判断将它反转之后的73是不是素数,还有一个D,这个radix D是指基数,你也可以理解为进制,就是你要将N转换成D进制数,反转,再转换成10进制数,然后看它是不是可逆素数.</p>
<p>这道题的另一个让我困惑的点是,原来并不是让它输完了数据之后,再显示结果,而是直接输入完一行,就显示一行,所以上面那个例子,在程序里面,应该是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">73 10</span><br><span class="line">Yes</span><br><span class="line">23 2</span><br><span class="line">Yes</span><br><span class="line">23 10</span><br><span class="line">No</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>
<p>这样子的.</p>
<h2 id="思路">思路</h2>
<p>这里我们为了让思维更加规整,先创建两个工具函数,一个用来判断某个数字是不是素数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static bool IsPrime(int input)</span><br><span class="line">&#123;</span><br><span class="line">    if (input &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i &lt; input; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (input % i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个函数用来反转素数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int Reverse(int prime, int radix)</span><br><span class="line">&#123;</span><br><span class="line">    int n = prime;</span><br><span class="line">    int result = 0;</span><br><span class="line">    while (n != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        result = result * radix + (n % radix);</span><br><span class="line">        n /= radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们只要获取到输入的数据,进行判断就行了.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string line;</span><br><span class="line">    int N = 0;</span><br><span class="line">    int D = 0;</span><br><span class="line">    while ((line = System.Console.ReadLine()) != null)</span><br><span class="line">    &#123;</span><br><span class="line">        string[] tokens = line.Split();</span><br><span class="line">        if (int.Parse(tokens[0]) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            N = int.Parse(tokens[0]);</span><br><span class="line">            D = int.Parse(tokens[1]);</span><br><span class="line">            if (!IsPrime(Reverse(N, D)) || !IsPrime(int.Parse(tokens[0])))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;No&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Yes&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1019 General Palindromic Number</title>
    <url>/2019/04/17/1019-General-Palindromic-Number/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>A number that will be the same when it is written forwards or backwards is known as a <strong>Palindromic Number</strong>. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p>
<p>Now given any two positive integers <em>N</em> (&lt;10<sup>5</sup>) and <em>D</em> (1&lt;<em>D</em>≤10), you are supposed to tell if <em>N</em> is a reversible prime with radix <em>D</em>.</p>
<p>Given any positive decimal integer <em>N</em> and a base <em>b</em>, you are supposed to tell if <em>N</em> is a palindromic number in base <em>b</em>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case consists of two positive numbers <em>N</em> and <em>b</em>, where 0&lt;<em>N</em>≤10<sup>9</sup> is the decimal number and 2≤<em>b</em>≤10<sup>9</sup> is the base. The numbers are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, first print in one line <code>Yes</code> if <em>N</em> is a palindromic number in base <em>b</em>, or <code>No</code> if not. Then in the next line, print <em>N</em> as the number in base <em>b</em> in the form "a<em>k</em> a<em>k−1</em> ... <em>a</em>0". Notice that there must be no extra space at the end of output.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">27 2</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">1 1 0 1 1</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">121 5</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br><span class="line">4 4 1</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>这一题和上一题1015有点相似,那一题是找素数,这一题是找回文,但是不是直接判断一个数是不是回文,而是要判断某个数N的b进制数是不是回文.</p>
<p>另一点要注意的是,如果N是0,那不管是多少进制,结果都是Yes,并且输出0.</p>
<h2 id="思路">思路</h2>
<p>这道题考的点主要还是两个,1是看你会不会进制转换,2是考你会不会判断回文.</p>
<p>所以我们可以先写一个判断回文的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static bool IsPalindromic(int[] input, int index)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt;= index / 2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (input[i] != input[index - 1 - i])</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再将已经转换了进制的整型数组放进去,判断是不是回文.</p>
<p>这里我们选择将N转换成b进制之后的结果放入一个整型数组,因为这样比较方便操作,但是要注意的是,因为一开始创建整型数组 <strong>int[ ] n</strong> 的时候,是不知道接下来要放进去的数据是多少位的,这就导致我们不知道整型数组结束的最后下标在哪,所以需要一个下标变量index确定末尾.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    string line = &quot;&quot;;</span><br><span class="line">    while ((line = System.Console.ReadLine()) != null)</span><br><span class="line">    &#123;</span><br><span class="line">        string[] tokens = line.Split();</span><br><span class="line">        int N = int.Parse(tokens[0]);</span><br><span class="line">        int b = int.Parse(tokens[1]);</span><br><span class="line">        if (N == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Yes&quot;);</span><br><span class="line">            Console.WriteLine(&quot;0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int[] n = new int[40];</span><br><span class="line">            int index = 0;</span><br><span class="line">            while (N != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                n[index] = N % b;</span><br><span class="line">                N /= b;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (IsPalindromic(n, index))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Yes&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;No&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = index - 1; i &gt;= 0; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                if (i &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(n[i] + &quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(n[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1023 Have Fun with Numbers</title>
    <url>/2019/04/17/1023-Have-Fun-with-Numbers/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!</p>
<p>Now you are suppose to check if there are more numbers with this property. That is, double a given number with <em>k</em> digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input contains one test case. Each case contains one positive integer with no more than 20 digits.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, first print in a line "Yes" if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or "No" if not. Then in the next line, print the doubled number.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234567899</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">2469135798</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>让你判断一个数,翻倍之后,是否还符合要求:</p>
<ul>
<li>翻倍之后的每一个数字,都要是没翻倍之前出现过的.</li>
<li>翻倍之后的每一个数字,出现的频率都要和没翻倍之前一样.</li>
</ul>
<h2 id="思路">思路</h2>
<p>这一题最难的地方,是读懂题目,我就是因为没看明白原来还有频率要求,被卡好久了,只要明确了有这两个要求,就比较好办了.</p>
<p>另一点要注意的是,题目规定是20位之内的大数翻倍,所以不应该用整型长整型这些数据类型,而是应该用数组保存数据.</p>
<h2 id="代码">代码</h2>
<p>既然要判断翻倍之后的数字是不是翻倍之前就存在的,那我们先创建一个用来判断某个数是不是在数组里面的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static bool Contains(char[] input, char index)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; input.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (input[i] == index)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再创建一个函数,用来将整型数组翻倍:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int[] DoubleIntegerArray(int[] num)</span><br><span class="line">&#123;</span><br><span class="line">    int flag = 0;</span><br><span class="line">    int length = num.Length - 1;</span><br><span class="line">    while (num[length] != -1)</span><br><span class="line">    &#123;</span><br><span class="line">        if (num[length] * 2 &gt;= 10)</span><br><span class="line">        &#123;</span><br><span class="line">            num[length] = num[length] * 2 % 10 + flag;</span><br><span class="line">            flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            num[length] = num[length] * 2 % 10 + flag;</span><br><span class="line">            flag = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        num[length] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个函数用来判断频率是不是已经全为0了,用来判断翻倍之后的数字和翻倍之前频率是否一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static bool FrequencyIsEmpty(int[] frequency)</span><br><span class="line">&#123;</span><br><span class="line">    foreach (var fre in frequency)</span><br><span class="line">    &#123;</span><br><span class="line">        if (fre != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    char[] line = System.Console.ReadLine().ToCharArray();</span><br><span class="line">    int[] num = new int[22];</span><br><span class="line">    int[] frequency = new int[10];</span><br><span class="line">    //用来判断新数字出来的频率和原数字是否一致.如果程序结束后frequency全为0则频率一致.</span><br><span class="line">    for (int i = 0; i &lt; num.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //将数组置为-1;</span><br><span class="line">        num[i] = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; line.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[num.Length - line.Length + i] = line[i] - &#x27;0&#x27;;//char转int要-48或者-&#x27;0&#x27;.</span><br><span class="line">        frequency[line[i] - &#x27;0&#x27;]++;//记录对应位置的频率.</span><br><span class="line">    &#125;</span><br><span class="line">    num = DoubleIntegerArray(num);</span><br><span class="line">    for (int i = num.Length - 1; num[i] != -1; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!Contains(line, (char)(num[i] + 48)))</span><br><span class="line">        &#123;</span><br><span class="line">            //如果出现了不存在的数字,直接NO</span><br><span class="line">            Console.WriteLine(&quot;No&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        frequency[num[i]]--;</span><br><span class="line">        if (num[i - 1] == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            if (FrequencyIsEmpty(frequency))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Yes&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;No&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; num.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (num[i] != -1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1027 Colors in Mars</title>
    <url>/2019/04/18/1027-Colors-in-Mars/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for <code>Red</code>, the middle 2 digits for <code>Green</code>, and the last 2 digits for <code>Blue</code>. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case which occupies a line containing the three decimal color values.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case you should output the Mars RGB value in the following format: first output <code>#</code>, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a <code>0</code> to its left.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15 43 71</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#123456</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>地球人的rgb颜色是16进制的,火星的rgb是13进制的,现在给你三个10进制数,要转换成火星rgb模式,要求:</p>
<ul>
<li><p>每种颜色的13进制数占2位.</p></li>
<li><p>三个10进制数范围是0到168.</p></li>
<li><p>如果转换成13进制数只有1位,那剩下的那一位左边要.</p></li>
<li><p>结果按照#rrggbb输出.</p></li>
</ul>
<h2 id="思路">思路</h2>
<p>这道题考察的是进制转换,只要实现一个函数,对输入的10进制数转换成13进制,然后用一个字符串将3种颜色拼接在一起.</p>
<p>而10进制转换到任意进制的方法都是固定的,就是10进制数%目标进制的余数的拼接结果.</p>
<h2 id="代码">代码</h2>
<p>先实现一个10进制转换到任意进制的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static string ConvertDecToTarget(int dec, int target, int length)</span><br><span class="line">&#123;</span><br><span class="line">    char[] result = new char[length];//length用来规定结果的长度.</span><br><span class="line">    for (int i = 0; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result[i] = &#x27;0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = dec;</span><br><span class="line">    int index = length - 1;</span><br><span class="line">    while (n != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (n % target &gt;= 10)</span><br><span class="line">        &#123;</span><br><span class="line">            result[index--] = (char)(n % target + 55);//整型到char大写字母.</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            result[index--] = (char)(n % target + 48);//整型到char数字</span><br><span class="line">        &#125;</span><br><span class="line">        n /= target;</span><br><span class="line">    &#125;</span><br><span class="line">    return new string(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    int red = int.Parse(tokens[0]);</span><br><span class="line">    int green = int.Parse(tokens[1]);</span><br><span class="line">    int blue = int.Parse(tokens[2]);</span><br><span class="line">    string result = &quot;#&quot;;</span><br><span class="line">    result += ConvertDecToTarget(red, 13, 2);</span><br><span class="line">    result += ConvertDecToTarget(green, 13, 2);</span><br><span class="line">    result += ConvertDecToTarget(blue, 13, 2);</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1035 Password</title>
    <url>/2019/04/18/1035-Password/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish <code>1</code> (one) from <code>l</code> (<code>L</code> in lowercase), or <code>0</code> (zero) from <code>O</code> (<code>o</code> in uppercase). One solution is to replace <code>1</code> (one) by <code>@</code>, <code>0</code> (zero) by <code>%</code>, <code>l</code> by <code>L</code>, and <code>O</code> by <code>o</code>. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case contains a positive integer <em>N</em> (≤1000), followed by <em>N</em> lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, first print the number <em>M</em> of accounts that have been modified, then print in the following <em>M</em> lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line <code>There are N accounts and no account is modified</code> where <code>N</code> is the total number of accounts. However, if <code>N</code> is one, you must print <code>There is 1 account and no account is modified</code> instead.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Team000002 Rlsp0dfa</span><br><span class="line">Team000003 perfectpwd</span><br><span class="line">Team000001 R1spOdfa</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">Team000002 RLsp%dfa</span><br><span class="line">Team000001 R@spodfa</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">team110 abcdefg332</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There is 1 account and no account is modified</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-3">Sample Input 3:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">team110 abcdefg222</span><br><span class="line">team220 abcdefg333</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-3">Sample Output 3:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are 2 accounts and no account is modified</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>让你按照给定的规则修改用户密码,修改完成之后输出修改的结果:</p>
<ul>
<li>1-&gt;@</li>
<li>0-&gt;%</li>
<li>l-&gt;L</li>
<li>O-&gt;o</li>
</ul>
<p>如果只有1个账户输入,而没有发生修改,输出:</p>
<blockquote>
<p>There is 1 account and no account is modified</p>
</blockquote>
<p>如果有N个账户输入,而没有发生修改,输出:</p>
<blockquote>
<p>There are N accounts and no account is modified</p>
</blockquote>
<h2 id="思路">思路</h2>
<p>这道题一开始我还打算用字典来存储用户名和密码,但是搞了好半天还不如直接用两个字符串数组.</p>
<p>创建一个字符串数组users用来存用户名,另一个字符串数组passwords用来存密码,两者位置一一对应</p>
<p>再创建一个存储修改位置的布尔数组modifiedInfo,哪个位置修改了密码,就在对应的布尔数组上置为true,最后做一个循环输出就行了.</p>
<h2 id="代码">代码</h2>
<p>先写一个用来修改密码的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static string ChangePassword(char[] password)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; password.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (password[i] == &#x27;0&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            password[i] = &#x27;%&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (password[i] == &#x27;1&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            password[i] = &#x27;@&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (password[i] == &#x27;l&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            password[i] = &#x27;L&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (password[i] == &#x27;O&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            password[i] = &#x27;o&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new string(password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int userCount = int.Parse(System.Console.ReadLine());</span><br><span class="line">    int modifiedCount = 0;</span><br><span class="line">    bool[] modifiedInfo = new bool[userCount];</span><br><span class="line">    string[] users = new string[userCount];</span><br><span class="line">    string[] passwords = new string[userCount];</span><br><span class="line">    for (int i = 0; i &lt; userCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string[] line = System.Console.ReadLine().Split();</span><br><span class="line">        users[i] = line[0];</span><br><span class="line">        passwords[i] = line[1];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; userCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!(ChangePassword(passwords[i].ToCharArray()) == passwords[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            //判断旧密码和新密码是否一致.</span><br><span class="line">            modifiedInfo[i] = true;</span><br><span class="line">            passwords[i] = ChangePassword(passwords[i].ToCharArray());</span><br><span class="line">            modifiedCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (modifiedCount == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (userCount != 1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;There are &quot; + userCount + &quot; accounts and no account is modified&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;There is &quot; + userCount + &quot; account and no account is modified&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(modifiedCount);</span><br><span class="line">        for (int i = 0; i &lt; userCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (modifiedInfo[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(users[i] + &quot; &quot; + passwords[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>104.二叉树的最大深度</title>
    <url>/2019/05/12/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong> 给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>还是用递归的方法来逐层+1,算出最大的深度</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int MaxDepth(TreeNode root)</span><br><span class="line">&#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 1 + Math.Max(MaxDepth(root.left), MaxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1041 Be Unique</title>
    <url>/2019/04/19/1041-Be-Unique/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1,10<sup>4</sup>]. The first one who bets on a unique number wins. For example, if there are 7 people betting on { 5 31 5 88 67 88 17 }, then the second one who bets on 31 wins.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case contains a line which begins with a positive integer <em>N</em> (≤10<sup>5</sup>) and then followed by <em>N</em> bets The numbers are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the winning number in a line. If there is no winner, print <code>None</code> instead.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 5 31 5 88 67 88 17</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">31</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 888 666 666 888 888</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">None</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>我发现PAT的题目就不喜欢直接问你,而是搞成某个情景来体现这个算法,花里胡哨.</p>
<p>这道题的意思是火星上的人都喜欢追求独一无二,所以这里有个彩票游戏,就是大伙N人从1到10<sup>4</sup>数字范围内抽一个数字下注,下注完了之后,第一个抽到独一无二,没有和别人重复数字的人,就赢了.</p>
<p>给定的一串数字,第一个数是指人数N,后面的是指大家下注的数字,我们要找出第一个只出现一次的数字,例如第一个例子里的31,66,17都出现了一次,但是31是第一个出现的,所以31赢了.</p>
<p>如果没有独一无二的数字,就输出None.</p>
<h2 id="思路">思路</h2>
<p>这道题是肯定不能直接用循环一次所有输入数字的方法来做的,因为这个人数N的上限是10<sup>5</sup>,循环完了肯定都超时了,所以要用到hash,直接定位到所选的数字,然后修改这个数字的次数,因为我们用的是数组,直接定位到数组的某个位置速度是很快的.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    int count = int.Parse(tokens[0]);</span><br><span class="line">    int[] numbers = new int[count];//记录输入了哪些数字.</span><br><span class="line">    int[] frequency = new int[100000];//记录所输入的这些数字的频率.</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        numbers[i] = int.Parse(tokens[i + 1]);</span><br><span class="line">        frequency[numbers[i]]++;//如果numbers[i]是5,那frequency的第5个位置就+1.</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (frequency[numbers[i]] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(numbers[i]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i == count - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;None&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1042 Shuffling Machine</title>
    <url>/2019/04/19/1042-Shuffling-Machine/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid "inside jobs" where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ <strong>automatic shuffling machines</strong>. Your task is to simulate a shuffling machine.</p>
<p>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S1, S2, ..., S13, </span><br><span class="line">H1, H2, ..., H13, </span><br><span class="line">C1, C2, ..., C13, </span><br><span class="line">D1, D2, ..., D13, </span><br><span class="line">J1, J2</span><br></pre></td></tr></table></figure>
<p>where "S" stands for "Spade", "H" for "Heart", "C" for "Club", "D" for "Diamond", and "J" for "Joker". A given order is a permutation of distinct integers in [1, 54]. If the number at the <em>i</em>-th position is <em>j</em>, it means to move the card from position <em>i</em> to position <em>j</em>. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>K</em> (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给你一副顺序完整的扑克牌,要你按照一定的规则去洗牌.</p>
<p>例如给你5张牌:</p>
<blockquote>
<p>S3, H5, C1, D13, J2</p>
</blockquote>
<p>给你一个洗牌顺序:</p>
<blockquote>
<p>{4, 2, 5, 3, 1}</p>
</blockquote>
<p>那洗牌一次的结果就是,把对应位置的牌放到对应的洗牌顺序位置:</p>
<blockquote>
<p>J2, H5, D13, S3, C1</p>
</blockquote>
<p>再用这个规则洗牌一次,结果就是:</p>
<blockquote>
<p>C1, H5, S3, J2, D13</p>
</blockquote>
<p>现在要求给你一个洗牌次数K,再一个洗牌顺序,让你把按照洗牌顺序的54张洗牌结果输出.</p>
<h2 id="思路">思路</h2>
<p>这道题,只要创建三个数组:一个指令数组orders,一个扑克牌数组cards,一个洗牌结果数组result,然后将洗牌指令数组内的数据作为结果数组的下标,存放扑克牌就好了.即:</p>
<blockquote>
<p>result[orders[i] - 1] = cards[i];</p>
</blockquote>
<p>例如现在i=0,对于上面那五张牌,order[0]-1就是4-1=3,所以result[3]=cards[0],这就可以将第一张扑克牌S3放到第4位了.</p>
<h2 id="代码">代码</h2>
<p>创建一个洗牌数组,放入一个洗牌指令,放入一个扑克牌,返回洗牌结果.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static string[] ShufflingMachines(int[] orders, string[] cards)</span><br><span class="line">&#123;</span><br><span class="line">    string[] result = new string[cards.Length];</span><br><span class="line">    for (int i = 0; i &lt; orders.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result[orders[i] - 1] = cards[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int repeatTimes = int.Parse(System.Console.ReadLine());</span><br><span class="line">    string[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    int[] orders = new int[tokens.Length];</span><br><span class="line">    string[] cards = new string[54];</span><br><span class="line">    for (int i = 0; i &lt; 54; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        orders[i] = int.Parse(tokens[i]);</span><br><span class="line">        if (i &lt; 13)</span><br><span class="line">        &#123;</span><br><span class="line">            cards[i] = &quot;S&quot; + (i + 1).ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= 13 &amp;&amp; i &lt; 26)</span><br><span class="line">        &#123;</span><br><span class="line">            cards[i] = &quot;H&quot; + (i % 13 + 1).ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= 26 &amp;&amp; i &lt; 39)</span><br><span class="line">        &#123;</span><br><span class="line">            cards[i] = &quot;C&quot; + (i % 13 + 1).ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= 39 &amp;&amp; i &lt; 52)</span><br><span class="line">        &#123;</span><br><span class="line">            cards[i] = &quot;D&quot; + (i % 13 + 1).ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= 52)</span><br><span class="line">        &#123;</span><br><span class="line">            cards[i] = &quot;J&quot; + (i % 13 + 1).ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; repeatTimes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cards = ShufflingMachines(orders, cards);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; cards.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i != cards.Length - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(cards[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(cards[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1046 Shortest Distance</title>
    <url>/2019/04/20/1046-Shortest-Distance/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>The task is really simple: given <em>N</em> exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains an integer <em>N</em> (in [3,10<sup>5</sup>]), followed by <em>N</em> integer distances D<sub>1</sub> D<sub>2</sub> ⋯ D<sub>N</sub>, where D<sub>i</sub> is the distance between the <em>i</em> -th and the (<em>i</em>+1)-st exits, and D<sub>N</sub> is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M(≤10<sup>4</sup>), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 10<sup>7</sup>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print your results in <em>M</em> lines, each contains the shortest distance between the corresponding given pair of exits.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 1 2 4 14 9</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">4 1</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>在一条环状高速公路上有很多节点,并且已知每个节点到下一个节点的距离,现在给定两个节点,要求求出节点的最近距离是多少.</p>
<h2 id="思路">思路</h2>
<p>这道题我一开始的思路是直接顺时针求出A到B和B到A的距离,看看谁小,这样做思路并没有错,但是因为我求距离的方法是用一个for循环,获取每个节点上的距离,再累加,这样分别循环两次得到的结果,但是当测试案例有很多个节点的时候,这样做会太浪费时间,导致超时.</p>
<p>所以对于上面的超时,要进行的思路改进有两点:</p>
<ul>
<li><p>不应该顺时针循环算两遍,因为高速公路是一个圆,只要算出A到B的距离,然后用总距离减去A到B距离,结果就是B到A了.</p></li>
<li><p>算A到B距离,没必要用循环累加每个节点的距离这种方式,我们用数组保存节点距离的时候,没必要将<strong>节点与下一个节点的距离</strong>保存到数组中,而是应该将<strong>节点与第一个节点的距离</strong>保存在数组中,例如例子中的:</p>
<blockquote>
<p>1 2 4 14 9</p>
</blockquote>
<p>是指当前节点,到下一个节点的距离,而我们保存数据的时候,可以保存为:</p>
<blockquote>
<p>0 1 3 7 21</p>
</blockquote>
<p>这是指每一个点到第一个点的距离,这样的话我们算A到B的距离就不用循环了,直接是第A个节点减去地B个节点的距离(下标0是第一个节点).</p></li>
</ul>
<h2 id="代码">代码</h2>
<p>先实现一个获得最短路径的函数,这个函数传入4个参数,分别是:保存各个节点数据的数组,需要计算的开始节点,需要计算的结束节点,还有总距离.</p>
<p>我们要做的是比较开始节点到结束节点之间的距离和总距离减去两节点之间的距离,谁更小就取哪个值.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int GetShortestDistance(int[] nodes, int beginNode, int endNode, int totalDistance)</span><br><span class="line">&#123;</span><br><span class="line">    int distance = beginNode &gt; endNode ? nodes[beginNode - 1] - nodes[endNode - 1] : nodes[endNode - 1] - nodes[beginNode - 1];</span><br><span class="line">    return distance &lt; (totalDistance - distance) ? distance : (totalDistance - distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    int nodesCount = int.Parse(tokens[0]);</span><br><span class="line">    int[] nodes = new int[nodesCount];</span><br><span class="line">    int totalDistance = 0;</span><br><span class="line">    for (int i = 0; i &lt; nodes.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes[i] = totalDistance;</span><br><span class="line">        totalDistance += int.Parse(tokens[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    int pairsCount = int.Parse(Console.ReadLine());</span><br><span class="line">    for (int i = 0; i &lt; pairsCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string[] pairs = Console.ReadLine().Split();</span><br><span class="line">        Console.WriteLine(GetShortestDistance(nodes, int.Parse(pairs[0]), int.Parse(pairs[1]), totalDistance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我其实还是有一个对于PAT的疑惑的,按照题目所说,不是应该等输入完了所有的节点对之后,再输出三个最短距离结果吗?为什么现在是输入一个节点对,马上输出一个结果,这样也可以呢?不影响程序判定的吗?</p>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1050 String Subtraction</title>
    <url>/2019/04/22/1050-String-Subtraction/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Given two strings <em>S</em>1 and <em>S</em>2, <em>S</em>=<em>S</em>1−<em>S</em>2 is defined to be the remaining string after taking all the characters in <em>S</em>2from <em>S</em>1. Your task is simply to calculate <em>S</em>1−<em>S</em>2 for any given strings. However, it might not be that simple to do it <strong>fast</strong>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case consists of two lines which gives <em>S</em>1 and <em>S</em>2, respectively. The string lengths of both strings are no more than 10<sup>4</sup>. It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print <em>S</em>1−<em>S</em>2 in one line.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">They are students.</span><br><span class="line">aeiou</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thy r stdnts.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定两个字符串S1,S2,输出S1-S2的结果.注意题目特地提到了fast,所以这道题时间是关键.</p>
<h2 id="思路">思路</h2>
<p>这道题看似很简单,但是正是因为很简单,所以肯定不能用最简单的双重for循环来判定的,因为S1最大长度可能到达10<sup>4</sup>,直接循环肯定要超时的.</p>
<p>但是我们知道,这道题无论如何都是要循环S1一次的,因为总得要输出的嘛,所以这道题只能循环一次S1,否则就要超时了.</p>
<p>所以这次题目的要求是要在一次S1循环内直接验证S1的某个字符是否在S2中存在,要用哈希表来解决.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string S1 = System.Console.ReadLine();</span><br><span class="line">    string S2 = System.Console.ReadLine();</span><br><span class="line">    bool[] signals = new bool[127];//创建一个bool数组,长度是ascii表的长度,保证每一个字符都有自己的位置.</span><br><span class="line">    foreach (var signal in S2)</span><br><span class="line">    &#123;</span><br><span class="line">        signals[signal] = true;//将bool数组的对应位置设置为true.</span><br><span class="line">    &#125;</span><br><span class="line">    foreach (var character in S1)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!signals[character])//将S1字符串对逐个字符放入bool数组中进行验证,如果是true说明需要放弃,是false说明需要输出.</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(character);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1054 The Dominant Color</title>
    <url>/2019/04/22/1054-The-Dominant-Color/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Behind the scenes in the computer's memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. A <strong>strictly</strong> dominant color takes more than half of the total area. Now given an image of resolution <em>M</em>by <em>N</em> (for example, 800×600), you are supposed to point out the strictly dominant color.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: <em>M</em> (≤800) and <em>N</em> (≤600) which are the resolutions of the image. Then <em>N</em> lines follow, each contains <em>M</em> digital colors in the range [0,2<sup>24</sup>). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, simply print the dominant color in a line.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">0 0 255 16777215 24</span><br><span class="line">24 24 0 0 24</span><br><span class="line">24 0 24 24 24</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定一张照片的分辨率为MxN,每一个像素点拥有一个颜色,任务是求出这张照片中一定存在的那个主颜色(颜色超过像素数目的一半).</p>
<h2 id="思路">思路</h2>
<p>我真的差点就被这道题搞自闭了,这个题目考察的点是哈希表,通过将出现过的颜色放入哈希表,颜色每出现一次,就将哈希表对应的数值加一,当颜色出现的次数大于一半像素时,即为所求颜色.</p>
<p>但是当我用这个办法去解这道题时,其他测试案例都通过了,唯独最后一个测试案例却永远是错误的,哪怕我已经觉得我的代码和别人的都一样了,只是用C#语言翻译过来而已,都仍然不能够通过,最后我意识到了,还有唯一的一种情况我没有设想到,那就是只有一个像素点的时候.</p>
<p>幸好最后我在<a href="https://github.com/lynnprosper/ZJU_PAT/tree/master/Advanced_Level">这个仓库</a>中看到了一个新的解法,把这道题过了.</p>
<p>这个巧妙的解法并没有用到哈希表,而是用一个全新的思路.因为我们已知,图片上肯定有一个主颜色,这个颜色的出现次数肯定大于剩下所有的颜色出现次数之和,也就是说,这个主颜色的出现次数减去剩下所有颜色出现的次数,都要大于0,所以可以定义两个变量,一个是当前颜色nowColor.</p>
<p>另一个是当前颜色出现的次数nowColorCount初始化为1.</p>
<p>如果输入颜色等于当前颜色,那就让nowColorCount++;</p>
<p>如果输入颜色不等于当前颜色,就让nowColorCount--;</p>
<p>如果nowColorCount自减成0,那说明nowColor还不是主颜色,那就将输入颜色设置为当前颜色nowColor.</p>
<p>这样到最后,nowColor肯定会成为主颜色,nowColorCount也肯定大于0.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    int column = int.Parse(tokens[0]);</span><br><span class="line">    int row = int.Parse(tokens[1]);</span><br><span class="line">    int half = (column * row) / 2;</span><br><span class="line">    int nowColorCount = 1;</span><br><span class="line">    string nowColor = &quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens = System.Console.ReadLine().Split();</span><br><span class="line">        foreach (var token in tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            if (token == nowColor)</span><br><span class="line">            &#123;</span><br><span class="line">                nowColorCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                nowColorCount--;</span><br><span class="line">                if (nowColorCount == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    nowColor = token;</span><br><span class="line">                    nowColorCount = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(nowColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是把我搞自闭的，用字典实现哈希功能的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    int column = int.Parse(tokens[0]);</span><br><span class="line">    int row = int.Parse(tokens[1]);</span><br><span class="line">    int half = (column * row) / 2;</span><br><span class="line">    Dictionary&lt;string, int&gt; dict = new Dictionary&lt;string, int&gt;();</span><br><span class="line">    for (int i = 0; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens = System.Console.ReadLine().Split();</span><br><span class="line">        foreach (var token in tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            if (dict.ContainsKey(token))</span><br><span class="line">            &#123;</span><br><span class="line">                dict[token]++;</span><br><span class="line">                if (dict[token] &gt; half)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(token);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                dict.Add(token, 1);</span><br><span class="line">                if (dict[token] &gt; half)//把我搞自闭的就是这个位置,如果像素点只有一个,那添加进来的时候就要判断了.</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(token);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1058 A+B in Hogwarts</title>
    <url>/2019/04/22/1058-A-B-in-Hogwarts/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>If you are a fan of Harry Potter, you would know the world of magic has its own currency system -- as Hagrid explained it to Harry, "Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it's easy enough." Your job is to write a program to compute <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are given in the standard form of <code>Galleon.Sickle.Knut</code> (<code>Galleon</code> is an integer in [0,10<sup>7</sup>], <code>Sickle</code> is an integer in [0, 17), and <code>Knut</code> is an integer in [0, 29)).</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case which occupies a line with <em>A</em> and <em>B</em> in the standard form, separated by one space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.2.1 10.16.27</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14.1.28</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>又是一道花里胡哨的题目,给你两个分成三个数的字符串,让你通过"霍格沃兹"进制来计算他们的和:最后一个数是29进制,中间那个数是17进制,第一个数是10进制.</p>
<h2 id="思路">思路</h2>
<p>这道题没什么好说的,就是进制算就完事了,尤其是这个数只有3份,甚至都不用循环,直接写就行了.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static string HogwartsAddition(string A, string B)</span><br><span class="line">&#123;</span><br><span class="line">    int[] currencyA = new int[3];</span><br><span class="line">    int[] currencyB = new int[3];</span><br><span class="line">    int[] result = new int[3];</span><br><span class="line">    string[] strA = A.Split(&#x27;.&#x27;);</span><br><span class="line">    string[] strB = B.Split(&#x27;.&#x27;);</span><br><span class="line">    int flag = 0;</span><br><span class="line">    for (int i = 0; i &lt; strA.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        currencyA[i] = int.Parse(strA[i]);</span><br><span class="line">        currencyB[i] = int.Parse(strB[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    result[2] = (currencyA[2] + currencyB[2]) % 29;</span><br><span class="line">    flag = currencyA[2] + currencyB[2] &gt;= 29 ? 1 : 0;</span><br><span class="line">    result[1] = (currencyA[1] + currencyB[1] + flag) % 17;</span><br><span class="line">    flag = currencyA[1] + currencyB[1] + flag &gt;= 17 ? 1 : 0;</span><br><span class="line">    result[0] = currencyA[0] + currencyB[0] + flag;</span><br><span class="line">    return result[0] + &quot;.&quot; + result[1] + &quot;.&quot; + result[2];</span><br><span class="line">&#125;</span><br><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">    Console.WriteLine(HogwartsAddition(tokens[0], tokens[1]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1061 Dating</title>
    <url>/2019/04/23/1061-Dating/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Sherlock Holmes received a note with some strange strings: <code>Let's date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm</code>. It took him only a minute to figure out that those strange strings are actually referring to the coded time <code>Thursday 14:04</code> -- since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter <code>D</code>, representing the 4th day in a week; the second common character is the 5th capital letter <code>E</code>, representing the 14th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from <code>A</code> to <code>N</code>, respectively); and the English letter shared by the last two strings is <code>s</code> at the 4th position, representing the 4th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the decoded time in one line, in the format <code>DAY HH:MM</code>, where <code>DAY</code> is a 3-character abbreviation for the days in a week -- that is, <code>MON</code>for Monday, <code>TUE</code> for Tuesday, <code>WED</code> for Wednesday, <code>THU</code> for Thursday, <code>FRI</code> for Friday, <code>SAT</code> for Saturday, and <code>SUN</code> for Sunday. It is guaranteed that the result is unique for each case.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3485djDkxh4hhGE </span><br><span class="line">2984akDfkkkkggEdsb </span><br><span class="line">s&amp;hgsfdk </span><br><span class="line">d&amp;Hyscvnm</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">THU 14:04</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>有人给了福尔摩斯一张小纸条,要跟他约会,但是约会时间已经被加密了,现在要通过以下规则解密:</p>
<ul>
<li>输入的4个字符串分为两组,第一组用来得出日期和小时,第二组得出分钟.</li>
<li>第一组中第一对位置相同的同一大写字母(A到G)代表了日期,A表示MON,G表示SUN.</li>
<li>第一组中第二对位置相同的同一数字或者大写字母(A到N)代表了小时,0表示0点,A表示10点,N表示23点.</li>
<li>第二组中第一对位置相同的同一大写或小写字母的位置代表分钟,下标0即第0分钟,下标4则第4分钟.</li>
</ul>
<h2 id="思路">思路</h2>
<p>又是一道因为题目规则没看明白浪费了一个上午的题,原来连题目都没看懂,真的烦,明白了规则其实这道题就比较简单了,就是相对位置一路比较过去就行了,但是一定要注意每个题目限定要求.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string[] tokens = new string[4];</span><br><span class="line">    string[] result = &#123; &quot;&quot;, &quot;&quot;, &quot;&quot; &#125;;</span><br><span class="line">    int flag = 0;</span><br><span class="line">    string[] week = &#123; &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot; &#125;;</span><br><span class="line">    for (int i = 0; i &lt; tokens.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens[i] = System.Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; tokens[0].Length &amp;&amp; i &lt; tokens[1].Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (tokens[0][i] == tokens[1][i] &amp;&amp; tokens[0][i] &gt;= &#x27;A&#x27; &amp;&amp; tokens[0][i] &lt;= &#x27;G&#x27;)//规定1,一定要在A到G之间.</span><br><span class="line">        &#123;</span><br><span class="line">            result[0] = week[tokens[0][i] - &#x27;A&#x27;];</span><br><span class="line">            flag = i + 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = flag; i &lt; tokens[0].Length &amp;&amp; i &lt; tokens[1].Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //规定2,i一定要在上一个循环结束的下一个位置开始,因为现在要找在第一对相同位置之后的第二对.</span><br><span class="line">        if (tokens[0][i] == tokens[1][i] &amp;&amp; (tokens[0][i] &gt;= &#x27;0&#x27; &amp;&amp; tokens[0][i] &lt;= &#x27;9&#x27; || tokens[0][i] &gt;= &#x27;A&#x27; &amp;&amp; tokens[0][i] &lt;= &#x27;N&#x27;))</span><br><span class="line">        //规定3,判定范围不能&gt;=&#x27;0&#x27;&amp;&amp;&lt;=&#x27;N&#x27;.</span><br><span class="line">        &#123;</span><br><span class="line">            result[1] = tokens[0][i] &gt; &#x27;9&#x27; ? (tokens[0][i] - &#x27;7&#x27;).ToString() : &quot;0&quot; + tokens[0][i];</span><br><span class="line">            //规定4,不足10的数要在前面补个0.</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; tokens[2].Length &amp;&amp; i &lt; tokens[3].Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (tokens[2][i] == tokens[3][i] &amp;&amp; (tokens[2][i] &gt;= &#x27;A&#x27; &amp;&amp; tokens[2][i] &lt;= &#x27;Z&#x27; || tokens[2][i] &gt;= &#x27;a&#x27; &amp;&amp; tokens[2][i] &lt;= &#x27;z&#x27;))</span><br><span class="line">        &#123;</span><br><span class="line">            result[2] = i &lt; 10 ? &quot;0&quot; + i : i.ToString();</span><br><span class="line">            Console.WriteLine(result[0] + &quot; &quot; + result[1] + &quot;:&quot; + result[2]);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1065 A+B and C (64bit)</title>
    <url>/2019/04/23/1065-A-B-and-C-64bit/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Given three integers <em>A</em>, <em>B</em> and <em>C</em> in [−2<sup>63</sup>,2<sup>63</sup>], you are supposed to tell whether <em>A</em>+<em>B</em>&gt;<em>C</em>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>The first line of the input gives the positive number of test cases, <em>T</em> (≤10). Then <em>T</em> test cases follow, each consists of a single line containing three integers <em>A</em>, <em>B</em> and <em>C</em>, separated by single spaces.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output in one line <code>Case #X: true</code> if <em>A</em>+<em>B</em>&gt;<em>C</em>, or <code>Case #X: false</code> otherwise, where <em>X</em> is the case number (starting from 1).</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">9223372036854775807 -9223372036854775808 0</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case #1: false</span><br><span class="line">Case #2: true</span><br><span class="line">Case #3: false</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定三个大范围的整数A,B,C,要求判断A+B是否大于C</p>
<h2 id="思路">思路</h2>
<p>这道题因为范围是64位的,所以肯定不能普通整型int的,而且哪怕你定义了64位的long,当两个数都超大时,相加结果仍然会溢出.</p>
<p>那怎么办呢?</p>
<p>128位的decimal莽就完事了,毫无技术含量.</p>
<p>当然这是一种投机取巧的方法,正规的方法是通过溢出判断.</p>
<p>定义了三个long,如果A&gt;0,B&gt;0,这个时候如果他们两个数都相当庞大,相加导致溢出,我们知道,不管相加结果是多少,只要溢出了,那就肯定比C大.</p>
<p>如果A&lt;0,B&lt;0,这个时候如果他们两个数都非常小,导致相加变得更小而溢出了,我们知道,不管结果如何,只要溢出了,那就肯定比C小.</p>
<p>而正数相加溢出,结果为负数;负数相加溢出,结果为正数,我们可以通过这样来判断,结果是否大于C.</p>
<h2 id="代码">代码</h2>
<p>机智版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int T = int.Parse(Console.ReadLine());</span><br><span class="line">    for (int i = 0; i &lt; T; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        decimal A, B, C;</span><br><span class="line">        string[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">        A = decimal.Parse(tokens[0]);</span><br><span class="line">        B = decimal.Parse(tokens[1]);</span><br><span class="line">        C = decimal.Parse(tokens[2]);</span><br><span class="line">        if (A + B &gt; C ? true : false)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Case #&#123;0&#125;: true&quot;, i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Case #&#123;0&#125;: false&quot;, i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老实版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int T = int.Parse(Console.ReadLine());</span><br><span class="line">    for (int i = 0; i &lt; T; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        long A, B, C;</span><br><span class="line">        string[] tokens = System.Console.ReadLine().Split();</span><br><span class="line">        A = long.Parse(tokens[0]);</span><br><span class="line">        B = long.Parse(tokens[1]);</span><br><span class="line">        C = long.Parse(tokens[2]);</span><br><span class="line">        long sum = A + B;</span><br><span class="line">        if (A &gt; 0 &amp;&amp; B &gt; 0 &amp;&amp; sum &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Case #&#123;0&#125;: true&quot;, i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (A &lt; 0 &amp;&amp; B &lt; 0 &amp;&amp; sum &gt;= 0)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Case #&#123;0&#125;: false&quot;, i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (sum &gt; C)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;Case #&#123;0&#125;: true&quot;, i + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;Case #&#123;0&#125;: false&quot;, i + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1069 The Black Hole of Numbers</title>
    <url>/2019/04/23/1069-The-Black-Hole-of-Numbers/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number <code>6174</code> -- the <strong>black hole</strong> of 4-digit numbers. This number is named Kaprekar Constant.</p>
<p>For example, start from <code>6767</code>, we'll get:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7766 - 6677 = 1089</span><br><span class="line">9810 - 0189 = 9621</span><br><span class="line">9621 - 1269 = 8352</span><br><span class="line">8532 - 2358 = 6174</span><br><span class="line">7641 - 1467 = 6174</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p>Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case which gives a positive integer <em>N</em> in the range (0,10<sup>4</sup>).</p>
<h3 id="output-specification">Output Specification:</h3>
<p>If all the 4 digits of <em>N</em> are the same, print in one line the equation <code>N - N = 0000</code>. Else print each step of calculation in a line until <code>6174</code> comes out as the difference. All the numbers must be printed as 4-digit numbers.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6767</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7766 - 6677 = 1089</span><br><span class="line">9810 - 0189 = 9621</span><br><span class="line">9621 - 1269 = 8352</span><br><span class="line">8532 - 2358 = 6174</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2222</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2222 - 2222 = 0000</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>6174是一个黑洞数字,所有的4位数(除了4个数字一样的),经过降序,再减去升序,得到的结果再重复这个过程,最终的数字都会得到6174,现在要求把这个过程展现出来.</p>
<p>注意这里有一个坑,那就是不管你输入的数是不是4位数,展现过程中都必须显示为4位,也就是说不足4位的前面要补零.</p>
<h2 id="思路">思路</h2>
<p>这道题的难点也不是很高,只是要知道上面说的那个坑,把所有的数都补足4位就行了.</p>
<h2 id="代码">代码</h2>
<p>创建一个给字符串降序排序的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static string decreasingSort(string input)</span><br><span class="line">&#123;</span><br><span class="line">    while (input.Length != 4)//不足4位要先补0.</span><br><span class="line">    &#123;</span><br><span class="line">        input += &quot;0&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] num = input.ToCharArray();</span><br><span class="line">    Array.Sort(num);//直接升序排序.</span><br><span class="line">    Array.Reverse(num);//再反转一次,就变成降序排序了.</span><br><span class="line">    return new string(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个反转字符串的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static string Reverse(string input)</span><br><span class="line">&#123;</span><br><span class="line">    char[] num = input.ToCharArray();</span><br><span class="line">    Array.Reverse(num);</span><br><span class="line">    return new string(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string input = System.Console.ReadLine();</span><br><span class="line">    string result = &quot;&quot;;</span><br><span class="line">    string sortedInput = &quot;&quot;;</span><br><span class="line">    string reversedInput = &quot;&quot;;</span><br><span class="line">    while (result != &quot;6174&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        sortedInput = decreasingSort(input);</span><br><span class="line">        reversedInput = Reverse(sortedInput);</span><br><span class="line">        result = (int.Parse(sortedInput) - int.Parse(reversedInput)).ToString();</span><br><span class="line">        if (sortedInput == reversedInput)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125; - &#123;1&#125; = &#123;2&#125;&quot;, sortedInput, reversedInput, &quot;0000&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125; - &#123;1&#125; = &#123;2&#125;&quot;, sortedInput, reversedInput, result.Length == 4 ? result : &quot;0&quot; + result);</span><br><span class="line">        input = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1077 Kuchiguse</title>
    <url>/2019/04/26/1077-Kuchiguse/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker's personality. Such a preference is called "Kuchiguse" and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle "nyan~" is often used as a stereotype for characters with a cat-like personality:</p>
<ul>
<li>Itai nyan~ (It hurts, nyan~)</li>
<li>Ninjin wa iyada nyan~ (I hate carrots, nyan~)</li>
</ul>
<p>Now given a few lines spoken by the same character, can you find her Kuchiguse?</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line is an integer <em>N</em> (2≤<em>N</em>≤100). Following are <em>N</em> file lines of 0~256 (inclusive) characters in length, each representing a character's spoken line. The spoken lines are case sensitive.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all <em>N</em> lines. If there is no such suffix, write <code>nai</code>.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Itai nyan~</span><br><span class="line">Ninjin wa iyadanyan~</span><br><span class="line">uhhh nyan~</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nyan~</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Itai!</span><br><span class="line">Ninjinnwaiyada T_T</span><br><span class="line">T_T</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nai</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>这是我开始做PAT以来首次遇到的一道,看完完全不知道在说什么,用了谷歌翻译仍然不知道在说什么,去看了别人的博客解释才明白说的是什么的题目.直到现在,我也只是知道题目问的是什么,但是题目什么意思还没明白.</p>
<p>这道题要问的就是从字符串后面开始,最大的字符子串是什么,如果有就输出最大子串,没有就输出<strong>nai</strong>.</p>
<h2 id="思路">思路</h2>
<p>这道题写出代码比读懂题目简单多了,解决的思路很简单.</p>
<p>先建立一个记录最大子串的变量count.</p>
<p>将输入的几个字符串的第一个字符串,作为标准,将它翻转(因为翻转之后可以从头开始比较),然后对所有字符串进行翻转然后逐位字符比较,如果都一样了,count++.</p>
<p>如果比较不相等,说明最大字符子串结束,返回count.</p>
<p>这个时候就得到了最大字符子串的长度,然后用任意一个字符串s对(s.Length-count)进行截取,得到的就是字符子串了.</p>
<h2 id="代码">代码</h2>
<p>先创建一个获取最大字符子串长度的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int MaxLengthOfSubstring(string[] inputs)</span><br><span class="line">&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    char[] standard = inputs[0].ToCharArray();//建立一个标准串.</span><br><span class="line">    char[] str;</span><br><span class="line">    Array.Reverse(standard);</span><br><span class="line">    for (int i = 0; i &lt; standard.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (var input in inputs)</span><br><span class="line">        &#123;</span><br><span class="line">            str = input.ToCharArray();</span><br><span class="line">            Array.Reverse(str);//对每一个输入串进行翻转,然后比较.</span><br><span class="line">            if (str[i] != standard[i])</span><br><span class="line">            &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int count = int.Parse(Console.ReadLine());</span><br><span class="line">    string[] inputs = new string[count];</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        inputs[i] = Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">    count = MaxLengthOfSubstring(inputs);//变量重复利用.</span><br><span class="line">    string substring = inputs[0].Substring(inputs[0].Length - count);</span><br><span class="line">    Console.WriteLine(count == 0 ? &quot;nai&quot; : substring);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1081 Rational Sum</title>
    <url>/2019/04/26/1081-Rational-Sum/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Given <em>N</em> rational numbers in the form <code>numerator/denominator</code>, you are supposed to calculate their sum.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case starts with a positive integer <em>N</em> (≤100), followed in the next line <em>N</em> rational numbers <code>a1/b1 a2/b2 ...</code> where all the numerators and denominators are in the range of <strong>long int</strong>. If there is a negative number, then the sign must appear in front of the numerator.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output the sum in the simplest form <code>integer numerator/denominator</code> where <code>integer</code> is the integer part of the sum, <code>numerator</code> &lt;<code>denominator</code>, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2/5 4/15 1/30 -2/60 8/3</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1/3</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4/3 2/3</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-3">Sample Input 3:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1/3 -1/6 1/8</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-3">Sample Output 3:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7/24</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>计算分数加法,要求如下:</p>
<ul>
<li>分数的结果一定要是最简分数.</li>
<li>分子如果大于分母,则要化简为带分数,即<strong>c又a分之b</strong>的整数和分数形式,.</li>
<li>当整数为0,只输出分数部分.</li>
<li>当分数为0,只输出整数部分.</li>
<li>当都为0.输出0.</li>
</ul>
<h2 id="思路">思路</h2>
<p>这道题第一眼看到可能会觉得很乱,因为这个题不仅要求和,还要化简,化简之后还要判定分子是否大于分母,看起来觉得很乱,但是只要仔细思考,就知道,这道题的重点其实只有4个</p>
<ul>
<li>为了化简,我们需要约分,而约分要用到最大公因数,所以第一个问题是,怎么快速得到最大公因数.</li>
<li>如何进行分数的求和.</li>
<li>分子比分母大的假分数如何化简成整数和分数形式的带分数.</li>
<li>如何防止分子或者分母超出long int范围.</li>
</ul>
<p>第一个点,我们可以用<a href="https://zh.wikipedia.org/wiki/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95">辗转相除法</a>获得最大公因数,得到了最大公因数,就可以对分数进行化简.</p>
<p>第二个点,我们直接使用分数加法公式,分子交叉相乘再相加得到分子的和,分母相乘通分.</p>
<p>第三个点,我们其实并不需要判断分子是否大于分母,只要将分子除以分母作为整数部分即可,如果分子比分母小,那分子除以分母的结果就是0,而分子%分母的结果,就是新分子.</p>
<p>第四个点,为了防止溢出,分数求和之后的结果要马上进行约分化简,而不能等到所有分数相加完了再化简.</p>
<h2 id="代码">代码</h2>
<p>先创建一个获得最大公因数的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static long GetGreatestCommonDivisor(long numerator, long denominator)</span><br><span class="line">&#123;</span><br><span class="line">    return denominator == 0 ? Math.Abs(numerator) : GetGreatestCommonDivisor(denominator, numerator % denominator);</span><br><span class="line">    //辗转相除法的递归形式.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再创建一个分数求和的函数,这个函数传入两个分数,返回一个<strong>已经化简了</strong>的分数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static long[] GetRationalSum(long[] rationalSum, long[] rationalNumber)</span><br><span class="line">&#123;</span><br><span class="line">    long greatestCommonDivisor = GetGreatestCommonDivisor(rationalNumber[0], rationalNumber[1]);//取得最大公约数.</span><br><span class="line">    rationalNumber[0] = rationalNumber[0] / greatestCommonDivisor;//先将分数化简.</span><br><span class="line">    rationalNumber[1] = rationalNumber[1] / greatestCommonDivisor;</span><br><span class="line">    rationalSum[0] = rationalSum[0] * rationalNumber[1] + rationalSum[1] * rationalNumber[0];//分子交叉相乘</span><br><span class="line">    rationalSum[1] = rationalSum[1] * rationalNumber[1];//分母通分.</span><br><span class="line">    greatestCommonDivisor = GetGreatestCommonDivisor(rationalSum[0], rationalSum[1]);//获得求和结果的最大公约数.</span><br><span class="line">    rationalSum[0] = rationalSum[0] / greatestCommonDivisor;//将结果也化简.</span><br><span class="line">    rationalSum[1] = rationalSum[1] / greatestCommonDivisor;</span><br><span class="line">    return rationalSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    Console.ReadLine();//第一个数字没用到.</span><br><span class="line">    string[] inputs = Console.ReadLine().Split();//用空格分割分数.</span><br><span class="line">    long[] rationalSum = new long[2] &#123; 0, 1 &#125;;//先初始化一个存放结果的分数为0/1.</span><br><span class="line">    long[] rationalNumber = new long[2];</span><br><span class="line">    long integer = 0;</span><br><span class="line">    foreach (var input in inputs)</span><br><span class="line">    &#123;</span><br><span class="line">        rationalNumber[0] = long.Parse(input.Split(&#x27;/&#x27;)[0]);//对于每个分数,用/分割分子分母.</span><br><span class="line">        rationalNumber[1] = long.Parse(input.Split(&#x27;/&#x27;)[1]);</span><br><span class="line">        rationalSum = GetRationalSum(rationalSum, rationalNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    integer = rationalSum[0] / rationalSum[1];//获得整数部分.</span><br><span class="line">    rationalSum[0] = rationalSum[0] % rationalSum[1];//更新分子.</span><br><span class="line">    if (integer == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (rationalSum[0] == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125;/&#123;1&#125;&quot;, rationalSum[0], rationalSum[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (rationalSum[0] == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(integer);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;/&#123;2&#125;&quot;, integer, rationalSum[0], rationalSum[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1084 Broken Keyboard</title>
    <url>/2019/04/28/1084-Broken-Keyboard/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen.</p>
<p>Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or <code>_</code> (representing the space). It is guaranteed that both strings are non-empty.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7_This_is_a_test</span><br><span class="line">_hs_s_a_es</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7TI</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>键盘的某些按键坏了,导致你输入的和屏幕显示的结果不一样,现在要找出哪些键位坏了,规则如下:</p>
<ul>
<li>每一个输入字符串都只有大小写字母,数字和下划线.</li>
<li>要求输出的结果只输出大写字母,而且每个坏按键只输出一次.</li>
</ul>
<h2 id="思路">思路</h2>
<p>这道题是相当简单的一道题了,可以有两种解决思路:</p>
<ul>
<li>对于第一个字符串中的每一个字符,直接查询是否包含在第二个字符串中,如果没有,说明是坏了.</li>
<li>用第一个字符串建立一个哈希表,然后对于第二个字符串中的每一个字符,修改哈希表,剩下的没被修改的值就是坏了的按键.</li>
</ul>
<h2 id="代码">代码</h2>
<p>方法一:直接查询.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string original = System.Console.ReadLine().ToUpper();</span><br><span class="line">    string typedOut = System.Console.ReadLine().ToUpper();</span><br><span class="line">    string result = &quot;&quot;;</span><br><span class="line">    foreach (var item in original)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!typedOut.Contains(item.ToString()) &amp;&amp; !result.Contains(item.ToString()))</span><br><span class="line">        &#123;</span><br><span class="line">            //这个字符不仅要不存在第二个字符串中,还要不存在结果字符串中,否则有可能重复输出同一个按键</span><br><span class="line">            result += item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二:建立哈希表.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string original = System.Console.ReadLine().ToUpper();</span><br><span class="line">    string typedOut = System.Console.ReadLine().ToUpper();</span><br><span class="line">    string result = &quot;&quot;;</span><br><span class="line">    int[] ascii = new int[128];</span><br><span class="line">    foreach (var item in original)</span><br><span class="line">    &#123;</span><br><span class="line">        ascii[item] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    foreach (var item in typedOut)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ascii[item] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            ascii[item] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    foreach (var item in original)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ascii[item] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            result += item;</span><br><span class="line">            ascii[item] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1092 To Buy or Not to Buy</title>
    <url>/2019/04/28/1092-To-Buy-or-Not-to-Buy/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is <code>Yes</code>, please tell her the number of extra beads she has to buy; or if the answer is <code>No</code>, please tell her the number of beads missing from the string.</p>
<p>For the sake of simplicity, let's use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. For example, the 3rd string in Figure 1 is the one that Eva would like to make. Then the 1st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2nd one is not since there is no black bead and one less red bead.</p>
<figure>
<img src="https://images.ptausercontent.com/b7e2ffa6-8819-436d-ad79-a41263abe914.jpg" alt="Figure 1" /><figcaption aria-hidden="true">Figure 1</figcaption>
</figure>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print your answer in one line. If the answer is <code>Yes</code>, then also output the number of extra beads Eva has to buy; or if the answer is <code>No</code>, then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ppRYYGrrYBR2258</span><br><span class="line">YrR8RrY</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes 8</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ppRYYGrrYB225</span><br><span class="line">YrR8RrY</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No 2</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>Eva想要买各种颜色的珠子做手链,但是商店老板只卖整条的,不肯单卖,所以现在要判断,老板提供的整条手链里面有没有我们需要的全部珠子:</p>
<ul>
<li>如果有,就输出<strong>Yes 剩下用不上的珠子的数目</strong>.</li>
<li>如果没有,就输出<strong>No 缺少了多少颗需要的珠子</strong>.</li>
</ul>
<h2 id="思路">思路</h2>
<p>这道题很明显应该用哈希表来解决.老板有的珠子,我们就在哈希表对应的位置+1;我们需要的珠子,就在对应的哈希表位置-1.</p>
<p>最终哈希表内如果有负数,说明老板的珠子不能满足我们的需要,各个负数之和就是我们缺少的珠子的数目;</p>
<p>如果没有负数,说明老板的珠子能够满足我们的需求,哈希表内各个正数之和就是我们用不上的多余的珠子数目;</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string shopBeads = Console.ReadLine();</span><br><span class="line">    string needBeads = Console.ReadLine();</span><br><span class="line">    int missingBeads = 0;</span><br><span class="line">    int extraBeads = 0;</span><br><span class="line">    int[] colors = new int[128];</span><br><span class="line">    foreach (var bead in shopBeads)</span><br><span class="line">    &#123;</span><br><span class="line">        colors[bead]++;</span><br><span class="line">    &#125;</span><br><span class="line">    foreach (var bead in needBeads)</span><br><span class="line">    &#123;</span><br><span class="line">        colors[bead]--;</span><br><span class="line">    &#125;</span><br><span class="line">    foreach (var bead in shopBeads + needBeads)</span><br><span class="line">    &#123;</span><br><span class="line">        if (colors[bead] &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            extraBeads += colors[bead];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            missingBeads += colors[bead];</span><br><span class="line">        &#125;</span><br><span class="line">        colors[bead] = 0;//已经算过的哈希表位置要将它置零,避免重复计算.</span><br><span class="line">    &#125;</span><br><span class="line">    if (missingBeads &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;No &#123;0&#125;&quot;, 0 - missingBeads);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Yes &#123;0&#125;&quot;, extraBeads);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1100 Mars Numbers</title>
    <url>/2019/04/29/1100-Mars-Numbers/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>People on Mars count their numbers with base 13:</p>
<ul>
<li>Zero on Earth is called "tret" on Mars.</li>
<li>The numbers 1 to 12 on Earth is called "jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec" on Mars, respectively.</li>
<li>For the next higher digit, Mars people name the 12 numbers as "tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou", respectively.</li>
</ul>
<p>For examples, the number 29 on Earth is called "hel mar" on Mars; and "elo nov" on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (&lt;100). Then <em>N</em> lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each number, print in a line the corresponding number in the other language.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">29</span><br><span class="line">5</span><br><span class="line">elo nov</span><br><span class="line">tam</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hel mar</span><br><span class="line">may</span><br><span class="line">115</span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>火星的数字是13进制的,并且他们的数字并不用0~9来表示,而是:</p>
<ul>
<li>当数字是1~12时,用jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec来表示1~12.</li>
<li>当数字超过12,有两位时,高位用tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou来表示1~12.</li>
<li>0用tret表示.</li>
<li>当数字是13,也即火星上的"10"时,只用一个"tam"表示,"20"用"hel"表示,也就是说,当火星数字是10,20,30这种整数时,后面的零不用写.</li>
</ul>
<p>现在要你设计一个翻译程序,如果输入的是地球整数,那就把它翻译成13进制的火星数字;如果输入是火星数字,就把它翻译成10进制的地球数字.</p>
<h2 id="思路">思路</h2>
<p>这道题要考虑的情况相当相当多,既要进制转换,又要字符替换,还要对不同长度的数字进行不同情况的分析.</p>
<p>用火星数字获取火星文字,可以直接使用字符串数组,下标表示火星数字,数组存放着火星对应的文字.</p>
<p>用火星文字获取火星数字,可以使用泛型字典,通过火星文字直接获得对应的火星数字.</p>
<p>而这道题明确告诉我们火星的文字只有高低两位,所以判断的时候就比较方便.</p>
<h2 id="代码">代码</h2>
<p>首先我们先实现一个地球数字转换成火星文字的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static string translateToMars(int EarthNumber)</span><br><span class="line">&#123;</span><br><span class="line">    if (EarthNumber == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;tret&quot;;//如果地球数字输入0直接返回,不用判断了.</span><br><span class="line">    &#125;</span><br><span class="line">    string[] lowerDigits = &#123; &quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot; &#125;;</span><br><span class="line">    string[] higherDigit = &#123; &quot;&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot; &#125;;</span><br><span class="line">    int[] number = &#123; 0, 0 &#125;;//number用于存放10进制转换成13进制的结果,结果只有两位,高位和低位.</span><br><span class="line">    int i = 1;</span><br><span class="line">    while (EarthNumber != 0)//进行进制转换.</span><br><span class="line">    &#123;</span><br><span class="line">        number[i--] = EarthNumber % 13;</span><br><span class="line">        EarthNumber /= 13;</span><br><span class="line">    &#125;</span><br><span class="line">    if (number[0] == 0)//如果进制转换的结果的第一位是0,例如05,07,09</span><br><span class="line">    &#123;</span><br><span class="line">        return lowerDigits[number[1]];//那就直接返回低位number[1]对应的数字的火星文字.</span><br><span class="line">    &#125;</span><br><span class="line">    else//如果进制转换的结果第一位不是0</span><br><span class="line">    &#123;</span><br><span class="line">        if (number[1] == 0)//如果第二位是0,例如10,20,30</span><br><span class="line">        &#123;</span><br><span class="line">            return higherDigit[number[0]];</span><br><span class="line">            //那就直接输出高位number[0]对应的数字的火星文字,因为火星文字的低位0是不输出的.</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return higherDigit[number[0]] + &quot; &quot; + lowerDigits[number[1]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再实现一个火星文字转地球数字的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int translateToEarth(string MarsNumber)</span><br><span class="line">&#123;</span><br><span class="line">    //先创建两个字典用于通过火星文字得到火星数字.</span><br><span class="line">    Dictionary&lt;string, int&gt; lowerDigits = new Dictionary&lt;string, int&gt;() &#123;</span><br><span class="line">        &#123;&quot;tret&quot;,0&#125;,&#123;&quot;jan&quot;,1&#125;,&#123;&quot;feb&quot;,2&#125;,&#123;&quot;mar&quot;,3&#125;,&#123;&quot;apr&quot;,4&#125;,&#123;&quot;may&quot;,5&#125;,</span><br><span class="line">        &#123;&quot;jun&quot;,6&#125;,&#123;&quot;jly&quot;,7&#125;,&#123;&quot;aug&quot;,8&#125;,&#123;&quot;sep&quot;,9&#125;,&#123;&quot;oct&quot;,10&#125;,&#123;&quot;nov&quot;,11&#125;,&#123;&quot;dec&quot;,12&#125;&#125;;</span><br><span class="line">    Dictionary&lt;string, int&gt; higherDigit = new Dictionary&lt;string, int&gt;() &#123;</span><br><span class="line">        &#123;&quot;tam&quot;,1&#125;,&#123;&quot;hel&quot;,2&#125;,&#123;&quot;maa&quot;,3&#125;,&#123;&quot;huh&quot;,4&#125;,&#123;&quot;tou&quot;,5&#125;,</span><br><span class="line">        &#123;&quot;kes&quot;,6&#125;,&#123;&quot;hei&quot;,7&#125;,&#123;&quot;elo&quot;,8&#125;,&#123;&quot;syy&quot;,9&#125;,&#123;&quot;lok&quot;,10&#125;,&#123;&quot;mer&quot;,11&#125;,&#123;&quot;jou&quot;,12&#125;&#125;;</span><br><span class="line">    string[] numbers = MarsNumber.Split();//尝试将火星文字进行分割.</span><br><span class="line">    if (numbers.Length == 1)//如果长度是1,说明只输入了一个单词.</span><br><span class="line">    &#123;</span><br><span class="line">        if (lowerDigits.ContainsKey(numbers[0]))//如果这个单词在低位字典里,那就返回对应数字.</span><br><span class="line">        &#123;</span><br><span class="line">            return lowerDigits[numbers[0]];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return higherDigit[numbers[0]] * 13;//如果在高位字典里,那就返回13乘以这个数字.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //如果长度是2,那就说明输入了两个单词,那就高位的乘以13,低位的直接获取.</span><br><span class="line">        return higherDigit[numbers[0]] * 13 + lowerDigits[numbers[1]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    int count = int.Parse(Console.ReadLine());</span><br><span class="line">    while (count-- != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        string input = Console.ReadLine();</span><br><span class="line">        if (int.TryParse(input, out result))//尝试转换成整型,如果成功那就是地球数字,如果失败那就是火星文字.</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(translateToMars(result));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(translateToEarth(input));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1108 Finding Average</title>
    <url>/2019/04/30/1108-Finding-Average/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>The basic task is simple: given <em>N</em> real numbers, you are supposed to calculate their average. But what makes it complicated is that some of the input numbers might not be legal. A <strong>legal</strong> input is a real number in [−1000,1000] and is accurate up to no more than 2 decimal places. When you calculate the average, those illegal numbers must not be counted in.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤100). Then <em>N</em> numbers are given in the next line, separated by one space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each illegal input number, print in a line <code>ERROR: X is not a legal number</code> where <code>X</code> is the input. Then finally print in a line the result: <code>The average of K numbers is Y</code> where <code>K</code> is the number of legal inputs and <code>Y</code> is their average, accurate to 2 decimal places. In case the average cannot be calculated, output <code>Undefined</code> instead of <code>Y</code>. In case <code>K</code> is only 1, output <code>The average of 1 number is Y</code> instead.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">5 -3.2 aaa 9999 2.3.4 7.123 2.35</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: aaa is not a legal number</span><br><span class="line">ERROR: 9999 is not a legal number</span><br><span class="line">ERROR: 2.3.4 is not a legal number</span><br><span class="line">ERROR: 7.123 is not a legal number</span><br><span class="line">The average of 3 numbers is 1.38</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">aaa -9999</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: aaa is not a legal number</span><br><span class="line">ERROR: -9999 is not a legal number</span><br><span class="line">The average of 0 numbers is Undefined</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>任务很简单,就是算所有数的平均数,但是要求是只算所有"合法"的数的平均数,规则为:</p>
<ul>
<li>输入的数如果不是有理数,不合法.</li>
<li>输入的数如果大于1000或者小于-1000,不合法.</li>
<li>输入的数如果小数点后超过2位,不合法.</li>
</ul>
<p>输出规则为:</p>
<ul>
<li>如果有不合法的数,那就先逐行依次输出 <code>ERROR: X is not a legal number</code></li>
<li>如果合法数为0,那就输出<code>The average of 0 numbers is Undefined</code></li>
<li>如果合法数为1,那就输出<code>The average of 1 number is Y</code>,注意这里的number没有加s.</li>
<li>剩余情况,就输出<code>The average of K numbers is Y</code>,注意,平均数规定要精确到小数点后两位.</li>
</ul>
<h2 id="思路">思路</h2>
<p>这道题难度不高,我们要做的其实只有三件事情:</p>
<ul>
<li>判断输入的某个数是否合法.</li>
<li>把不合法的数收集起来,然后输出.</li>
<li>记录合法数的和与合法数的数量,求平均值.</li>
</ul>
<p>对于收集不合法的数,我们可以使用泛型队列,只要判断不合法,就将它入队,等到全部判断完了,再将不合法的数出队,这样可以保证顺序不出错.</p>
<h2 id="代码">代码</h2>
<p>先实现一个用于判断输入是否合法的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static bool IsLegalInput(string input)</span><br><span class="line">&#123;</span><br><span class="line">    double result = 0;</span><br><span class="line">    if (double.TryParse(input, out result))//使用TryParse函数尝试转换,转换失败说明绝对不是合法数字,转换成功会将转换结果赋值给result.</span><br><span class="line">    &#123;</span><br><span class="line">        if (result &lt; -1000 || result &gt; 1000)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            //到了这个位置,开始判断是否是在小数点后两位之内,如果字符串的长度减去小数点的下标位置大于3,说明小数点后面不止两位了.</span><br><span class="line">            //这里要注意,要用input判断而是不result来判断,因为类似1.000000这种字符串转换成double型的result后会直接变成1,所以要直接用字符串来做判断.</span><br><span class="line">            //如果indexOf(&#x27;.&#x27;)的结果是-1那说明没有小数点,肯定是合法数字.</span><br><span class="line">            if (input.IndexOf(&#x27;.&#x27;) &gt; 0 &amp;&amp; input.ToString().Length - input.ToString().IndexOf(&#x27;.&#x27;) &gt; 3)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int count = int.Parse(Console.ReadLine());</span><br><span class="line">    int legalCount = 0;</span><br><span class="line">    double legalSum = 0;</span><br><span class="line">    string[] inputs = Console.ReadLine().Split();</span><br><span class="line">    Queue&lt;string&gt; illegalInput = new Queue&lt;string&gt;();</span><br><span class="line">    foreach (var input in inputs)</span><br><span class="line">    &#123;</span><br><span class="line">        if (IsLegalInput(input))</span><br><span class="line">        &#123;</span><br><span class="line">            legalSum += double.Parse(input);</span><br><span class="line">            legalCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            illegalInput.Enqueue(input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (illegalInput.Count != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;ERROR: &#123;0&#125; is not a legal number&quot;, illegalInput.Dequeue());</span><br><span class="line">    &#125;</span><br><span class="line">    if (legalCount == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;The average of 0 numbers is Undefined&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (legalCount == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;The average of 1 number is &#123;0&#125;&quot;, legalSum.ToString(&quot;0.00&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    if (legalCount &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;The average of &#123;0&#125; numbers is &#123;1&#125;&quot;, legalCount, (legalSum / legalCount).ToString(&quot;0.00&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1112 Stucked Keyboard</title>
    <url>/2019/05/01/1112-Stucked-Keyboard/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>On a broken keyboard, some of the keys are always stucked. So when you type some sentences, the characters corresponding to those keys will appear repeatedly on screen for <em>k</em> times.</p>
<p>Now given a resulting string on screen, you are supposed to list all the possible stucked keys, and the original string.</p>
<p>Notice that there might be some characters that are typed repeatedly. The stucked key will always repeat output for a fixed <em>k</em> times whenever it is pressed. For example, when <em>k</em>=3, from the string <code>thiiis iiisss a teeeeeest</code> we know that the keys <code>i</code> and <code>e</code> might be stucked, but <code>s</code> is not even though it appears repeatedly sometimes. The original string could be <code>this isss a teest</code>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the 1st line gives a positive integer <em>k</em> (1&lt;<em>k</em>≤100) which is the output repeating times of a stucked key. The 2nd line contains the resulting string on screen, which consists of no more than 1000 characters from {a-z}, {0-9} and <code>_</code>. It is guaranteed that the string is non-empty.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the possible stucked keys, in the order of being detected. Make sure that each key is printed once only. Then in the next line print the original string. It is guaranteed that there is at least one stucked key.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">caseee1__thiiis_iiisss_a_teeeeeest</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ei</span><br><span class="line">case1__this_isss_a_teest</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>在一个坏掉的键盘上有一些按键是卡住的,所以当我们输入句子的时候,总有一些按键会固定重复出现K次,每按一下这个坏了的按键,字符就会重复出现K次,现在给定一个重复次数K,和给一个结果字符串,尝试找出粘键的按键和原始的字符串,每一个结果字符串保证至少有一个坏掉的按键.</p>
<p>注意,上面的例子中,e和i是坏掉的按键,因为每次按一下e和i,他们都会重复3次,但是s却不是,因为它并没有每按一次s就重复3次.</p>
<h2 id="思路">思路</h2>
<p>这道题需要记录每个按键是否坏掉,也就是说我们要记录字符串里每个字符的具体情况,所以可以使用哈希表.</p>
<p>哈希表内每个字符对应的位置的值,代表着这个按键的情况:</p>
<ul>
<li><p>如果还没判断,按键默认值就是0.</p></li>
<li><p>如果判断出这个按键没有坏,就将值设置为-1.</p></li>
<li><p>判断按键已经卡住了,就把按键设置为1.</p></li>
</ul>
<p>要如何判断按键是否卡住,可以设置一个变量为nowKey,表示现在正在判断的按键字符;再设置一个nowKeyCount变量表示这个正在判断的字符已经连续出现的次数,如果nowKeyCount%K==0表示这个nowKey重复出现了k的倍数次,是坏键;如果不等于0,说明nowKey出现的次数不是k的倍数,这个键不是坏键.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int repeatedlyTimes = int.Parse(Console.ReadLine());//重复次数.</span><br><span class="line">    string str = Console.ReadLine();//输入的结果字符串.</span><br><span class="line">    int[] characters = new int[128];//哈希表.</span><br><span class="line">    char nowKey = str[0];//当前判断的按键,先将它设置为字符串第一个字符.</span><br><span class="line">    int nowKeyCount = 0;//当前判断按键出现的次数.</span><br><span class="line">    string brokenKeys = &quot;&quot;;//坏掉的按键结果.</span><br><span class="line">    string originalString = &quot;&quot;;//原始字符串.</span><br><span class="line">    foreach (var character in (str + &quot; &quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        //for循环的每一个字符Character会比nowKey领先一个位置,为了保证最后一个字符的结果能得到比较,要在str字符串后面再加一个位置.</span><br><span class="line">        if (character == nowKey)</span><br><span class="line">        &#123;</span><br><span class="line">            nowKeyCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (nowKeyCount % repeatedlyTimes == 0 &amp;&amp; characters[nowKey] != -1)//characters[nowKey] != -1是为了保证已经被判断没坏的字符不能被重新设置为坏了.</span><br><span class="line">            &#123;</span><br><span class="line">                characters[nowKey] = 1;//坏了.</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                characters[nowKey] = -1;//没坏.</span><br><span class="line">            &#125;</span><br><span class="line">            nowKey = character;//判断结束,将新的character赋给nowKey,成为新的判断对象.</span><br><span class="line">            nowKeyCount = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; str.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (characters[str[i]] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!brokenKeys.Contains(str[i].ToString()))//保证坏了的键只出现一次.</span><br><span class="line">            &#123;</span><br><span class="line">                brokenKeys += str[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i += repeatedlyTimes - 1;//让i往后跳repeatedlyTimes - 1个位置,例如重复次数为3,那就让i往后跳2个位置,这样就可以保证按键只输出一次.</span><br><span class="line">            originalString += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            originalString += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(brokenKeys);</span><br><span class="line">    Console.WriteLine(originalString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1116 Come on! Let&#39;s C</title>
    <url>/2019/05/03/1116-Come-on-Let-s-C/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>"Let's C" is a popular and fun programming contest hosted by the College of Computer Science and Technology, Zhejiang University. Since the idea of the contest is for fun, the award rules are funny as the following:</p>
<ul>
<li>0.The Champion will receive a "Mystery Award" (such as a BIG collection of students' research papers...).</li>
<li>1.Those who ranked as a prime number will receive the best award -- the Minions (小黄人)!</li>
<li>2.Everyone else will receive chocolates.</li>
</ul>
<p>Given the final ranklist and a sequence of contestant ID's, you are supposed to tell the corresponding awards.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10<sup>4</sup>), the total number of contestants. Then N lines of the ranklist follow, each in order gives a contestant's ID (a 4-digit number). After the ranklist, there is a positive integer K followed by K query ID's.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each query, print in a line <code>ID: award</code> where the award is <code>Mystery Award</code>, or <code>Minion</code>, or <code>Chocolate</code>. If the ID is not in the ranklist, print <code>Are you kidding?</code>instead. If the ID has been checked before, print <code>ID: Checked</code>.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1111</span><br><span class="line">6666</span><br><span class="line">8888</span><br><span class="line">1234</span><br><span class="line">5555</span><br><span class="line">0001</span><br><span class="line">6</span><br><span class="line">8888</span><br><span class="line">0001</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">8888</span><br><span class="line">2222</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8888: Minion</span><br><span class="line">0001: Chocolate</span><br><span class="line">1111: Mystery Award</span><br><span class="line">2222: Are you kidding?</span><br><span class="line">8888: Checked</span><br><span class="line">2222: Are you kidding?</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定一个排名列表,再给定一个查询列表,输出查询列表中每个id对应的排名所能获得的奖品,规则如下:</p>
<ul>
<li>排名列表的排名从1开始</li>
<li>如果id排名第一,将获得<code>Mystery Award</code></li>
<li>如果id排名是素数,将获得<code>Minion</code></li>
<li>其他名次,将获得<code>Chocolate</code></li>
<li>如果查询用户没有名次,输出<code>Are you kidding?</code></li>
<li>如果查询的用户已经查询过了,输出<code>Checked</code></li>
</ul>
<h2 id="思路">思路</h2>
<p>这道题是相对简单的一道题,用泛型字典做哈希表,存放用户id和对应的排名值,如果被查询过了,就将排名值改为-1.</p>
<h2 id="代码">代码</h2>
<p>先实现一个检查素数函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static bool IsPrime(int input)</span><br><span class="line">&#123;</span><br><span class="line">    if (input &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i &lt;= Math.Sqrt(input); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (input % i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    Dictionary&lt;string, int&gt; rankList = new Dictionary&lt;string, int&gt;();</span><br><span class="line">    int count = int.Parse(Console.ReadLine());</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rankList.Add(Console.ReadLine(), i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    count = int.Parse(Console.ReadLine());</span><br><span class="line">    string queryID;</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        queryID = Console.ReadLine();</span><br><span class="line">        if (!rankList.ContainsKey(queryID))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125;: Are you kidding?&quot;, queryID);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (rankList[queryID] == -1)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;&#123;0&#125;: Checked&quot;, queryID);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (rankList[queryID] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;&#123;0&#125;: Mystery Award&quot;, queryID);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (IsPrime(rankList[queryID]))</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;&#123;0&#125;: Minion&quot;, queryID);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;&#123;0&#125;: Chocolate&quot;, queryID);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rankList[queryID] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1120 Friend Numbers</title>
    <url>/2019/05/03/1120-Friend-Numbers/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Two integers are called "friend numbers" if they share the same sum of their digits, and the sum is their "friend ID". For example, 123 and 51 are friend numbers since 1+2+3 = 5+1 = 6, and 6 is their friend ID. Given some numbers, you are supposed to count the number of different frind ID's among them.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N. Then N positive integers are given in the next line, separated by spaces. All the numbers are less than 10<sup>4</sup>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print in the first line the number of different frind ID's among the given integers. Then in the second line, output the friend ID's in increasing order. The numbers must be separated by exactly one space and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">123 899 51 998 27 33 36 12</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 6 9 26</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>如果两个整数的各位数字之和相同,那这两个数字就是"友谊数",他们的和叫做"友谊ID".现在给定一个数字序列,让你输出他们的各个友谊ID的总数,并且在下一行从小到大输出各个友谊ID.</p>
<h2 id="思路">思路</h2>
<p>这道题很多人会直接用哈希表set来做,但是其实还有更简单的方法,因为这些输入的整数不会大于10000,也就是说最大也就是9999,而友谊id最大也就可能是4个9即36,所以我们完全可以直接用整型数组做哈希表而不用直接创建set.</p>
<h2 id="代码">代码</h2>
<p>先创建一个逐位数字求和的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int GetDigitsSum(int input)</span><br><span class="line">&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    if (input == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while (input != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        result += input % 10;</span><br><span class="line">        input /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">    string[] inputs = Console.ReadLine().Split();</span><br><span class="line">    int[] friendIDs = new int[40];//创建一个长度为40的整型数组做哈希表,其实只要33个位置就够了.</span><br><span class="line">    int friendID = 0;</span><br><span class="line">    int count = 0;</span><br><span class="line">    foreach (var input in inputs)</span><br><span class="line">    &#123;</span><br><span class="line">        friendID = GetDigitsSum(int.Parse(input));</span><br><span class="line">        if (friendIDs[friendID] != 1)</span><br><span class="line">        &#123;</span><br><span class="line">            friendIDs[friendID] = 1;//将对应的ID位置数值值为1.</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(count);</span><br><span class="line">    for (int i = 0; i &lt; friendIDs.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (friendIDs[i] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            count--;</span><br><span class="line">            Console.Write(count == 0 ? i.ToString() : i + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1124 Raffle for Weibo Followers</title>
    <url>/2019/05/04/1124-Raffle-for-Weibo-Followers/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>John got a full mark on PAT. He was so happy that he decided to hold a raffle（抽奖） for his followers on Weibo -- that is, he would select winners from every N followers who forwarded his post, and give away gifts. Now you are supposed to help him generate the list of winners.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives three positive integers M (≤ 1000), N and S, being the total number of forwards, the skip number of winners, and the index of the first winner (the indices start from 1). Then M lines follow, each gives the nickname (a nonempty string of no more than 20 characters, with no white space or return) of a follower who has forwarded John's post.</p>
<p>Note: it is possible that someone would forward more than once, but no one can win more than once. Hence if the current candidate of a winner has won before, we must skip him/her and consider the next one.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print the list of winners in the same order as in the input, each nickname occupies a line. If there is no winner yet, print <code>Keep going...</code> instead.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9 3 2</span><br><span class="line">Imgonnawin!</span><br><span class="line">PickMe</span><br><span class="line">PickMeMeMeee</span><br><span class="line">LookHere</span><br><span class="line">Imgonnawin!</span><br><span class="line">TryAgainAgain</span><br><span class="line">TryAgainAgain</span><br><span class="line">Imgonnawin!</span><br><span class="line">TryAgainAgain</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PickMe</span><br><span class="line">Imgonnawin!</span><br><span class="line">TryAgainAgain</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 5</span><br><span class="line">Imgonnawin!</span><br><span class="line">PickMe</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Keep going...</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>john想在微博搞一个粉丝抽奖,现在要做一个抽奖程序,要求如下:</p>
<ul>
<li><p>先输入三个数M,N,S M是指粉丝总人数. N是指下一个粉丝所在的位置的间隔. S是指第一个中奖的位置(从1开始数). 例如9 3 2是指粉丝一共9个人,第2个人就是第一个中奖的位置,间隔是3即第2个往后数3个人也就是第5个粉丝,第8个粉丝也中奖位置.</p></li>
<li><p>粉丝名单里面有的粉丝可能不止出现了一次,如果选中的粉丝已经中奖过了,则往后推一个位置.</p></li>
<li><p>如果没有粉丝中奖,则输出<code>Keep going...</code></p></li>
</ul>
<h2 id="思路">思路</h2>
<p>这道题难度不算高,要做的只是判断某个粉丝是否中过奖,中过了就跳到下一个就好了.这里可以有两个思路来判断粉丝是否中过奖,1可以用哈希表将中奖的粉丝设置为1,然后每次检查哈希表中的值是否为1来判断是否曾经中奖;2可以用泛型列表List的Contains()函数来判断粉丝是否已经存在于获奖名单里.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string line = Console.ReadLine();</span><br><span class="line">    int totalForwards = int.Parse(line.Split()[0]);</span><br><span class="line">    int skipNumber = int.Parse(line.Split()[1]);</span><br><span class="line">    int firstWinner = int.Parse(line.Split()[2]);</span><br><span class="line">    if (totalForwards &lt; firstWinner)//没有中奖者的情况只有一种,那就是粉丝数比第一个获奖位置还要小.</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Keep going...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;string&gt; winners = new List&lt;string&gt;();//用来判断粉丝曾经是否已经获奖</span><br><span class="line">        string follower;</span><br><span class="line">        for (int i = 1; i &lt;= totalForwards ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            follower = Console.ReadLine();</span><br><span class="line">            if (i == firstWinner)</span><br><span class="line">            &#123;</span><br><span class="line">                if (winners.Contains(follower))//如果粉丝已经获奖过,那就将位置+1;</span><br><span class="line">                &#123;</span><br><span class="line">                    firstWinner += 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    winners.Add(follower);//如果没有获奖那就将他添加入获奖名单.</span><br><span class="line">                    Console.WriteLine(follower);</span><br><span class="line">                    firstWinner += skipNumber;//将获奖位置向后挪动skipNumber个位置.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1128 N Queens Puzzle</title>
    <url>/2019/05/05/1128-N-Queens-Puzzle/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>The "eight queens puzzle" is the problem of placing eight chess queens on an 8×8 chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general <em>N</em> queens problem of placing <em>N</em> non-attacking queens on an <em>N</em>×<em>N</em> chessboard. (From Wikipedia - "Eight queens puzzle".)</p>
<p>Here you are NOT asked to solve the puzzles. Instead, you are supposed to judge whether or not a given configuration of the chessboard is a solution. To simplify the representation of a chessboard, let us assume that no two queens will be placed in the same column. Then a configuration can be represented by a simple integer sequence (<em>Q</em>1,<em>Q</em>2,⋯,<em>QN</em>), where <em>Qi</em> is the row number of the queen in the <em>i</em>-th column. For example, Figure 1 can be represented by (4, 6, 8, 2, 7, 1, 3, 5) and it is indeed a solution to the 8 queens puzzle; while Figure 2 can be represented by (4, 6, 7, 2, 8, 1, 9, 5, 3) and is NOT a 9 queens' solution.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="https://images.ptausercontent.com/7d0443cf-5c19-4494-98a6-0f0f54894eaa.jpg" alt="8q.jpg" /></th>
<th></th>
<th style="text-align: center;"><img src="https://images.ptausercontent.com/d187e37a-4eb8-4215-8e2c-040a73c5c8d8.jpg" alt="9q.jpg" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Figure 1</td>
<td></td>
<td style="text-align: center;">Figure 2</td>
</tr>
</tbody>
</table>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains several test cases. The first line gives an integer <em>K</em> (1&lt;<em>K</em>≤200). Then <em>K</em> lines follow, each gives a configuration in the format "<em>N</em> <em>Q</em>1 <em>Q</em>2 ... <em>QN</em>", where 4≤<em>N</em>≤1000 and it is guaranteed that 1≤<em>Qi</em>≤<em>N</em> for all <em>i</em>=1,⋯,<em>N</em>. The numbers are separated by spaces.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each configuration, if it is a solution to the <em>N</em> queens problem, print <code>YES</code> in a line; or <code>NO</code> if not.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">8 4 6 8 2 7 1 3 5</span><br><span class="line">9 4 6 7 2 8 1 9 5 3</span><br><span class="line">6 1 5 2 6 4 3</span><br><span class="line">5 1 3 5 2 4</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定一个棋盘序列,让你判断这个棋盘上的皇后位置是否符合正确摆放方法: &gt; 棋盘的横,竖,对角线都没有重复的皇后.</p>
<h2 id="思路">思路</h2>
<p>这道题如果想要用多重循环暴力解法,那肯定是走错路了,这里给一个另类的解法,使用哈希表.</p>
<p>我们知道,一旦一个棋盘的某一个位置放了一个皇后,那这个皇后所在的行,列,上对角线,下对角线就不能再次使用了,所以我们可以将行,列,对角线都作为哈希表,一旦某个棋子有了一个位置,那哈希表内对应的行,列,对角线都置为-1,下一个棋子只要判断自己所在的行,列,对角线的哈希表值是否为-1来判断自己是否已经重复.</p>
<h2 id="代码">代码</h2>
<p>先实现最关键的判断输入的棋盘是否符合正确摆放位置的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static bool IsNQueensPuzzleSolution(string chessInfo)</span><br><span class="line">&#123;</span><br><span class="line">    string[] chessBoard = chessInfo.Split();</span><br><span class="line">    int queensCount = int.Parse(chessBoard[0].ToString());//皇后的数量.</span><br><span class="line">    int[] rows = new int[queensCount + 1];//行哈希表,如果皇后在某行,哈希表内的位置即设置为-1.</span><br><span class="line">    int[] columns = new int[queensCount + 1];//题目已经明确列是不会重复的,所以这里可以不写列哈希表.</span><br><span class="line">    int[] upDiagonal = new int[2 * queensCount];//上对角线哈希表.</span><br><span class="line">    int[] downDiagonal = new int[2 * queensCount + 1];//下对角线哈希表.</span><br><span class="line">    for (int i = 1; i &lt; chessBoard.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int row = int.Parse(chessBoard[i].ToString());//获取行号和列号.</span><br><span class="line">        int column = i;</span><br><span class="line">        if (rows[row] == -1 || columns[column] == -1 || upDiagonal[queensCount + row - column] == -1 || downDiagonal[row + column] == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            //上对角线的特点:行-列始终相等.</span><br><span class="line">            //下对角线的特点:行+列始终相等.</span><br><span class="line">            //因为row-column可能为负数,而下标不能为负,所以要加上queensCount让它始终为正.</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            rows[row] = -1;</span><br><span class="line">            columns[column] = -1;</span><br><span class="line">            upDiagonal[queensCount + (row - column)] = -1;</span><br><span class="line">            downDiagonal[row + column] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int lines = int.Parse(Console.ReadLine());</span><br><span class="line">    for (int i = 0; i &lt; lines; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string chessInfo = Console.ReadLine();</span><br><span class="line">        Console.WriteLine(IsNQueensPuzzleSolution(chessInfo) ? &quot;YES&quot; : &quot;NO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1132 Cut Integer</title>
    <url>/2019/05/06/1132-Cut-Integer/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Cutting an integer means to cut a K digits lone integer Z into two integers of (K/2) digits long integers A and B. For example, after cutting Z = 167334, we have A = 167 and B = 334. It is interesting to see that Z can be devided by the product of A and B, as 167334 / (167 × 334) = 3. Given an integer Z, you are supposed to test if it is such an integer.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20). Then N lines follow, each gives an integer Z (10 ≤ Z &lt;2<sup>31</sup>). It is guaranteed that the number of digits of Z is an even number.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print a single line <code>Yes</code> if it is such a number, or <code>No</code> if not.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">167334</span><br><span class="line">2333</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定一个偶数位的整数,平均分割成两部分,如果这两部分相乘,可以被这个偶数位整数整除,则输出Yse,否则输出No.</p>
<h2 id="思路">思路</h2>
<p>这道题就体现出面向对象语言的优势了,直接字符串分割转整型就完事了,根本不需要除法逐位取数字.</p>
<p>判断的时候要注意一点0不能被模,所以首先要先把0排除了,而因为这个输入整数是大于等于10的,所以只有后半部分有可能是0.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int count = int.Parse(Console.ReadLine());</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string input = Console.ReadLine();</span><br><span class="line">        int firstPart = int.Parse(input.Substring(0, input.Length / 2));</span><br><span class="line">        int secondPart = int.Parse(input.Substring(input.Length / 2, input.Length / 2));</span><br><span class="line">        Console.WriteLine(secondPart != 0 &amp;&amp; int.Parse(input) % (firstPart * secondPart) == 0 ? &quot;Yes&quot; : &quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1136 A Delayed Palindrome</title>
    <url>/2019/05/06/1136-A-Delayed-Palindrome/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Consider a positive integer <em>N</em> written in standard notation with <em>k</em>+1 digits <em>ai</em> as <em>ak</em>⋯<em>a1</em> <em>a0</em> with 0≤<em>ai</em>&lt;10 for all <em>i</em> and <em>ak</em>&gt;0. Then <em>N</em> is <strong>palindromic</strong> if and only if <em>ai</em>=<em>ak</em>−<em>i</em> for all <em>i</em>. Zero is written 0 and is also palindromic by definition.</p>
<p>Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. Such number is called <strong>a delayed palindrome</strong>. (Quoted from <a href="https://en.wikipedia.org/wiki/Palindromic_number" class="uri">https://en.wikipedia.org/wiki/Palindromic_number</a> )</p>
<p>Given any positive integer, you are supposed to find its paired palindromic number.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case which gives a positive integer no more than 1000 digits.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print line by line the process of finding the palindromic number. The format of each line is the following:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A + B = C</span><br></pre></td></tr></table></figure>
<p>where <code>A</code> is the original number, <code>B</code> is the reversed <code>A</code>, and <code>C</code> is their sum. <code>A</code> starts being the input number, and this process ends until <code>C</code> becomes a palindromic number -- in this case we print in the last line <code>C is a palindromic number.</code>; or if a palindromic number cannot be found in 10 iterations, print <code>Not found in 10 iterations.</code> instead.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">97152</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">97152 + 25179 = 122331</span><br><span class="line">122331 + 133221 = 255552</span><br><span class="line">255552 is a palindromic number.</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">196</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">196 + 691 = 887</span><br><span class="line">887 + 788 = 1675</span><br><span class="line">1675 + 5761 = 7436</span><br><span class="line">7436 + 6347 = 13783</span><br><span class="line">13783 + 38731 = 52514</span><br><span class="line">52514 + 41525 = 94039</span><br><span class="line">94039 + 93049 = 187088</span><br><span class="line">187088 + 880781 = 1067869</span><br><span class="line">1067869 + 9687601 = 10755470</span><br><span class="line">10755470 + 07455701 = 18211171</span><br><span class="line">Not found in 10 iterations.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定一个不大于1000位的正整数A,尝试寻找一个回文数:</p>
<ol type="1">
<li>如果这个数本身就是回文数,输出<code>A is a palindromic number.</code></li>
<li>如果这个数不是回文数,则寻找它的延迟回文数:
<ul>
<li>将这个数A与它的反转数B相加,判断它们的和C是否为回文数,如果是,则C为延迟回文数,输出<code>C is a palindromic number.</code>.</li>
<li>如果C不是回文数,输出<code>A + B = C</code>,将C赋值给A,重复这个过程.</li>
<li>10步之内如果没有找到延迟回文数,则输出<code>Not found in 10 iterations.</code></li>
</ul></li>
<li>0也是回文数.</li>
</ol>
<h2 id="思路">思路</h2>
<p>这道题非常有意思,看似是考察回文数,但实际上是考察<strong>大数相加</strong>,因为输入的数有可能有好几百位的长度,绝对不能够用整型相加得到和,肯定会溢出的.</p>
<p>大数相加的操作比较简单,就是将两个数字都作为字符串来相加,因为它们的长度都是相同的,所以直接逐位相加就可以了,得到的结果仍作为字符串.</p>
<p>另一个比较坑的点,题目没有说如果输入是回文数那就可以直接输出了,我当时还以为还要再加一次才行,例如输入0,我还以为要输出: &gt; 0+0=0 &gt; 0 is a palindromic number.</p>
<p>结果并不用,直接输出结果就可以了.</p>
<h2 id="代码">代码</h2>
<p>先实现一个<a href="https://jiayaoo3o.github.io/2019/04/23/1069-The-Black-Hole-of-Numbers/">1069 The Black Hole of Numbers</a>就已经写过的反转字符串的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static string Reverse(string input)</span><br><span class="line">&#123;</span><br><span class="line">    char[] num = input.ToCharArray();</span><br><span class="line">    Array.Reverse(num);</span><br><span class="line">    return new string(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再实现一个用于将大数相加的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static string AddStrNumber(string input, string reversed)</span><br><span class="line">&#123;</span><br><span class="line">    string sum = &quot;&quot;;</span><br><span class="line">    int flag = 0;//记录进位信息.</span><br><span class="line">    for (int i = input.Length - 1; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = (((int)input[i] - 48 + (int)reversed[i] - 48 + flag) % 10) + sum;</span><br><span class="line">        flag = ((int)input[i] - 48 + (int)reversed[i] - 48 + flag) / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag == 1 ? &quot;1&quot; + sum : sum;//最终结果如果有进位得在前面加1.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string input = Console.ReadLine();</span><br><span class="line">    string sum = &quot;&quot;;</span><br><span class="line">    string reversed;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        reversed = Reverse(input);</span><br><span class="line">        if (input == reversed)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125; is a palindromic number.&quot;, input);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = AddStrNumber(input, reversed);</span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&quot;, input, reversed, sum);</span><br><span class="line">        input = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;Not found in 10 iterations.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1140 Look-and-say Sequence</title>
    <url>/2019/05/09/1140-Look-and-say-Sequence/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Look-and-say sequence is a sequence of integers as the following:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D, D1, D111, D113, D11231, D112213111, ...</span><br></pre></td></tr></table></figure>
<p>where <code>D</code> is in [0, 9] except 1. The (n+1)st number is a kind of description of the nth number. For example, the 2nd number means that there is one <code>D</code> in the 1st number, and hence it is <code>D1</code>; the 2nd number consists of one <code>D</code>(corresponding to <code>D1</code>) and one 1 (corresponding to 11), therefore the 3rd number is <code>D111</code>; or since the 4th number is <code>D113</code>, it consists of one <code>D</code>, two 1's, and one 3, so the next number must be <code>D11231</code>. This definition works for <code>D</code> = 1 as well. Now you are supposed to calculate the Nth number in a look-and-say sequence of a given digit <code>D</code>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case, which gives <code>D</code> (in [0, 9]) and a positive integer N (≤ 40), separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>Print in a line the Nth number in a look-and-say sequence of <code>D</code>.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 8</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1123123111</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>外观序列是指通过将序列的每个数的数目都"说出来"而形成的序列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D</span><br><span class="line">D1 //D有1个</span><br><span class="line">D111 //D有1个,1有1个</span><br><span class="line">D113 //D有1个,1有3个</span><br><span class="line">D11231 //D有1个,1有2个,3有1个</span><br><span class="line">D112213111 //D有1个,1有2个,2有1个,3有1个,1有1个</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>现在输入一个数D和一个重复次数N,要求输出第N个重复序列.</p>
<h2 id="思路">思路</h2>
<p>对于每一次循环的一个序列,比较当前的字符和上一个字符是否相同,如果相同那就让计数器+1,不一样的时候说明这个字符已经完结了,将这个答案拼接到一个临时结果上,最后将临时结果再次放入循环.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    string[] lines = Console.ReadLine().Split();</span><br><span class="line">    string input = lines[0];</span><br><span class="line">    int count = int.Parse(lines[1]);</span><br><span class="line">    System.Text.StringBuilder result = new System.Text.StringBuilder(&quot;&quot;);</span><br><span class="line">    while (--count &gt; 0)//这里使用--count,即假设输入的是8,只需要循环7次,因为输入的D已经算是第一次了.</span><br><span class="line">    &#123;</span><br><span class="line">        int nowCount = 1;</span><br><span class="line">        for (int i = 1; i &lt; input.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (input[i] == input[i - 1])</span><br><span class="line">            &#123;</span><br><span class="line">                nowCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                result.Append(input[i - 1] + nowCount.ToString());</span><br><span class="line">                //将result定义成StringBuilder可以大幅度降低花费的时间.</span><br><span class="line">                //如果直接用string类型的result+=input[i - 1] + nowCount.ToString()来拼接结果,将会导致超时!!!</span><br><span class="line">                nowCount = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.Append(input[input.Length - 1] + nowCount.ToString());</span><br><span class="line">        input = result.ToString();//将临时结果赋值给input进行下次循环.</span><br><span class="line">        result.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1144 The Missing Number</title>
    <url>/2019/05/09/1144-The-Missing-Number/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>Given N integers, you are supposed to find the smallest positive integer that is NOT in the given list.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10<sup>5</sup>). Then N integers are given in the next line, separated by spaces. All the numbers are in the range of <strong>int</strong>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>Print in a line the smallest positive integer that is missing from the input list.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">5 -25 9 6 1 3 4 2 5 17</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>给定N个数，要求找出不在列表内的最小正整数.</p>
<h2 id="思路">思路</h2>
<p>这道题如果没有理解题目就会跑偏了,题目要求<strong>找出不在列表内的最小正整数</strong>,也就是说如果1不在列表里,那1就是我们要找的那个最小正整数.</p>
<p>不管输入的列表有多少个数，我们都只需要在循环内从1开始比较，只要发现某个数不存在,那就输出这个数.</p>
<p>但是因为输入的数字列表是无序的,所以我们要将这些数字放入一个集合中.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">    HashSet&lt;string&gt; inputsInfo = new HashSet&lt;string&gt;(Console.ReadLine().Split());</span><br><span class="line">    //用hashset来接收输入的数据.</span><br><span class="line">    for (int i = 1; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!inputsInfo.Contains(i.ToString()))//从1开始,如果i不在集合内那就是要找的数.</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>1152 Google Recruitment</title>
    <url>/2019/05/09/1152-Google-Recruitment/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>In July 2004, Google posted on a giant billboard along Highway 101 in Silicon Valley (shown in the picture below) for recruitment. The content is super-simple, a URL consisting of the first 10-digit prime found in consecutive digits of the natural constant <em>e</em>. The person who could find this prime number could go to the next step in Google's hiring process by visiting this website.</p>
<figure>
<img src="https://images.ptausercontent.com/57148679-d574-4f49-b048-775c6c07791c.jpg" alt="prime.jpg" /><figcaption aria-hidden="true">prime.jpg</figcaption>
</figure>
<p>The natural constant <em>e</em> is a well known transcendental number（超越数）. The first several digits are: <em>e</em> = 2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642<strong>7427466391</strong>932003059921... where the 10 digits in bold are the answer to Google's question.</p>
<p>Now you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case first gives in a line two positive integers: L (≤ 1,000) and K (&lt; 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, output <code>404</code> instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 5</span><br><span class="line">23654987725541023819</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">49877</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 3</span><br><span class="line">2468024680</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">404</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="题意">题意</h2>
<p>找出给定长度的正整数L内的第一个长度为K的素数.</p>
<ul>
<li>正整数内的0也算作长度,例如200236内找出第一个长度为4的素数,那0023就是答案.</li>
<li>如果没有要求的素数,输出404.</li>
</ul>
<h2 id="思路">思路</h2>
<p>这道题还是相对简单的,因为主要的考点还是在与判断某个数是不是素数,而判断素数的函数已经写过很多次了.</p>
<p>另一方面要获得指定长度的字符串,只需要用字符串的Substring()方法就可以了.</p>
<h2 id="代码">代码</h2>
<p>先实现一个判断是否为素数的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static bool IsPrime(int input)</span><br><span class="line">&#123;</span><br><span class="line">    if (input &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i &lt;= Math.Sqrt(input); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (input % i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int primeLength = int.Parse(Console.ReadLine().Split()[1]);</span><br><span class="line">    string input = Console.ReadLine();</span><br><span class="line">    for (int i = 0; i &lt;= input.Length - primeLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (IsPrime(int.Parse(input.Substring(i, primeLength))))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(input.Substring(i, primeLength));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;404&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>121.买卖股票的最佳时机</title>
    <url>/2019/05/12/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 </span><br><span class="line">注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>定义两个变量最大利润和最小价格,在一个循环内比较每一天的最大利润和当前的最大利润相比谁更大,如果今天的利润比最大利润还大,那就让今天的利润成为最大利润.今天的最大利润等于今天的价格减去最小价格.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int MaxProfit(int[] prices)</span><br><span class="line">&#123;</span><br><span class="line">    if (prices.Length &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int minPrice = prices[0], maxProfit = 0;</span><br><span class="line">    for (int i = 0; i &lt; prices.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxProfit = Math.Max(maxProfit, prices[i] - minPrice);//得到这么多天以来的最大利润.</span><br><span class="line">        minPrice = Math.Min(minPrice, prices[i]);//得到这么多天以来的最小价格.</span><br><span class="line">    &#125;</span><br><span class="line">    return maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>125.验证回文串</title>
    <url>/2019/05/13/125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题还是比较简单的,因为只考虑字母和数字字符,剩下的都不考虑,所以解题步骤只有3步:</p>
<ul>
<li>将输入字符串全部转化为小写.</li>
<li>逐个验证是否是字母或者数字,如果是就假如新的字符串.</li>
<li>验证这个新的字符串是否为回文.</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsPalindrome(string s)</span><br><span class="line">&#123;</span><br><span class="line">    s = s.ToLower();</span><br><span class="line">    System.Text.StringBuilder result = new System.Text.StringBuilder();</span><br><span class="line">    foreach (var c in s)</span><br><span class="line">    &#123;</span><br><span class="line">        if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27; || c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            result.Append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; result.Length / 2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (result[i] != result[result.Length - 1 - i])</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>13.罗马数字转整数</title>
    <url>/2019/05/01/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>
<p><strong>示例 5:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>从右往左逐个比较,如果左边的数比右边的数大,那就加上这个数;如果左边的数比右边的数小,那就减去这个数.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int RomanToInt(string s)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Dictionary&lt;char, int&gt; romanNumber = new Dictionary&lt;char, int&gt; &#123;</span><br><span class="line">        &#123; &#x27;I&#x27;, 1 &#125;,&#123; &#x27;V&#x27;, 5 &#125;,&#123; &#x27;X&#x27;, 10 &#125;,&#123; &#x27;L&#x27;, 50 &#125;,&#123; &#x27;C&#x27;, 100 &#125;,&#123; &#x27;D&#x27;, 500 &#125;,&#123; &#x27;M&#x27;, 1000 &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    int result = romanNumber[s[s.Length - 1]];//先拿出倒数第一位的数.</span><br><span class="line">    for (int i = s.Length - 2; i &gt;= 0; i--)//从倒数第二位开始.</span><br><span class="line">    &#123;</span><br><span class="line">        if (romanNumber[s[i]] &lt; romanNumber[s[i + 1]])</span><br><span class="line">        &#123;</span><br><span class="line">            result -= romanNumber[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            result += romanNumber[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>136.只出现一次的数字</title>
    <url>/2019/05/13/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题的一个巧妙的解法就是使用异或来计算,两个数异或会产生以下的特点:</p>
<ul>
<li>任何数与0异或会得到它本身.</li>
<li>任何数与自己异或会得到0.</li>
</ul>
<p>而题目已经说明只有某个元素出现了一次,其余的都出现了两次,也就是说这些出现偶数次的元素异或结果都会等于0,唯独只出现一次的这个元素与剩下的0异或得到本身.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int SingleNumber(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    int n = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n = n ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>14.最长公共前缀</title>
    <url>/2019/05/02/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>""</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code></p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>用第一个字符串作为基准字符串,用剩下的字符串与之逐位比较.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public string LongestCommonPrefix(string[] strs)</span><br><span class="line">&#123;</span><br><span class="line">    if (strs == null || strs.Length == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (strs.Length == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; strs[0].Length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt; strs.Length; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (strs[j].Length &lt;= i || strs[0][i] != strs[j][i])</span><br><span class="line">            &#123;</span><br><span class="line">                return strs[0].Substring(0, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return strs[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>141.环形链表</title>
    <url>/2019/05/13/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<span id="more"></span>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="思路">思路</h2>
<p>对于链表得环问题,我们可以使用快慢指针来解决.</p>
<p>想象两个人在环形跑道上同向跑步,一个快一个慢,那快的和慢的总会相遇的.我们利用这一个点,定义一个快指针,一个慢指针,如果它们两个相遇了,那说明链表有环.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool HasCycle(ListNode head)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    while (fast != null &amp;&amp; fast.next != null)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast.next.next;//快指针每次走两步.</span><br><span class="line">        slow = slow.next;//慢指针每次走一步.</span><br><span class="line">        if (fast == slow)//两者相遇.</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>160.相交链表</title>
    <url>/2019/05/14/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" /></a></p>
<p>在节点 c1 开始相交。</p>
<span id="more"></span>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img" /></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img" /></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；</span><br><span class="line">在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img" /></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>
<h2 id="思路">思路</h2>
<p>要判断两个链表是否有交点的难点在于,由于两条链表的长度不一样,所以无法简单的做到一一比较,因此解题思路就是先将两个链表的起始长度设置为一样,然后逐个比较.</p>
<h2 id="代码">代码</h2>
<p>先实现一个计算链表长度的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int CountNode(ListNode list)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (list != null)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        list = list.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode GetIntersectionNode(ListNode headA, ListNode headB)</span><br><span class="line">&#123;</span><br><span class="line">    if (headB == null || headA == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int CountA = CountNode(headA);</span><br><span class="line">    int CountB = CountNode(headB);</span><br><span class="line">    if (CountA &gt; CountB)//如果A比B长</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; CountA - CountB; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            headA = headA.next;//那就将A变得和B一样短.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; CountB - CountA; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            headB = headB.next;//否则就将B变得和A一样短.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (headA != null)</span><br><span class="line">    &#123;</span><br><span class="line">        if (headA == headB)</span><br><span class="line">        &#123;</span><br><span class="line">            return headA;//当两者长度一样时,开始逐位比较,相等说明相交.</span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>167.两数之和 II - 输入有序数组</title>
    <url>/2019/05/15/167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p>
<p><strong>说明:</strong></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>由于题目已经明说这个数组是一个有序数组,并且一定会有一个答案,那我们就可以使用双指针法来得到结果.</p>
<p>设置一个头指针和一个尾指针,分别指向首元素的尾元素,然后让头尾相加.</p>
<p>如果结果太大,那就说明尾元素过大了,让尾指针前进一步.</p>
<p>如果结果太小,那就说明头指针太小了,让头指针往后一步.</p>
<p>这样逐步逼近,就能得到结果.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] TwoSumII(int[] numbers, int target)</span><br><span class="line">&#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = numbers.Length - 1;</span><br><span class="line">    while (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        if (numbers[left] + numbers[right] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            return new int[] &#123; left + 1, right + 1 &#125;;//下标要加一.</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (numbers[left] + numbers[right] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new int[] &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>169.求众数</title>
    <url>/2019/05/15/169-%E6%B1%82%E4%BC%97%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题由于题目已经明确了众数是出现次数大于n/2次,所以就可以得到一个规律:只要将这个数组进行排序,那数组中间的那个数无论如何都会是众数,因为众数占据了长度的一半以上.</p>
<p>所以这道题可以有两种解法:</p>
<ul>
<li>直接返回排序之后数组的一半位置的数.</li>
<li>用一个哈希表记录数字出现的次数,如果多于一半就是众数</li>
</ul>
<h2 id="代码">代码</h2>
<p>排序法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int MajorityElement(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    Array.Sort(nums);</span><br><span class="line">    return nums[nums.Length / 2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希表法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int MajorityElement(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    Dictionary&lt;int, int&gt; numsInfo = new Dictionary&lt;int, int&gt;();</span><br><span class="line">    foreach (var num in nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (numsInfo.ContainsKey(num))</span><br><span class="line">        &#123;</span><br><span class="line">            numsInfo[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            numsInfo.Add(num, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (numsInfo[num] &gt; nums.Length / 2)</span><br><span class="line">        &#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>172.阶乘后的零</title>
    <url>/2019/05/15/172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 0</span><br><span class="line">解释: 3! = 6, 尾数中没有零。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 1</span><br><span class="line">解释: 5! = 120, 尾数中有 1 个零.</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> 你算法的时间复杂度应为 <em>O</em>(log <em>n</em>)</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这是相当有难度的一道题,要明白这个简单的解法并不简单.</p>
<p>首先先把这个数的阶乘暴力算出来,然后从后往前数多少个零这种做法肯定是不可取的,肯定是有更巧妙的方法的.</p>
<p>先来观察结果的尾数中0的个数与什么有关.</p>
<p>阶乘是指将1到n之间的所有数都乘起来,而在这些数之中,想要得到尾数0,则必然需要2x5才会有0,要么就是2的倍数乘以5或者5的倍数会得到0. 例如:</p>
<blockquote>
<p>6!=1x2x3x4x5x6</p>
</blockquote>
<p>就是通过2x5来得到尾数0的,所以我们可以得知,尾数0的个数受到2和5的个数限制.</p>
<p>而另一方面,我们通过公式可以得知,2的个数必然是会比5的个数多的,例如上面的式子,可以拆成:</p>
<blockquote>
<p>6!=1x2x3x(2x2)x5x(2x3)</p>
</blockquote>
<p>所以我们可以进一步得出结论,尾数0的个数受限于5的个数,有多少个5,就总会有多少个2来和它组成一个10来产生一个0.</p>
<p>到了这里我们的目标就从算出尾数有多少个0,变成了给定的阶乘数里面包含了多少个5.例如30!里面能凑出7个5,分别是</p>
<blockquote>
<p><strong>5</strong> , 2x<strong>5</strong> ,3x<strong>5</strong> , 4x<strong>5</strong> , <strong>5</strong>x<strong>5</strong> , 6x<strong>5</strong></p>
</blockquote>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int TrailingZeroes(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (n &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        count = count + n / 5;</span><br><span class="line">        n = n / 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>190. 颠倒二进制位</title>
    <url>/2019/05/16/190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 00000010100101000001111010011100</span><br><span class="line">输出: 00111001011110000010100101000000</span><br><span class="line">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class="line">因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：10111111111111111111111111111111</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span><br><span class="line">因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这是一道考察位运算的题目,通过左移和右移来得到结果.</p>
<p>可以先创建一个结果变量,用于存放输入变量最右边一位的信息,然后让结果变量不断左移,输入变量不断右移,这样循环32次,就可以将输入变量颠倒了.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public uint reverseBits(uint n)</span><br><span class="line">&#123;</span><br><span class="line">    uint result = 0;</span><br><span class="line">    for (int i = 0; i &lt; 32; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result &lt;&lt;= 1;//先左移一个位置,让出最右边空位.</span><br><span class="line">        result = result + n &amp; 1;//用与运算得到n最右边一位,交给result.</span><br><span class="line">        n &gt;&gt;= 1;//n右移一位,挤掉最右边的位置.</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>191.位1的个数</title>
    <url>/2019/05/19/191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量">汉明重量</a>）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题解法有很多,这里举两个.</p>
<p>一种是最基本的暴力解法,就是将数转换成二进制字符串,一个循环内数有多少个1.</p>
<p>另一种就是通过判断数字的最后一位是不是1,然后让整个数不断右移,每次都判断最右边的那个数字,想要判断最后一位是不是1,可以通过与运算.</p>
<h2 id="代码">代码</h2>
<p>转换成字符串法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int HammingWeight(uint n)</span><br><span class="line">&#123;</span><br><span class="line">   string s = Convert.ToString(n, 2);</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = 0; i &lt; s.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[i] == &#x27;1&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右移法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int HammingWeight(uint n)</span><br><span class="line">&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; 32; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((n &amp; 1) == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>198.打家劫舍</title>
    <url>/2019/05/20/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题是一道典型的动态规划题目.</p>
<p>可以创建一个数组sum[],动态地记录偷或者不偷这一家房子会得到的最高金额.</p>
<p>如果决定偷,那sum[i]=sum[i-2]+nums[i].</p>
<p>如果决定不偷,那这个位置的最高金额和上一个位置的一样sum[i]=sum[i-1].</p>
<p>判断偷不偷的依据是看两者谁提供的金额更高.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int Rob(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    if (nums == null || nums.Length == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums.Length == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return nums[0];</span><br><span class="line">    &#125;</span><br><span class="line">    int[] sum = new int[nums.Length];</span><br><span class="line">    sum[0] = nums[0];</span><br><span class="line">    sum[1] = Math.Max(nums[0], nums[1]);</span><br><span class="line">    for (int i = 2; i &lt; sum.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = Math.Max(sum[i - 1], sum[i - 2] + nums[i]);//判断偷和不偷得到的最高金额.</span><br><span class="line">    &#125;</span><br><span class="line">    return sum[sum.Length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>20.有效的括号</title>
    <url>/2019/05/03/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个只包括 <code>(</code>，<code>)</code>，<code>&#123;</code>，<code>&#125;</code>，<code>[</code>，<code>]</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol type="1">
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 5:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题一个简洁的解法就是使用栈.只要属于左括号的,我们就将它入栈;只要是属于右括号的,我们就将栈中的元素取出,看看两者是不是一对,如果不是,说明不是有效的括号;</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsValid(string s)</span><br><span class="line">&#123;</span><br><span class="line">    Stack&lt;char&gt; stack = new Stack&lt;char&gt;();</span><br><span class="line">    for (int i = 0; i &lt; s.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[i] == &#x27;(&#x27; || s[i] == &#x27;&#123;&#x27; || s[i] == &#x27;[&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.Push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (stack.Count == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                char symbol = stack.Pop();</span><br><span class="line">                if (s[i] == &#x27;)&#x27; &amp;&amp; symbol != &#x27;(&#x27; || s[i] == &#x27;]&#x27; &amp;&amp; symbol != &#x27;[&#x27; || s[i] == &#x27;&#125;&#x27; &amp;&amp; symbol != &#x27;&#123;&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return stack.Count == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2019优质产品年度盘点</title>
    <url>/2019/12/27/2019%E4%BC%98%E8%B4%A8%E4%BA%A7%E5%93%81%E5%B9%B4%E5%BA%A6%E7%9B%98%E7%82%B9/</url>
    <content><![CDATA[<p>最近看到很多节目都在搞年度盘点 , 那我也来盘点一下2019年我遇到的值得称道的年度产品.</p>
<blockquote>
<p>年度最佳软件 : scoop</p>
</blockquote>
<blockquote>
<p>年度最佳笔记应用 : notion</p>
</blockquote>
<blockquote>
<p>年度最佳编辑器 : VSCode</p>
</blockquote>
<blockquote>
<p>年度最佳markdown编辑器 : Typora</p>
</blockquote>
<blockquote>
<p>年度最佳在线交友平台 : Github</p>
</blockquote>
<blockquote>
<p>年度最佳浏览器 : 新Microsoft Edge</p>
</blockquote>
<blockquote>
<p>年度最佳在线付费服务 : Office 365</p>
</blockquote>
<blockquote>
<p>年度最佳键盘输入体验 : 将CapsLock键映射为Ctrl</p>
</blockquote>
<blockquote>
<p>年度最佳鼠标输入体验 : 将前进键+左键/右键映射为切换桌面</p>
</blockquote>
<blockquote>
<p>年度最佳运动鞋 : 态极1.0Plus</p>
</blockquote>
<blockquote>
<p>年度最高性价比价格敏感人群无线蓝牙耳机 : QCY T5</p>
</blockquote>
]]></content>
      <categories>
        <category>个人安利</category>
      </categories>
      <tags>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>202.快乐数</title>
    <url>/2019/05/20/202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 19 输出: true 解释: 1<sup>2</sup> + 9<sup>2</sup> = 82 8<sup>2</sup> + 2<sup>2</sup>= 68 6<sup>2 </sup>+ 8<sup>2</sup> = 100 1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2 </sup>= 1</p>
</blockquote>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题要算平方和不难,唯一要注意的就是,什么时候循环退出返回false,因为如果这个数不是快乐数,那就会一直循环下去.</p>
<p>这里选择使用哈希集来存储出现过的数,如果某个非快乐数已经出现过了,那说明已经进入循环了.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsHappy(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    HashSet&lt;int&gt; used = new HashSet&lt;int&gt;();</span><br><span class="line">    while (!used.Contains(result))</span><br><span class="line">    &#123;</span><br><span class="line">        used.Add(result);</span><br><span class="line">        result = 0;</span><br><span class="line">        while (n != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            result = result + (n % 10) * (n % 10);</span><br><span class="line">            n = n / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        n = result;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>203.删除链表中的节点</title>
    <url>/2019/05/22/203-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>删除链表中等于给定值 <strong>val</strong> 的所有节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题可以用两种解法解决.</p>
<ul>
<li>直接用最普通的循环方法,在一个循环内判断链表中的某个数是否与val相同,然后删去相同节点.</li>
<li>用递归方法来解决.</li>
</ul>
<p>这里重点讲解一下递归解决这道题的思路.</p>
<p>首先我们用递归函数的时候,要明确的知道这个函数是干嘛的,<strong>并且坚信它已经可以实现这个功能</strong>,所以到了这道题,首先我们要明确知道,这个题目要求的方法是"删除链表中定值等于val的节点,并且<strong>返回删除后的链表</strong>".所以我们可以得到下面这个函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode RemoveElements(ListNode head, int val)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先不管里面是怎么实现的,现在我们要做的是<strong>坚信这个函数已经实现了这个功能</strong>.</p>
<p>然后,我们要找出递归函数的出口,即终止条件,也就是说当递归到了什么程度的时候,可以结束.</p>
<p>可以想到,当head到了最小情况,也就是为null的时候,可以直接返回null结束了.所以head==null就是终止条件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode RemoveElements(ListNode head, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (head == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来,我们就要将问题逐步分解为子问题,将递归范围逐步减小.</p>
<p>想一下,如果一条长度为4个节点的链表,放入我们的函数,将会如何操作.注意这个时候不要想递归是如何实现的,而是要坚信现在的函数已经可以实现这个功能了.</p>
<p>这个时候会有两种情况:</p>
<ol type="1">
<li>这个4个节点的链表的第一个节点就是要删除的节点.这个时候我们只要放弃掉第一个节点,将剩下的三个节点作为一条新的链表,继续放入我们的函数中进行判断即可.所以现在代码应该是这样的:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode RemoveElements(ListNode head, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (head == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (head.val == val)//如果是要删除的.</span><br><span class="line">    &#123;</span><br><span class="line">        return RemoveElements(head.next, val);//那就把第一个节点扔掉,将剩下的三个节点作为一个新的链表,继续放入函数判断.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>这个4个节点的链表的第一个节点不是我们要删除的节点,这个时候我们保留第一个节点,将剩下的的3个节点作为一个新的链表,继续放入函数中进行判断.这个时候代码就会成为这样:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode RemoveElements(ListNode head, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (head == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (head.val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        return RemoveElements(head.next, val);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        head.next = RemoveElements(head.next, val);//保留第一个节点head,将剩下的三个节点作为一个新的链表放入函数进行判断,并且将结果接到头节点后面.</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这里,整个递归就已经完成了.</p>
<h2 id="代码">代码</h2>
<p>普通循环法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode RemoveElements(ListNode head, int val)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode p = new ListNode(-1)</span><br><span class="line">    &#123;</span><br><span class="line">        next = head</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode h = p;</span><br><span class="line">    while (p.next != null)</span><br><span class="line">    &#123;</span><br><span class="line">        if (p.next.val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return h.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode RemoveElements(ListNode head, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (head == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (head.val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        return RemoveElements(head.next, val);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        head.next = RemoveElements(head.next, val);</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>205.同构字符串</title>
    <url>/2019/05/23/205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定两个字符串 <strong><em>s</em></strong> 和 <strong>t</strong>，判断它们是否是同构的。</p>
<p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong>t</strong> ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> 你可以假设 <strong><em>s</em></strong> 和 <strong>t</strong> 具有相同的长度。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>既然同构的s和t有着一一对应的关系,应该使用泛型字典来存储这样的一一对应关系.</p>
<p>因为我们知道,如果s,和t长度相同却不构成一对一关系,那就只可能是一对多,多对一,多对多关系,所以我们在一个循环之内一定可以判断两者是否同构.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsIsomorphic(string s, string t)</span><br><span class="line">&#123;</span><br><span class="line">    Dictionary&lt;char, char&gt; strInfo = new Dictionary&lt;char, char&gt;();</span><br><span class="line">    for (int i = 0; i &lt; s.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!strInfo.ContainsKey(s[i]))//如果字典里面没有s[i].</span><br><span class="line">        &#123;</span><br><span class="line">            if (strInfo.ContainsValue(t[i]))//但是已经存在了与之对应的t[i],说明产生了多对一关系.</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            strInfo.Add(s[i], t[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (strInfo[s[i]] != t[i])//如果字典里面已经有了s[i],就看看t[i]是否与之配对.</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>206.反转链表</title>
    <url>/2019/05/24/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题可以使用迭代和递归两种形式来反转链表,先说迭代:</p>
<p>用迭代来反转单链表,也就相当于将每一个节点的头节点,放到自己的尾节点来,所以步骤应该是这样的:</p>
<ol type="1">
<li>将原链表头节点的尾部进行临时保存,防止断链丢失所有数据.</li>
<li>取出头节点,将null节点接入头节点,成为新链.</li>
<li>再将刚刚临时保存的链表头节点取出,将新链接入此头节点尾部,再次成为新链.</li>
<li>重复以上步骤直到临时保存的链表为null.</li>
</ol>
<p>用递归来反转链表,就要按照递归的解题步骤,找到递归的几个要素:</p>
<ol type="1">
<li><p>首先要坚信我们的函数已经可以实现所需功能,哪怕它还没写完,但是我们要明确这个函数已经可以实现这个功能了,所以我们先写出这个已经实现功能的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode head)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>找出递归结束的条件.这道题显然我们可以知道,当链表的长度为1时,不需要反转了,直接返回它本身就可以了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode head)</span><br><span class="line">&#123;</span><br><span class="line">    if (head == null || head.next == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接下来我们要做的就是找出怎么将这个问题化为它的子问题,可以知道,假如现在的链表是这样的:</p>
<blockquote>
<p>1-&gt;2-&gt;3-&gt;4</p>
</blockquote>
<p>那假如我们将它的头节点后面进行反转,那后面那部分链表将会变成</p>
<blockquote>
<p>1-&gt;2&lt;-3&lt;-4</p>
</blockquote>
<p>1(head)还是头节点,它的下一个节点还是2(head.next),但是后面的部分已经反转完成了,所以现在要做的就是将2(head.next)的下一个节点变为1(head),而将1(head)的下一个节点变为null,所以这时候代码应该是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode head)</span><br><span class="line">&#123;</span><br><span class="line">    if (head == null || head.next == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newLinkedList = ReverseList(head.next);//接收已经反转了的链表.</span><br><span class="line">    head.next.next = head;//将2(head.next)的下一个节点(next)变为1(head).</span><br><span class="line">    head.next = null;//将1(head)的下一个节点变为null.</span><br><span class="line">    return newLinkedList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="代码">代码</h2>
<p>迭代版本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode head)</span><br><span class="line">&#123;</span><br><span class="line">    if (head == null || head.next == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newLinkedList = null;//创建一个新的链表.</span><br><span class="line">    while (head != null)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode tempNode = head.next;//创建临时链表存放头节点的尾巴.</span><br><span class="line">        head.next = newLinkedList;//将新链表接到头节点后面.</span><br><span class="line">        newLinkedList = head;//再次成为新链表.</span><br><span class="line">        head = tempNode;//将临时链表覆盖原链表.</span><br><span class="line">    &#125;</span><br><span class="line">    return newLinkedList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归版本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode head)</span><br><span class="line">&#123;</span><br><span class="line">    if (head == null || head.next == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newLinkedList = ReverseList(head.next);//接收已经反转了的链表.</span><br><span class="line">    head.next.next = head;//将2(head.next)的下一个节点(next)变为1(head).</span><br><span class="line">    head.next = null;//将1(head)的下一个节点变为null.</span><br><span class="line">    return newLinkedList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>21.合并两个有序链表</title>
    <url>/2019/05/04/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>创建一条新的链表,然后逐个比较两个链表的节点大小,谁的节点小就将这个节点接到新链表后面,然后往后移动.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode MergeTwoLists(ListNode l1, ListNode l2)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode node = new ListNode(0);</span><br><span class="line">    ListNode head = node;</span><br><span class="line">    while (l1 != null &amp;&amp; l2 != null)</span><br><span class="line">    &#123;</span><br><span class="line">        if (l1.val &lt;= l2.val)</span><br><span class="line">        &#123;</span><br><span class="line">            node.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            node.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    node.next = l1 != null ? l1 : l2;</span><br><span class="line">    return head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>217.存在重复元素</title>
    <url>/2019/05/24/217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题解决的方法有非常多,但是比较快的做法都是先将数组排序,因为排序之后相同元素就一定会挨着,比较好找.</p>
<p>可以直接比较两个相邻的数是否相等,或者也可以使用哈希集合来判断某个数据是否已经出现过.</p>
<p>两者提交结果耗时都差不多.</p>
<h2 id="代码">代码</h2>
<p>直接循环比较相邻元素法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool ContainsDuplicate(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    if (nums.Length &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    Array.Sort(nums);</span><br><span class="line">    for (int i = 1; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[i] == nums[i - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用哈希集合来判断当前数字是否已经存在过:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool ContainsDuplicate(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    if (nums.Length &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;int&gt; numSet = new HashSet&lt;int&gt;();</span><br><span class="line">    foreach (var num in nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (numSet.Contains(num))</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            numSet.Add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>225.用队列实现栈</title>
    <url>/2019/05/25/225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) -- 元素 x 入栈</li>
<li>pop() -- 移除栈顶元素</li>
<li>top() -- 获取栈顶元素</li>
<li>empty() -- 返回栈是否为空</li>
</ul>
<p><strong>注意:</strong></p>
<ul>
<li>你只能使用队列的基本操作-- 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>用队列实现栈方法比较简单.栈的每一个出栈元素都是最后的元素,但是队列的出队元素是第一个元素,所以要做的就是设法将队列每一个入队的元素移到队头.</p>
<p>所以要做的就是每当有一个元素入队,就将队列里在它前面的元素全部出队一次再入队一次.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyStack</span><br><span class="line">&#123;</span><br><span class="line">    Queue&lt;int&gt; queue = new Queue&lt;int&gt;();</span><br><span class="line">    public MyStack() &#123; &#125;</span><br><span class="line">    public void Push(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        queue.Enqueue(x);</span><br><span class="line">        for (int i = 0; i &lt; queue.Count - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.Enqueue(queue.Dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        return queue.Dequeue();</span><br><span class="line">    &#125;</span><br><span class="line">    public int Top()</span><br><span class="line">    &#123;</span><br><span class="line">        return queue.Peek();</span><br><span class="line">    &#125;</span><br><span class="line">    public bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return queue.Count &gt; 0 ? false : true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>231.2的幂</title>
    <url>/2019/05/26/231-2%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: true</span><br><span class="line">解释: 20 = 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br><span class="line">解释: 24 = 16</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 218</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这一题可真是个神仙题目,如果会解那就非常简洁,如果不会解那就得暴力判断.</p>
<p>一个神奇而优雅的解法是,由于2的幂次方(1,2,4,8...)的二进制数都有一个奇特的特点:</p>
<blockquote>
<p>1 : 0001 , 0 : 0000 2 : 0010 , 1 : 0001 4 : 0100 , 3 : 0011 8 : 1000 , 7 : 0111</p>
</blockquote>
<p>他们都只有一位为1,并且他们减去一之后都只有一位为0.</p>
<p>所以将他们相与,结果刚好就为0.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsPowerOfTwo(int n)</span><br><span class="line">&#123;</span><br><span class="line">    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;//n与n-1相与,每一个0和1相与结果都为0.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>232.用栈实现队列</title>
    <url>/2019/05/28/232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) -- 将一个元素放入队列的尾部。</li>
<li>pop() -- 从队列首部移除元素。</li>
<li>peek() -- 返回队列首部的元素。</li>
<li>empty() -- 返回队列是否为空。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // 返回 1</span><br><span class="line">queue.pop();   // 返回 1</span><br><span class="line">queue.empty(); // 返回 false</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>你只能使用标准的栈操作 -- 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>只能使用栈来实现队列的话,可以使用两个栈.</p>
<p>因为队列的特性是后进后出,而栈的特性是后进先出,要实现后进后出,也就是说最新入栈的元素,要被放到栈底.</p>
<p>所以可以定义一个临时栈,只要有元素进入主栈,就将主栈的所有元素搬到临时栈,在栈底放入新元素,然后再将数据从临时栈搬入主栈.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyQueue</span><br><span class="line">&#123;</span><br><span class="line">    Stack&lt;int&gt; stack1 = new Stack&lt;int&gt;();</span><br><span class="line">    Stack&lt;int&gt; stack2 = new Stack&lt;int&gt;();</span><br><span class="line">    public MyQueue()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Push(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        while (stack1.Count != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            stack2.Push(stack1.Pop());//将所有元素从主栈搬到临时栈.</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.Push(x);//将新元素放入主栈底.</span><br><span class="line">        while (stack2.Count != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            stack1.Push(stack2.Pop());//将所有元素从临时栈搬回主栈.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        return stack1.Pop();</span><br><span class="line">    &#125;</span><br><span class="line">    public int Peek()</span><br><span class="line">    &#123;</span><br><span class="line">        return stack1.Peek();</span><br><span class="line">    &#125;</span><br><span class="line">    public bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return stack1.Count &gt; 0 ? false : true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>234.回文链表</title>
    <url>/2019/05/29/234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong> 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题,有上中下三种解法:</p>
<ul>
<li><p>下等解法,直接用个栈来存储每个链表的元素,由于栈是后进先出的,所以每一个出栈元素都是链表的末尾元素,这时候可以直接和头元素比较是否相等.</p>
<p>但是这样做的缺点很明显,首先浪费时间和空间;其次要是这个链表是循环链表,那就爆栈了.</p></li>
<li><p>中等解法,将链表整条直接反转,然后继续比较两条链表是否完全一致.</p>
<p>这样做的缺点是,会浪费一点点的时间,因为我们知道,如果一条链是回文链,那其实只要比较一半的数据就够了,并不需要完全比较.</p></li>
<li><p>上等解法,找到链表的中点,然后将中点节点的后面部分反转,如果和前面部分一致,那就说明是回文链表了.</p>
<p>而反转链表的这个部分,可以直接找回当初的<a href="https://jiayaoo3o.github.io/2019/05/24/206-反转链表/">206.反转链表</a>.</p></li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsPalindrome(ListNode head)</span><br><span class="line">&#123;</span><br><span class="line">    if (head == null || head.next == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    while (fast != null &amp;&amp; fast.next != null)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast.next.next;//快的每次走两步.</span><br><span class="line">        slow = slow.next;//慢的每次走一步,快的走到尾了,慢的就会在中间.</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newLinkedList = null;//创建一个新的链表.</span><br><span class="line">    while (slow != null)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode tempNode = slow.next;//创建临时链表存放头节点的尾巴.</span><br><span class="line">        slow.next = newLinkedList;//将新链表接到头节点后面.</span><br><span class="line">        newLinkedList = slow;//再次成为新链表.</span><br><span class="line">        slow = tempNode;//将临时链表覆盖原链表.</span><br><span class="line">    &#125;</span><br><span class="line">    slow = newLinkedList;</span><br><span class="line">    while (slow != null)</span><br><span class="line">    &#123;</span><br><span class="line">        if (slow.val != head.val)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>237.删除链表中的节点</title>
    <url>/2019/05/31/237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 -- head = [4,5,1,9]，它可以表示为:</p>
<figure>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: head = [4,5,1,9], node = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: head = [4,5,1,9], node = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题真的是一道神题目,如果不看解释一开始我连意思都没读懂.</p>
<p>这道题是指,函数里面给定的节点就是要删除的节点,它自身就处于这条链表内,所以其实问的是<strong>在你只拥有自身节点的情况下如何删除自身</strong>?</p>
<p>而这道题的解法真的是太有意思了,因为我们知道,如果只知道自身节点是没法直接删除自身的,因为一般来说删除一个链表的某个节点的方法,是将这个被删除节点的头节点与自己的尾节点相连,然后自己就会被孤立了.</p>
<p>但是现在不知道自己的上一个节点,只知道自己,如何删掉自己?</p>
<p>方法就是复制下一个节点的数据到自己身上,把自己变成自己的下一个节点,然后删掉下一个节点.</p>
<p>这样的效果就仿佛是自己被删除了.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void DeleteNode(ListNode node)</span><br><span class="line">&#123;</span><br><span class="line">    node.val = node.next.val;//用下一个节点的数据覆盖当前节点.</span><br><span class="line">    node.next = node.next.next;//删除下一个节点.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>242.有效的字母异位词</title>
    <url>/2019/05/31/242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p>
<p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>首先要知道什么是字母异位词,它是指两个字符串所包含的字母的出现次数都相同,只是顺序不一样.</p>
<p>这道题解决的思路还是挺多的,而且虽然说明上明确只有小写字母,但是进阶里问到如果出现unicode字符怎么办,所以方法里最好不要有硬编码26个字母出现.</p>
<ul>
<li>方法一:将两个字符串直接排序,然后逐个比较对应位置是否相同.</li>
<li>方法二:s字符串里面每出现一个字母,就在字典对应位置+1;t字符串里每出现一个字母,就在对应位置-1,这样一加一减,结果就应该是字典里面所有数据都为0,如果不是,说明两者不是字母异位词.</li>
</ul>
<h2 id="代码">代码</h2>
<p>排序法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsAnagram(string s, string t)</span><br><span class="line">&#123;</span><br><span class="line">    if (s.Length != t.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] str1 = s.ToCharArray();</span><br><span class="line">    char[] str2 = t.ToCharArray();</span><br><span class="line">    Array.Sort(str1);</span><br><span class="line">    Array.Sort(str2);</span><br><span class="line">    for (int i = 0; i &lt; str1.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (str1[i] != str2[i])</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字典法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsAnagram(string s, string t)</span><br><span class="line">&#123;</span><br><span class="line">    if (s.Length != t.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var charDict = new Dictionary&lt;char, int&gt;();</span><br><span class="line">    foreach (var c in s)</span><br><span class="line">    &#123;</span><br><span class="line">        if (charDict.ContainsKey(c))</span><br><span class="line">        &#123;</span><br><span class="line">            charDict[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            charDict.Add(c, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    foreach (var c in t)</span><br><span class="line">    &#123;</span><br><span class="line">        if (charDict.ContainsKey(c))</span><br><span class="line">        &#123;</span><br><span class="line">            if (--charDict[c] == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                charDict.Remove(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return charDict.Count == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>258.各位相加</title>
    <url>/2019/06/02/258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入 : 38</span><br><span class="line">输出 : 2 </span><br><span class="line">解释 : 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题非常有意思的点是进阶里面说的:</p>
<blockquote>
<p>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
</blockquote>
<p>说明这道题不止只有暴力循环解法,还有更巧妙的,只用O(1)时间的解法,也就是说,连扫描一趟的功夫都不用,直接就能得到结果.</p>
<p>这个时候就应该通过数学找规律来解题了,先用比较小的数去尝试看看能不能发现规律:</p>
<p>10---1</p>
<p>11---2</p>
<p>12---3</p>
<p>18---9</p>
<p>19---1</p>
<p>20---2</p>
<p>21---3</p>
<p>99---9</p>
<p>100---1</p>
<p>101---2</p>
<p>102---3</p>
<p>109---1</p>
<p>110---2</p>
<p>111---3</p>
<p>117---9</p>
<p>可以看到,有某个数是比较特别的,那就是这个9.</p>
<p>各位相加答案为9的数,刚好也即是9的倍数.也就是说某个数能被9整除,那他的各位相加结果就刚好是9.</p>
<p>并且无法被9整除的数,得到的余数也就刚好是答案.</p>
<h2 id="代码">代码</h2>
<p>暴力法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int AddDigits(int num)</span><br><span class="line">&#123;</span><br><span class="line">    if (num &lt; 10)</span><br><span class="line">    &#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">    int result = 0;</span><br><span class="line">    while (num &gt;= 10)</span><br><span class="line">    &#123;</span><br><span class="line">        result = 0;</span><br><span class="line">        while (num != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            result += num % 10;</span><br><span class="line">            num /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        num = result;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规律法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int AddDigits(int num)</span><br><span class="line">&#123;</span><br><span class="line">    if (num &gt; 9)</span><br><span class="line">    &#123;</span><br><span class="line">        num = num % 9;</span><br><span class="line">        if (num == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 9;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>26.删除排序数组中的重复项</title>
    <url>/2019/05/04/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>用快慢指针来解决,定义两个指针,一个快一个慢,如果快的和慢的不相等,就让快的覆盖慢的.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int RemoveDuplicates(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    if (nums.Length == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (int j = 1; j &lt; nums.Length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[j] != nums[i])//用快慢指针解决,后面的数覆盖前面的重复值.</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>263.丑数</title>
    <url>/2019/06/03/263-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 6</span><br><span class="line">输出: true</span><br><span class="line">解释: 6 = 2 × 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: true</span><br><span class="line">解释: 8 = 2 × 2 × 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 14</span><br><span class="line">输出: false </span><br><span class="line">解释: 14 不是丑数，因为它包含了另外一个质因数 7。</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol type="1">
<li><code>1</code> 是丑数。</li>
<li>输入不会超过 32 位有符号整数的范围: [−2<sup>31</sup>, 2<sup>31</sup> − 1]</li>
</ol>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>丑数的定义是只会存在2,3,5这三个因数的一个或多个,也就说明一个丑数整除这三个数中的一个或者多个,肯定是可以除尽的,所以可以逐步缩小输入的数,只要当输入数可以整除2,3,5中的数时,就除以他们,这样逐步计算下去,如果逐步缩小到最后的结果为1,那就说明这个输入的数仅包含质因数2,3,5.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsUgly(int num)</span><br><span class="line">&#123;</span><br><span class="line">    if (num &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return (num == 1) ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">    while (num % 2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        num /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    while (num % 3 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        num /= 3;</span><br><span class="line">    &#125;</span><br><span class="line">    while (num % 5 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        num /= 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return num == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>268.缺失数字</title>
    <url>/2019/06/26/268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p>
<p><strong>示例 1:</strong></p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> 你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题的思路有很多,我挑了最简单的两个来写.</p>
<ul>
<li>直接对输入的整型数组进行排序,排序了之后与0-n的序列进行逐个比较,如果遇到不相等,那就说明找到了这个缺失的数字.</li>
<li>由于题目说明有且仅有一个数是缺失的,所以我们如果求出了不缺失情况下的和,减去现在数组的和,差值就是这个缺失的数字,而且由于这个0-n序列是一个等差数列,求和可以直接使用公式.</li>
</ul>
<h2 id="代码">代码</h2>
<p>排序法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int MissingNumber(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    Array.Sort(nums);</span><br><span class="line">    for (int i = 0; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i != nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求和法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int MissingNumber(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    int sum = (nums.Length * (nums.Length + 1)) / 2;</span><br><span class="line">    for (int i = 0; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum -= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>27.移除元素</title>
    <url>/2019/05/04/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个数组 <em>nums</em> 和一个值 <em>val</em>，你需要<strong>原地</strong>移除所有数值等于 <em>val</em> 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>用双向指针来解决这道题,一个指针从头开始,一个指针从末尾开始,只要头指针等于val,就将尾指针不等于val的值放到头指针的位置,这样逐步扫过去,结果就是目标数组了.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int RemoveElement(int[] nums, int val)</span><br><span class="line">&#123;</span><br><span class="line">    int n = nums.Length;//尾指针.</span><br><span class="line">    for (int i = 0; i &lt; n;)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[i] == val)//如果头指针对应位置等于val,就用尾指针覆盖.</span><br><span class="line">        &#123;</span><br><span class="line">            n--;</span><br><span class="line">            nums[i] = nums[n];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>278.第一个错误的版本</title>
    <url>/2019/06/26/278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>示例:</p>
<blockquote>
<p>给定 n = 5，并且 version = 4 是第一个错误的版本。</p>
<p>调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true</p>
<p>所以，4 是第一个错误的版本。</p>
</blockquote>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题如果没看明白题目说的调用接口判断是啥意思那可能会理解错题意,题目是说现在已经提供给你一个isBadVersion()函数给你去判断了,你不需要自己写这个函数,直接在代码里调用就可以了,思路也比较明确,应该要使用二分法来查找.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int FirstBadVersion(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int left = 1, right = n;</span><br><span class="line">    while (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (IsBadVersion(mid))</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>28.实现strStr()</title>
    <url>/2019/05/06/28-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>实现 <a href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 <strong>-1</strong>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>直接使用库函数解决.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int StrStr(string haystack, string needle)</span><br><span class="line">&#123;</span><br><span class="line">    return haystack.IndexOf(needle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>283.移动零</title>
    <url>/2019/07/01/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例: &gt; 输入: [0,1,0,3,12] &gt; 输出: [1,3,12,0,0]</p>
<p>说明: - 必须在原数组上操作，不能拷贝额外的数组。 - 尽量减少操作次数。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>既然要求在原数组上操作,并且要尽量减少操作,那说明就应该在一趟扫描中解决问题.</p>
<p>题目想要的是将0移到数组末尾,一个思路是在一趟扫描中,只要遇到0,就用后面不是0的数覆盖到这个0,覆盖完了之后,将数组后面的数字都设置成0.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void MoveZeroes(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    int flag = 0;</span><br><span class="line">    foreach (int num in nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (num != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[flag] = num;</span><br><span class="line">            flag += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = flag; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>292.Nim游戏</title>
    <url>/2019/07/02/292-Nim%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<p>示例:</p>
<blockquote>
<p>输入: 4 输出: false 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</p>
</blockquote>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>根据题目所说,我们每次可以拿1-3块,也就是说假设现在轮到我们的局面只剩1-3块,那我们必赢;但是如果轮到我们局面剩下4块,那我们必输,因为我们不管最后拿多少,肯定会剩下石头,让对手胜出,由此可见,在谁的回合中剩下4块石头,谁必输;另一方面,为了让对手回合有4块石头,我们的回合就一定得是5-7块石头,如果我们的回合有8块石头,那无论我们拿多少个石头,对方都能够逼迫我们下一回合拥有4块石头,所以我们也输了.</p>
<p>也就是说,只要我们的回合是4,8,12,16等等4的倍数块,那对手就总能够逼迫我们剩下四块,导致我们失败;另一方面,只要我们的回合不是4的倍数块,我们就能逼迫对手变成4的倍数块,从而赢得胜利.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool CanWinNim(int n)</span><br><span class="line">&#123;</span><br><span class="line">    return n % 4 != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>326.3的幂</title>
    <url>/2019/07/02/326-3%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 27 输出: true</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 0 输出: false</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: 9 输出: true</p>
</blockquote>
<p>示例 4:</p>
<blockquote>
<p>输入: 45 输出: false</p>
</blockquote>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>3或者某个数的幂次方有两个特点:</p>
<ol type="1">
<li>这个幂次方模3肯定为0.</li>
<li>这个幂次方除以3之后继续模3,也会为0,直到它最后变成1</li>
</ol>
<p>所以我们可以通过循环,只要这个数模3为0就将它除以3,然后继续循环,知道它最后结果为1</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsPowerOfThree(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if (n == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    while (n % 3 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        n /= 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return n == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>35. 搜索插入位置</title>
    <url>/2019/05/06/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题很简单,就是在一个循环内将数组的每个数与目标值进行比较,如果目标值小于等于数组值,那就说明这个位置就是我们要找的位置.</p>
<p>如果一个循环下来都没有找到这个位置,说明这个位置在数组的最后.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int SearchInsert(int[] nums, int target)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[i] &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.Length;//如果前面的循环都找不到插入位置说明在最后面一个</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>53.最大子序和</title>
    <url>/2019/05/06/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>题目要求有最大和的连续子数组,如果添加数组的下一个数导致这个和成为了负数,说明这个序列能到达的最大的长度已经结束了,因为加上下一个数只会让和变得更小,新的序列应该从下一个数开始尝试.</p>
<p>所以我们可以设定一个最大值,每当一个序列结束时,我们就将这个序列的和与最大值进行比较,如果序列和大于最大值,就让这个序列和成为最大值.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int MaxSubArray(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">    if (nums.Length == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int max = nums[0];</span><br><span class="line">    for (int i = 0; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum &lt; 0 ? 0 : sum;//如果sum&lt;0那这个sum就可以舍弃了,直接变为0;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        max = sum &gt; max ? sum : max;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>58.最后一个单词的长度</title>
    <url>/2019/05/06/58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个仅包含大小写字母和空格 <code>' '</code> 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p><strong>说明：</strong>一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;Hello World&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<h2 id="思路">思路</h2>
<p>这道题要注意的一个点是,给定的字符串有可能是后面带有若干个空格的,所以要处理字符串之前先要用Trim()函数解决了头尾空格,然后就容易判断了.</p>
<span id="more"></span>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int LengthOfLastWord(string s)</span><br><span class="line">&#123;</span><br><span class="line">    return s.Trim().Split()[s.Trim().Split().Length - 1].Length;//trim用于消除头尾空格,split用于将字符串分割,然后取最后一个字符串得长度.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>66.加一</title>
    <url>/2019/05/07/66-%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题考察的是数组加法,数组加法的常规步骤为:</p>
<ul>
<li>定义一个记录进制信息的变量.</li>
<li>一个循环内按位相加得到每一位的和,和模10就是每一位的值,注意,如果是字符串数组,char要减去48才是int.</li>
<li>进位等于和除以10.</li>
<li>循环结束后如果进位仍然为1,则说明数组第一位仍然要添加1.</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] PlusOne(int[] digits)</span><br><span class="line">&#123;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    int digitSum = 0;</span><br><span class="line">    for (int i = digits.Length - 1; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        digitSum = digits[i] + flag;</span><br><span class="line">        digits[i] = digitSum % 10;</span><br><span class="line">        flag = (digitSum + 1 + flag) / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int[] result = new int[digits.Length + 1];</span><br><span class="line">        result[0] = 1;</span><br><span class="line">        digits.CopyTo(result, 1);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>67. 二进制求和</title>
    <url>/2019/05/07/67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>又是字符串相加的题目,思路类似于上一题的数组加法,只要是要自己实现加法的,步骤都基本如下:</p>
<ul>
<li>定义一个进位变量flag.</li>
<li>如果长度不一致,将两者长度变成一致.</li>
<li>从右到左按位相加,如果产生了进位,进位就变成1.</li>
<li>循环结束后,如果flag仍为1,则说明还要加一.</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public string AddBinary(string a, string b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a.Length &gt; b.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        b = b.PadLeft(a.Length, &#x27;0&#x27;);//用padleft这个方法来填充0.</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        a = a.PadLeft(b.Length, &#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    int flag = 0;</span><br><span class="line">    string result = &quot;&quot;;</span><br><span class="line">    for (int i = a.Length - 1; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        result = (((int)a[i] - 48 + (int)b[i] - 48 + flag) % 2).ToString() + result;</span><br><span class="line">        flag = ((int)a[i] - 48 + (int)b[i] - 48 + flag) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag == 1 ? flag + result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>69.x的平方分根</title>
    <url>/2019/05/07/69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E5%88%86%E6%A0%B9/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题看似简单,但是非常有意思,普通解法可以使用二分法来进行计算,但是这里使用一个更好用的解法:<a href="https://www.guokr.com/question/461510/">牛顿迭代法</a>,通过逼近斜率来得到方程的解.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int MySqrt(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if (x &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    double r = x;</span><br><span class="line">    for (int i = 0; i &lt; 20; i++)//迭代次数,次数越多越精确.</span><br><span class="line">    &#123;</span><br><span class="line">        r = (r + x / r) / 2;//牛顿迭代法的关键,建议直接背下来.</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>7.整数反转</title>
    <url>/2019/05/01/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>关于反转类题目,千万不要一开始就想着转变成字符数组然后调用Array.Reverse(),应该用模得到余数,再逐次乘以10来获得反转数.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int Reverse(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int n = 0;</span><br><span class="line">    int result = 0;</span><br><span class="line">    while (x != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        result = n * 10 + x % 10;</span><br><span class="line">        if (result / 10 != n)//不等于n说明溢出了.</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        x /= 10;</span><br><span class="line">        n = result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>70.爬楼梯</title>
    <url>/2019/05/08/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>这道题是典型的动态规划题目,详细解释可以查看<a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg">这篇推文</a>,讲的非常好.</p>
<h2 id="代码">代码</h2>
<p>动态规划:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int ClimbStairs(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if (n == 1 || n == 0 || n == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] r = new int[n + 1];//定义一个数组,接收每一层楼梯的走法</span><br><span class="line">    r[1] = 1;</span><br><span class="line">    r[2] = 2;</span><br><span class="line">    for (int i = 3; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r[i] = r[i - 1] + r[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return r[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int ClimbStairs(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if (n==1||n==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return ClimbStairs(n - 1) + ClimbStairs(n - 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>83.删除排序链表中的重复元素</title>
    <url>/2019/05/08/83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>将下一个节点和当前节点进行比较,如果两者相等,那就将下下个节点接到这个节点的后面,相当于将重复的节点摘除了.</p>
<h2 id="代码">代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode DeleteDuplicates(ListNode head)</span><br><span class="line">&#123;</span><br><span class="line">    if (head == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    while (node.next != null)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node.next.val == node.val)</span><br><span class="line">        &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>9.回文数</title>
    <url>/2019/05/01/9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong></p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<p>最简单的方法就是转化为字符串判断首尾是否一致.</p>
<p>不转化成字符串的方法就是用<a href="https://jiayaoo3o.github.io/2019/05/01/7-整数反转/">7.整数反转</a>里说到的方法将整数反转再判断是否相等.</p>
<h2 id="代码">代码</h2>
<p>直接转化字符串:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsPalindrome(int x)</span><br><span class="line">&#123;</span><br><span class="line">     string str = x.ToString();</span><br><span class="line">     for (int i = 0; i &lt; str.Length / 2; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         if (str[i] != str[str.Length - i - 1])</span><br><span class="line">         &#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反转整数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool IsPalindrome(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if (x &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int num = x;</span><br><span class="line">        int result = 0;</span><br><span class="line">        while (num != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            result = result * 10 + num % 10;</span><br><span class="line">            num /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return result == x ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>AdobeCC2019激活补丁</title>
    <url>/2019/03/22/AdobeCC2019%E6%BF%80%E6%B4%BB%E8%A1%A5%E4%B8%81/</url>
    <content><![CDATA[<h1 id="请不要在任何商业活动中使用非正版adobe全家桶">请不要在任何商业活动中使用非正版Adobe全家桶</h1>
<p>有很多人想要用付费软件时,第一时间想到的是去各种软件下载站下载所谓的"破解版",这是不应该的,因为很多软件并不需要"破解",只要在官方下载的正版软件上输入一个注册码,或者改变一个激活文件就行了,而下载的"破解版",你是不知道别人在里面更改了什么东西的,所以"正确"的激活方法,应该是去官网下载软件,安装之后自己激活,而不是去找"破解版".</p>
<span id="more"></span>
<p>下面的软件,都可以去官网下载安装后激活而不需要找"破解版":</p>
<ul>
<li>Adobe系列软件</li>
<li>office系列软件</li>
<li>Windows系统系列</li>
<li>各种制图软件,3d建模软件系列</li>
</ul>
<p>adobe系列软件从2019版开始,改变了激活策略,以前用软件更换一个amtlib.dll的方法,只能激活19年以前的版本,现在已经不能用了.</p>
<p>但是好在现在依然能通过更换注册补丁的方法来激活,只是稍微复杂一点点而已,全部步骤如下:</p>
<ol type="1">
<li><p>在<a href="https://www.adobe.com/cn/">adobe官方网站</a>下载页面找到免费试用,开始下载和安装你需要的软件.</p></li>
<li><p>安装完你需要的软件之后,打开它,它应该会弹出一个"试用7天"的窗口的,这时候关闭软件.</p></li>
<li><p><a href="https://www6.zippyshare.com/d/3jRFC4r7/419067/Zer0Cod3%20End%20October%20Cracks%2030-10-2018.zip">点击下载</a>Zer0Cod3制作的AdobeCC2019激活补丁,文件大小224M,下载完成之后解压到任意一个文件夹<img src="https://i.loli.net/2019/03/22/5c94a2ec822e9.png" /></p></li>
<li><p>找到你需要激活的软件的补丁压缩包,双击解压,例如AE2019,解压后的.dll文件,就是我们需要的激活补丁了,现在要把这两个激活补丁放到他们应该在的地方,所以接下来我们要找到他们原本所在文件夹<img src="https://i.loli.net/2019/03/22/5c94a3342b898.png" /></p></li>
<li><p>打开安装Adobe的文件目录,一般所有Adobe软件都装在C:Files,例如AE的安装目录是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Adobe\Adobe After Effects CC 2019</span><br></pre></td></tr></table></figure></li>
<li><p>打开软件的文件夹之后,在<strong>右上方的搜索框</strong>分别搜索刚刚的补丁的名字,在找到的结果上<strong>右键</strong>,选择<strong>打开文件所在位置</strong><img src="https://i.loli.net/2019/03/22/5c94a4f1f0b9d.png" /></p></li>
<li><p>将同名的激活补丁粘贴到这个文件的所在目录,替换掉原来的文件<img src="https://i.loli.net/2019/03/22/5c94a5639843a.png" /></p></li>
<li><p>再次打开Adobe的软件,应该就已经激活成功了.</p></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Adobe</tag>
      </tags>
  </entry>
  <entry>
    <title>CapsLock键的AutoHotKey映射方案</title>
    <url>/2019/06/26/CapsLock%E9%94%AE%E7%9A%84AutoHotKey%E6%98%A0%E5%B0%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>CapsLock键,占着最好的位置,产出最低的贡献,所以很多人包括我都会选择将它映射成其他功能. vim党喜欢将CapsLock键映射成esc,这样退出输入模式就会非常的轻松,但是我vim用得不多,所以更想要将它映射成ctrl键,并且由于vim的hjkl方向移动很好用,所以我也打算将CapsLock＋hjkl实现方向移动.</p>
<span id="more"></span>
<p>但是这里问题就出现了,如果直接将CapsLock–&gt;ctrl,那假设想要实现CapsLock＋hjkl方向移动,就意味着要将ctrl+hjkl进一步映射成左下右上,但是这样会发生冲突,因为ctrl+hjkl本身是有含义的,例如chrome下ctrl+h就是历史记录,如果修改了这个按键映射那就没法直接调出历史记录了.</p>
<p>所以,将CapsLock映射为ctrl,和hjkl实现方向移动,总是会产生冲突的.</p>
<p>但是我想到了一个完美的方法去解决这个问题,那就是将CapsLock键映射为右ctrl键,注意不是ctrl,而是右ctrl,这个操作就可以完美实现我需要的两个功能.</p>
<p>因为右手边的ctrl键隔得太远平时就很少用,所以将CapsLock–&gt;右ctrl的好处是,不会影响左ctrl与hjkl的组合功能.</p>
<p>例如,现在按住CapsLock+h,光标会往左边移动,但是按住左边的ctrl+h,仍然可以调出历史记录,并且CapsLock可以实现ctrl的全部功能,例如CapsLock+c,v复制粘贴功能仍然能够实现.</p>
<p>附上autohotkey脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SetCapsLockState, AlwaysOff </span><br><span class="line">CapsLock::RControl ;CapsLock映射右ctrl.</span><br><span class="line">#CapsLock::CapsLock ;win+CapsLock映射为CapsLock.</span><br><span class="line"></span><br><span class="line">&gt;^h::Send, &#123;Left&#125; ;右ctrl+hjkl实现移动.</span><br><span class="line">&gt;^j::Send, &#123;Down&#125;</span><br><span class="line">&gt;^k::Send, &#123;Up&#125;</span><br><span class="line">&gt;^l::Send, &#123;Right&#125;</span><br><span class="line"></span><br><span class="line">&gt;^+h::Send, +&#123;Left&#125; ;右ctrl+shift+hjkl实现选定移动.</span><br><span class="line">&gt;^+j::Send, +&#123;Down&#125;</span><br><span class="line">&gt;^+k::Send, +&#123;Up&#125;</span><br><span class="line">&gt;^+l::Send, +&#123;Right&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>autohotkey</tag>
      </tags>
  </entry>
  <entry>
    <title>Git操作手册</title>
    <url>/2019/03/21/Git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="生成ssh密钥">生成ssh密钥</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></p>
<h2 id="查看git配置信息">查看git配置信息</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></p>
<h2 id="配置git">配置git</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global : 当前用户</span><br><span class="line">git config --system : 整个系统</span><br><span class="line">git config --global user.name &quot;jiayao&quot;</span><br><span class="line">git config --global user.email jiayao3.14@outlook.com</span><br><span class="line">git config --global core.editor vim : 设置默认编辑器</span><br><span class="line">git config --global alias.alias full_name : 设置别名</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化git仓库">初始化git仓库</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<h2 id="添加文件到仓库暂存已修改文件">添加文件到仓库/暂存已修改文件</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="取消暂存">取消暂存</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>
<h2 id="取消修改">取消修改</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure>
<h2 id="提交更改">提交更改</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;massage&quot;</span><br><span class="line">git commit -a : 跳过使用暂存区,直接将修改的文件提交</span><br><span class="line">git commit --amend : 重新提交来覆盖上一次操作</span><br></pre></td></tr></table></figure></p>
<h2 id="克隆仓库">克隆仓库</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="查看仓库状态">查看仓库状态</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git status -s : 紧凑输出</span><br><span class="line">?? : 未跟踪</span><br><span class="line">A : 新添加到暂存区</span><br><span class="line">左M : 修改并且加入暂存区</span><br><span class="line">右M : 修改但未加入暂存区</span><br><span class="line">MM : 修改后加入暂存区又被修改</span><br></pre></td></tr></table></figure></p>
<h2 id="忽略文件.gitignore">忽略文件.gitignore</h2>
<p>github的<a href="https://github.com/github/gitignore">忽略文件列表</a>,忽略文件应该在仓库创建后马上添加,因为已经提交了的文件,哪怕后来被加入了忽略列表,也并不会自动忽略.</p>
<h2 id="比较文件差异">比较文件差异</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff : 比较当前已修改和已暂存文件的差异</span><br><span class="line">git diff --staged : 比较已暂存和已提交的文件差异</span><br><span class="line">git diff --cached</span><br><span class="line">git diff --check : 查找空白错误</span><br></pre></td></tr></table></figure></p>
<h2 id="删除已跟踪文件">删除已跟踪文件</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;file&gt; : 会将文件移除暂存区但是不会删除文件本身</span><br><span class="line">git rm &lt;file&gt; : 会将文件移出仓库并且删除</span><br></pre></td></tr></table></figure></p>
<h2 id="更改文件名称">更改文件名称</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv file_from file_to : 等于下面三个命令</span><br><span class="line">mv file_from file_to</span><br><span class="line">git rm file_from</span><br><span class="line">git add file_to</span><br></pre></td></tr></table></figure></p>
<h2 id="查看提交历史">查看提交历史</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">git log -p -2 : 添加-p显示每次提交的差异,-2表示最近两次</span><br><span class="line">git log --stat : 查看每次提交的简略统计信息</span><br><span class="line">git log --since : 从什么时候开始</span><br><span class="line">git log --until : 直到什么时候</span><br></pre></td></tr></table></figure></p>
<h2 id="添加远程仓库">添加远程仓库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure>
<h2 id="查看远程仓库">查看远程仓库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure>
<h2 id="拉取远程仓库">拉取远程仓库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch [remote-name] : 只是拉取,但是不会自动合并</span><br><span class="line">git pull [remote-name] : 拉取并且合并到当前分支</span><br></pre></td></tr></table></figure>
<h2 id="推送到远程仓库">推送到远程仓库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure>
<h2 id="移除远程仓库">移除远程仓库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm [remote-name]</span><br></pre></td></tr></table></figure>
<h2 id="创建分支">创建分支</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch &lt;name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="删除分支">删除分支</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="切换分支">切换分支</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout &lt;name&gt; : 可以切换分支,或者HEAD移动到某个提交</span><br><span class="line">git checkout -b &lt;name&gt; : 创建并且切换到新建分支</span><br></pre></td></tr></table></figure>
<h2 id="合并分支">合并分支</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge &lt;target_branch&gt;</span><br></pre></td></tr></table></figure>
<h2 id="变基">变基</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase target : 把自身分支变基到target分支,此时切换到target分支进行merge会产生快速合并</span><br><span class="line">git rebase --onto master server client : 取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍</span><br><span class="line">git rebase [basebranch] [topicbranch] : 可以省略切换分支再变基的步骤</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo通过GitHub Actions持续集成发布</title>
    <url>/2019/12/21/Hexo%E9%80%9A%E8%BF%87GitHubActions%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>GitHub Page博客源文件,通过GitHub Action自动发布推送</p>
<h2 id="原理">原理</h2>
<p>简单来说,原理就是将所有的hexo文章文件放到当前的<strong>Blog</strong>分支,然后在<strong>Blog</strong>分支添加一个Action,每当这个分支接收到更新,就触发一次Action,在Github提供的免费服务器上安装node.js,再安装hexo,然后生成静态页面,推送到<strong>jiayaoO3O.github.io</strong>的<strong>master</strong>分支.</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<h3 id="创建一对公钥与私钥">创建一对公钥与私钥</h3>
<p>由于需要从<strong>Blog</strong>分支推送到<strong>jiayaoO3O.github.io</strong>的<strong>master</strong>分支,所以得先创建一对公钥与私钥,输入:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>按下三次回车,创建一对公钥与私钥.</p>
<p>将私钥添加到<strong>Settings</strong>下<strong>Secrets</strong>中,名字设置为<strong>ACTION_DEPLOY_KEY</strong>.</p>
<p><img src="https://i.loli.net/2019/12/23/JCNwPQUGt1RdmiA.png" /></p>
<p>将公钥添加到<strong>Settings</strong>下的<strong>Deploy keys</strong>中,名字不重要.</p>
<p><img src="https://i.loli.net/2019/12/23/mC6ZlP3zTcw9IJ5.png" /></p>
<p>这时候,<strong>Blog</strong>分支就有权限推送文件到<strong>jiayaoO3O.github.io</strong>的<strong>master</strong>分支了.</p>
<h3 id="修改推送博客的方式">修改推送博客的方式</h3>
<p>由于现在使用ssh方式对文件进行推送,所以要修改博客文件根目录的**_config.yml<strong>文件的</strong>deploy**方式:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:jiayaoO3O/jiayaoO3O.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h3 id="创建一个新的blog分支">创建一个新的Blog分支</h3>
<p>从master分支中创建一个新的Blog分支,删除Blog分支的所有文件,然后添加所有博客源文件到Blog分支中.</p>
<p><img src="https://i.loli.net/2019/12/23/wduqPtUkmf45pMg.png" /></p>
<h3 id="创建一个workflow文件在blog分支中">创建一个Workflow文件在Blog分支中</h3>
<p>点击分支的Actions,创建一个新的Workflow,名字不限.</p>
<p><img src="https://i.loli.net/2019/12/23/DB7OtP46osfu2ca.png" /></p>
<p>注意这里如果是第一次创建这个文件,一定要确定选择的是Blog分支.</p>
<p>添加内容如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Publish</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">Blog</span> <span class="string">Branche</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span> </span><br><span class="line">          <span class="attr">ref:</span> <span class="string">Blog</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Node.js</span> <span class="number">12</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">12.</span><span class="string">x</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Git</span> <span class="string">Config</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACTION_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$ACTION_DEPLOY_KEY&quot; | tr -d &#x27;\r&#x27; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.name &#x27;jiayaoO3O&#x27;</span></span><br><span class="line"><span class="string">          git config --global user.email &#x27;jiayao3.14@outlook.com&#x27;</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm i -g hexo-cli </span></span><br><span class="line"><span class="string">          npm i</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">g</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是,如果刚刚在<strong>Settings</strong>下<strong>Secrets</strong>中添加的名字不是<strong>ACTION_DEPLOY_KEY</strong>,则</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACTION_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这一行也要修改成对应的名字.</p>
<p>提交了这个Workflow文件之后,就会马上启动一个Action,如果没有报错,那么等一会儿博客就会自动更新.</p>
<h3 id="修改blog分支为默认分支">修改Blog分支为默认分支</h3>
<p>这一步是可选项,由于我们平时只关注Blog分支下面的源文件,对于master分支的页面内容其实并不关心,所以可以修改Blog分支为默认分支.</p>
<p><img src="https://i.loli.net/2019/12/23/7lrVEMjIL64hQdq.png" /></p>
<p>点击<strong>Settings</strong>中的<strong>Branches</strong>,选择<strong>Blog</strong>作为默认分支,这样仓库的默认显示页面就成了<strong>Blog</strong>分支了.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>Actions</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Sakura frp--免费的高速内网穿透工具</title>
    <url>/2019/03/01/Sakura-Frp-%E5%85%8D%E8%B4%B9%E7%9A%84%E9%AB%98%E9%80%9F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="什么是sakurafrp">什么是Sakurafrp?</h1>
<p><a href="https://www.natfrp.org">Skaura frp</a>是一款免费的,基于 <a href="https://github.com/fatedier/frp">frp</a> 封装的可用于内网穿透的高性能的反向代理应用,通过frp,没有公网ip的用户也能够远程访问自己的电脑.</p>
<span id="more"></span>
<h1 id="sakurafrp的优点">Sakurafrp的优点</h1>
<p>相对于传统的frp,Sakura frp有以下优点:</p>
<ol type="1">
<li>最大的优点,Sakura frp免费提供了frp服务器给广大用户,使得用户不需要自己购买,维护公网服务器便能享受frp带来的便捷.</li>
<li>Sakura frp在传统的frp程序上进行封装,不需要用户配置frp客户端,只要输入用户名和密码,选择适合自己的服务器即可,做到快捷上手,简单易用,门槛降低.</li>
</ol>
<h1 id="使用sakurafrp进行远程桌面控制">使用Sakurafrp进行远程桌面控制</h1>
<p>既然frp主打的功能是内网穿透,在这里就用Windows的远程桌面来展示如何使用Sakura frp.</p>
<h2 id="注册并登录sakurafrp">1.注册并登录Sakurafrp</h2>
<p>首先先在<a href="https://www.natfrp.org">Sakurafrp</a>官网注册账号并登录</p>
<p><img src="https://i.loli.net/2019/03/01/5c7951fdd3276.png" /></p>
<h2 id="创建内网穿透映射">2.创建内网穿透映射</h2>
<p>登录之后,选择左边的映射列表,创建一个新的映射</p>
<p><img src="https://i.loli.net/2019/03/01/5c795275e01ad.png" /></p>
<p>这里可以看到,Sakurafrp 已经内置了几种常用的内网穿透映射,这里点击远程桌面,注意远程端口要自己填一个数字,但是这个数字不能跟其他用户已经选择的数字冲突,所以可能要多试几个端口,直到成功为止.</p>
<h2 id="下载sakurafrp客户端">3.下载Sakurafrp客户端</h2>
<p>创建成功之后,点击左侧的客户软件选择适合自己的客户端进行<a href="https://s1.tcotp.cn/cdn/SakurafrpClient-2.3/Sakura_frpc_Windows_amd64.exe">下载</a>,如果没有需求不需要下载图形版本.</p>
<p><img src="https://i.loli.net/2019/03/01/5c79537c0ba50.png" /></p>
<h2 id="运行sakurafrp客户端">4.运行Sakurafrp客户端</h2>
<p>运行Sakurafrp客户端的方法有3种:</p>
<ol type="1">
<li>直接双击下载的Sakurafrp,输入账号和密码,再输入服务器ID,选择合适自己的服务器</li>
</ol>
<p><img src="https://i.loli.net/2019/03/01/5c79555656732.png" /></p>
<p>就已经内网穿透成功了,其他电脑打开微软远程桌面,或者手机安装微软远程桌面app,电脑ip地址位置输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所选服务器地址:远程端口号</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/03/02/5c795d2a2f194.png" /></p>
<p>例如你选了台湾百兆服务器,远程端口是10010,则输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s21.natfrp.org:10010</span><br></pre></td></tr></table></figure>
<p>账号密码则输入运行了Sakurafrp的,被控制的电脑的账号与密码,点击连接,手机或者其他电脑就可以远程控制这台电脑了.</p>
<p>这个方法适合临时使用Sakurafrp进行内网穿透,关闭软件窗口即断开连接服务器.</p>
<ol start="2" type="1">
<li><p>在powershell等终端软件中打开Sakurafrp,这种方法可以免去每次手动输入账户名,密码,服务器ID.只要在Sakurafrp客户端所在的文件夹中,按住Shift键,选择打开powershell,然后在powershell中输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./Sakura_frpc_Windows_amd64.exe --su=&quot;你的用户名&quot; --sp=&quot;你的密码&quot; --sid=&quot;服务器ID&quot;</span><br></pre></td></tr></table></figure>
<p>即可自动登录并且选择服务器.</p></li>
<li><p>开机自启动Sakurafrp.虽然上面两种方法可以使用,但是会在任务栏上显示出来,而且软件不能关闭,只要关闭就会断掉,所以第三种方法是将Sakurafrp放在后台,自动开机启动.</p>
<p>首先在Sakurafrp所在的文件夹新建一个文本文件,命名为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sakura_frpc.bat</span><br></pre></td></tr></table></figure>
<p>右键该文件,选择编辑,输入:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Sakura_frpc_Windows_amd64.exe -<span class="literal">-su</span>=<span class="string">&quot;你的用户名&quot;</span> -<span class="literal">-sp</span>=<span class="string">&quot;你的密码&quot;</span> -<span class="literal">-sid</span>=<span class="string">&quot;服务器ID&quot;</span></span><br></pre></td></tr></table></figure>
<p>并且保存.</p>
<p>再在Sakurafrp所在的文件夹新建一个文本文件,命名为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sakura_frpc.vbs</span><br></pre></td></tr></table></figure>
<p>右键该文件,选择编辑,输入:</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> ws=WScript.<span class="built_in">CreateObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>) </span><br><span class="line">ws.Run <span class="string">&quot;Sakura_frpc.bat /start&quot;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>并且保存.</p>
<p>这时,我们只要双击这个Sakura_frpc.vbs,软件就会在后台启动了,在任务栏是看不到的,但是在任务管理器中能够看到.</p>
<p>此时,我们右键Sakura_frpc.vbs,选择创建快捷方式</p>
<p>然后键盘Win+R键,输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell:startup</span><br></pre></td></tr></table></figure>
<p>打开开机启动文件夹,把快捷方式放进去.</p>
<p>Sakurafrp就已经能够开机启动了.</p></li>
</ol>
<h1 id="总结">总结</h1>
<p>Sakurafrp是我昨天晚上无意中发现的一个项目,本来我用frp做内网穿透是用自己的腾讯云1M小水管用作公网服务器的,但是没想到Sakurafrp竟然这么良心,免费提供8M的服务器给别人使用,所以我觉得得写一个教程来感恩一下,感谢Sakurafrp,💉 💧 🐮 🍺</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu配置samba</title>
    <url>/2021/05/29/Ubuntu%E9%85%8D%E7%BD%AEsamba/</url>
    <content><![CDATA[<h2 id="安装samba">安装samba</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure>
<h2 id="配置samba">配置samba</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/samba/smb.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[global]</span></span><br><span class="line"><span class="attr">read</span> <span class="string">raw = Yes</span></span><br><span class="line"><span class="attr">write</span> <span class="string">raw = Yes</span></span><br><span class="line"><span class="attr">socket</span> <span class="string">options = TCP_NODELAY IPTOS_LOWDELAY SO_RCVBUF=131072 SO_SNDBUF=131072</span></span><br><span class="line"><span class="attr">min</span> <span class="string">receivefile size = 16384</span></span><br><span class="line"><span class="attr">use</span> <span class="string">sendfile = true</span></span><br><span class="line"><span class="attr">aio</span> <span class="string">read size = 16384</span></span><br><span class="line"><span class="attr">aio</span> <span class="string">write size = 16384</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[sambashare]</span></span><br><span class="line"><span class="attr">comment</span> = <span class="string">Samba on Ubuntu</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">/home/username/sambashare</span></span><br><span class="line"><span class="attr">read</span> <span class="string">only = no</span></span><br><span class="line"><span class="attr">browsable</span> = <span class="string">yes</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service smbd restart</span><br></pre></td></tr></table></figure>
<h2 id="设置用户名密码">设置用户名密码</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo smbpasswd -a username</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode使用docker搭建hexo博客</title>
    <url>/2019/06/29/VSCode%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>随着vscode推出remote-container容器开发模式,在docker里面搭hexo变得简单了起来,非常方便,现在来记录一下vscode使用docker搭建hexo的步骤.</p>
<p>首先要知道待解决的问题有哪些:</p>
<ul>
<li>vscode的remote-container模式好在哪.</li>
<li>如何使用vscode调用docker生成一个镜像.</li>
<li>生成的镜像会有哪些问题.</li>
<li>安装hexo需要哪些东西.</li>
<li>要对Dockerfile进行什么修改才能让生成的容器本身就安装好hexo.</li>
</ul>
<span id="more"></span>
<h2 id="vscode的remote-container模式好在哪">vscode的remote-container模式好在哪</h2>
<p>优点有3个:</p>
<ol type="1">
<li>vscode的<code>remote-container</code>模式使得新手用户几乎不需要太多的手动干涉docker,即可开箱即用.只需安装对应的插件,并且安装了docker,即可成功地让vscode帮你完成大部分事情.</li>
<li>vscode还会将你本机的git配置与容器中的git进行关联,使得几乎可以直接在容器中使用<code>hexo d</code>命令将博客部署到GitHubPage而不需要任何设置.</li>
<li>不管你去到哪台电脑,只要这台电脑的vscode安装了这个插件和docker,就能自动识别到<code>.devcontainer</code>文件夹中的内容,然后<strong>自动帮你生成hexo镜像</strong>.</li>
</ol>
<h2 id="如何使用vscode调用docker生成一个hexo容器">如何使用vscode调用docker生成一个hexo容器</h2>
<h3 id="前提条件">前提条件:</h3>
<ol type="1">
<li><p>安装了<strong>vscode 1.35</strong>以上版本.</p></li>
<li><p>安装了<code>Remote Developmentm</code>插件.<img src="https://i.loli.net/2019/07/04/5d1dce8fb3c5d35149.png" /></p></li>
<li><p>电脑已经安装了docker.</p></li>
</ol>
<h3 id="步骤">步骤:</h3>
<ol type="1">
<li><p>使用vscode打开你想要创建hexo博客的文件夹(这个文件夹既可以是新创建的文件夹,又可以是你以前就已经用hexo写过博客的文件夹),例如我这里的<strong>hexodocker</strong>空文件夹.<img src="https://i.loli.net/2019/07/04/5d1dcf7a3fe2e53998.png" /></p></li>
<li><p>按F1,输入<code>remote</code>,在选项中选择<code>Open Folder in Container</code>,选择我们现在所在的这个hexodocker文件夹<img src="https://i.loli.net/2019/07/04/5d1dd01a72fce45611.png" /></p></li>
<li><p>下一步vscode会让你选择你所需要的基础镜像,由于我们知道hexo是基于node.js的所以要找到node.js镜像<img src="https://i.loli.net/2019/07/04/5d1dd0dacffe353417.png" /></p></li>
<li><p>选择完镜像,这时候vscode就会在你的这个目录下生成一个<code>.devcontainer</code>文件夹,这个文件夹有两个文件,一个是<code>devcontainer.json</code>,另一个是<code>Dockerfile</code>文件,vscode此时会依靠这两个文件,驱使docker生成新的镜像与容器.注意这时候生成镜像与容器所需的时间完全取决于你的电脑性能和网络性能,如果感觉vscode卡了很久都没用动,可以直接关闭vscode并且重新打开.<img src="https://i.loli.net/2019/07/04/5d1dd1c4e3c3670595.png" /></p></li>
<li><p>一切完成之后,可以看到自动生成的Dockerfile的内容,并且docker已经按照这个文件创建了镜像与容器,而且已经自动将这个容器与我们当前的文件夹进行了一个挂载.</p>
<p>但是要注意的是,这个生成的镜像却并不是最终我们所需要的,因为这些内容只是vscode帮我们自动生成的,我们要对它进行修改.<img src="https://i.loli.net/2019/07/04/5d1dd578e2bca71189.png" /></p></li>
</ol>
<h3 id="生成的镜像会有哪些问题">生成的镜像会有哪些问题</h3>
<p>根据我爬过的坑,生成的镜像并不能直接使用,会有一些问题:</p>
<ol type="1">
<li>容器内的默认时区是UTC,而中国的时区是CST,如果不把时区改过来,生成的文章时间是错误的.解决的方法请看我这一篇文章<a href="https://jiayaoo3o.github.io/2019/06/29/docker容器设置时区/">docker容器设置时区</a>.</li>
<li>容器默认是没有对中文进行处理的,所以直接通过镜像生成的容器是无法输入中文的,那当我们使用<code>hexo new "文章标题"</code> 包含中文的时候,会无法输入.解决方法请看我的这一篇文章<a href="https://jiayaoo3o.github.io/2019/06/29/解决docker容器无法输入中文问题/">解决docker容器无法输入中文问题</a>.</li>
</ol>
<h3 id="安装hexo需要哪些东西">安装hexo需要哪些东西</h3>
<p>这里不会教你使用hexo的方方面面,这些东西去看网上的博客一搜一大把,我们只需要知道,安装hexo只需要在确保node.js环境正常的情况下输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure>
<p>即可安装,所以我们也要在dockerfile中配置这两句.</p>
<h3 id="要对dockerfile进行什么修改">要对Dockerfile进行什么修改</h3>
<p>接下来直接贴上Dockerfile文件,注意看注释,并且仔细对比哪些是自动生成的,哪些是人为添加的.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Copyright (c) Microsoft Corporation. All rights reserved.</span></span><br><span class="line"><span class="comment"># Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.</span></span><br><span class="line"><span class="comment">#-------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> node:lts</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure apt</span></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">&#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get -y install --no-install-recommends apt-utils 2&gt;&amp;1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify git and needed tools are installed</span></span><br><span class="line"><span class="comment"># 这一部分直接解决了时区问题和中文输入问题</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y git procps locales \</span></span><br><span class="line"><span class="bash">    &amp;&amp; sed -i <span class="string">&#x27;/^#.* zh_CN.UTF-8 /s/^#//&#x27;</span> /etc/locale.gen \</span></span><br><span class="line"><span class="bash">    &amp;&amp; locale-gen \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\</span></span><br><span class="line"><span class="bash">    &amp;&amp; dpkg-reconfigure -f noninteractive tzdata</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove outdated yarn from /opt and install via package </span></span><br><span class="line"><span class="comment"># so it can be easily updated via apt-get upgrade yarn</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> rm -rf /opt/yarn-* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -f /usr/<span class="built_in">local</span>/bin/yarn \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -f /usr/<span class="built_in">local</span>/bin/yarnpkg \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl apt-transport-https lsb-release \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -sS https://dl.yarnpkg.com/$(lsb_release -is | tr <span class="string">&#x27;[:upper:]&#x27;</span> <span class="string">&#x27;[:lower:]&#x27;</span>)/pubkey.gpg | apt-key add - 2&gt;/dev/null \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;deb https://dl.yarnpkg.com/<span class="subst">$(lsb_release -is | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)</span>/ stable main&quot;</span> | tee /etc/apt/sources.list.d/yarn.list \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get -y install --no-install-recommends yarn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install eslint</span></span><br><span class="line"><span class="comment"># 这一部分负责安装hexo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install -g eslint \</span></span><br><span class="line"><span class="bash">    &amp;&amp; npm install -g hexo-cli \</span></span><br><span class="line"><span class="bash">    &amp;&amp; npm install hexo -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Clean up</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get autoremove -y \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get clean -y \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/* </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=dialog</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the default shell to bash instead of sh</span></span><br><span class="line"><span class="keyword">ENV</span> <span class="keyword">SHELL</span><span class="bash"> /bin/bash</span></span><br><span class="line"><span class="comment"># 这里负责设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> LANG=<span class="string">&#x27;zh_CN.utf8&#x27;</span></span><br></pre></td></tr></table></figure>
<p>修改完成之后,我们要继续按F1,然后找到<code>Rebuild Container</code>重新生成新容器,这个时候就会得到一个完全可用的hexo容器.<img src="https://i.loli.net/2019/07/04/5d1dda0281bac67071.png" /></p>
<h2 id="创建博客">创建博客</h2>
<p>这里与平时创建博客的方法就完全一致了,只要在终端中输入<code>hexo init</code>即可,而如果你以前就已经在这个文件夹里面使用<code>hexo init</code>初始化过,那建议删除<code>node_modules</code>文件夹,然后再在终端中输入<code>npm install</code>命令安装所有需要的模块.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10配置同时使用网线和WiFi访问内外网</title>
    <url>/2020/07/13/Win10%E9%85%8D%E7%BD%AE%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BA%BF%E5%92%8CWiFi%E8%AE%BF%E9%97%AE%E5%86%85%E5%A4%96%E7%BD%91/</url>
    <content><![CDATA[<h2 id="使用场景">使用场景</h2>
<p>公司内网服务器不能连外网, 或者网速很慢, 但是平时开发又有使用外网的需求, 为了不想要频繁地切换网络, 需要对网络进行配置, 使得平时访问外网可以使用WiFi热点, 而内网的服务器或者内网网站又能通过网线直接访问.</p>
<span id="more"></span>
<h2 id="设置步骤">设置步骤</h2>
<h3 id="配置两个网络的接口跃点数">配置两个网络的接口跃点数</h3>
<p>如果同时连接了网线与WiFi, 那Win10会默认所有流量都走网线的, 因为它认为网线一般来说速度会比WiFi快. 系统默认情况下, 会为每一个网络自动分配一个<a href="https://support.microsoft.com/zh-cn/help/299540/an-explanation-of-the-automatic-metric-feature-for-ipv4-routes">接口跃点数</a>, 自动选择跃点数比较小的进行网络访问, 所以第一步就是要将WiFi的自动跃点数调小, 而有线网络的跃点数调大, 先实现所有网络都走WiFi外网的功能, 配置步骤如下 :</p>
<ol type="1">
<li>右键电脑右下角的网络图标, 选择<strong>打开网络和Internet设置</strong>选项.</li>
<li>点击<strong>更改适配器选项</strong>.</li>
<li>找到已连接网线的<strong>以太网</strong>, 右键选择属性.</li>
<li>点击<strong>Internet协议版本4</strong>, 选择属性.</li>
<li>点击右下角<strong>高级</strong>.</li>
<li>取消勾选<strong>自动跃点</strong>选项, 然后手动在<strong>接口跃点数</strong>中填入64.</li>
<li>再回到更改适配器选项页面, 找到WLAN网络设备, 使用同样的步骤, 在接口跃点数中填入32.</li>
</ol>
<p>完成上述操作之后就实现了第一步, 右下角的图标应该就会变成WiFi, 并且访问网络时流量都走WiFi.</p>
<h3 id="在hosts中配置内网网站的ip地址可选-如果你内网不需要访问内网网站可以不配置">在hosts中配置内网网站的ip地址(可选, 如果你内网不需要访问内网网站可以不配置)</h3>
<p>第二步指定需要访问的内网网站的ip, 是因为接下来的第三步需要指定某个ip走某个网络接口, 而不能指定网站, 所以需要在hosts中指定网站的ip, 这样我们在浏览器中访问该网站是, 系统会自动读取hosts中的ip地址, 从而走指定的网络接口.</p>
<p>先在命令行中输入下方ping命令, 可以看到你需要访问的网站的ip地址 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 你需要配置的内网网址,例如我这里输入百度,得到的163.177.151.109就是对应的ip</span><br><span class="line">PS C:\Users\jiayao&gt; ping www.baidu.com</span><br><span class="line"></span><br><span class="line">Pinging www.a.shifen.com [163.177.151.109] with 32 bytes of data:</span><br><span class="line">Reply from 163.177.151.109: bytes=32 time=36ms TTL=53</span><br><span class="line">Reply from 163.177.151.109: bytes=32 time=42ms TTL=53</span><br><span class="line">Reply from 163.177.151.109: bytes=32 time=26ms TTL=53</span><br><span class="line">Reply from 163.177.151.109: bytes=32 time=24ms TTL=53</span><br></pre></td></tr></table></figure>
<p>得到了对应ip之后, 进入**C:*目录, 打开hosts文件, 输入网址和ip :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Copyright (c) 1993-2009 Microsoft Corp.</span><br><span class="line">#</span><br><span class="line"># This is a sample HOSTS file used by Microsoft TCP/IP for Windows.</span><br><span class="line">#</span><br><span class="line"># This file contains the mappings of IP addresses to host names. Each</span><br><span class="line"># entry should be kept on an individual line. The IP address should</span><br><span class="line"># be placed in the first column followed by the corresponding host name.</span><br><span class="line"># The IP address and the host name should be separated by at least one</span><br><span class="line"># space.</span><br><span class="line">#</span><br><span class="line"># Additionally, comments (such as these) may be inserted on individual</span><br><span class="line"># lines or following the machine name denoted by a &#x27;#&#x27; symbol.</span><br><span class="line">#</span><br><span class="line"># For example:</span><br><span class="line">#</span><br><span class="line">#      102.54.94.97     rhino.acme.com          # source server</span><br><span class="line">#       38.25.63.10     x.acme.com              # x client host</span><br><span class="line"></span><br><span class="line"># localhost name resolution is handled within DNS itself.</span><br><span class="line">#	127.0.0.1       localhost</span><br><span class="line">#	::1             localhost</span><br><span class="line"></span><br><span class="line">www.baidu.com	163.177.151.109</span><br></pre></td></tr></table></figure>
<p>然后保存即可, 如果发现无法保存, 那就另存为新的文件放到桌面, 再将新文件拖入到原始目录覆盖即可.</p>
<h3 id="配置系统的路由转发规则">配置系统的路由转发规则</h3>
<p>使用管理员权限打开cmd或者powershell, 输入<code>route print</code>可以看到当前系统的路由信息, 输入下列命令即可指定对应的ip使用对应的网络接口 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route add 你需要访问的ip mask 有线网络子网掩码 有线网络的网关 -p</span><br></pre></td></tr></table></figure>
<p>例如 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route add xx.xx.xx.xx mask 255.255.255.0 192.168.101.1 -p </span><br></pre></td></tr></table></figure>
<p>-p参数可以使得配置持久化,这样当访问xx.xx.xx.xx时系统会自动通过192.168.101.1网关进行访问, 而其他的网络访问不受影响,重启也仍然生效, 这个时候可以尝试访问内网服务器是否成功, 然后尝试访问外网网站试试能否正常访问, 如果没问题那就结束了.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Win10</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10开启ssh服务器功能</title>
    <url>/2019/03/04/Windows10%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="为什么要用ssh连接windows10">为什么要用ssh连接Windows10</h1>
<p>一般来说,想要远程连接并且使用Windows10的命令行有两种方法:</p>
<ol type="1">
<li>使用微软自带的远程桌面(RDP)或者其他第三方远程桌面控制软件(teamviewer等)远程控制Windows10,然后在软件控制界面使用命令行.</li>
<li>使用ssh连接到Windows10,然后使用命令行.</li>
</ol>
<p>而如果电脑没有公网ip,可以参考上一篇文章 <a href="https://jiayaoo3o.github.io/2019/03/01/Sakura-Frp-%E5%85%8D%E8%B4%B9%E7%9A%84%E9%AB%98%E9%80%9F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/">Sakura frp--免费的高速内网穿透工具</a>进行内网穿透,从而在外网访问本地电脑.</p>
<span id="more"></span>
<h1 id="使用powershell安装openssh">使用PowerShell安装OpenSSH</h1>
<p>要使用PowerShell安装OpenSSH前，请首先以管理员身份启动PowerShell.</p>
<ol type="1">
<li><p>在powershell中输入: <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-WindowsCapability</span> <span class="literal">-Online</span> | ? Name <span class="operator">-like</span> <span class="string">&#x27;OpenSSH*&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>此时powershell应该会显示可返回的结果:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Name  : OpenSSH.Client~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br><span class="line">State : NotPresent</span><br><span class="line">Name  : OpenSSH.Server~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br><span class="line">State : NotPresent</span><br></pre></td></tr></table></figure></li>
<li><p>分别输入以下命令安装ssh客户端与ssh服务器端:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Add-WindowsCapability</span> <span class="literal">-Online</span> <span class="literal">-Name</span> OpenSSH.Client~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Add-WindowsCapability</span> <span class="literal">-Online</span> <span class="literal">-Name</span> OpenSSH.Server~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>此时powershell会显示如下返回结果:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Path          :</span><br><span class="line">Online        : True</span><br><span class="line">RestartNeeded : False</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="使用powershell卸载openssh">使用powershell卸载openssh</h1>
<p>输入以下两条命令即可卸载刚刚安装的ssh客户端与ssh服务器:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Remove-WindowsCapability</span> <span class="literal">-Online</span> <span class="literal">-Name</span> OpenSSH.Client~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br><span class="line"><span class="built_in">Remove-WindowsCapability</span> <span class="literal">-Online</span> <span class="literal">-Name</span> OpenSSH.Server~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<h1 id="初始化ssh服务器">初始化ssh服务器</h1>
<p>仍然以管理员身份启动powershell,输入以下命令:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Start-Service</span> sshd</span><br><span class="line"><span class="comment"># 以下命令可选,但是建议启用:</span></span><br><span class="line"><span class="built_in">Set-Service</span> <span class="literal">-Name</span> sshd <span class="literal">-StartupType</span> <span class="string">&#x27;Automatic&#x27;</span></span><br><span class="line"><span class="built_in">Get-NetFirewallRule</span> <span class="literal">-Name</span> *ssh*</span><br></pre></td></tr></table></figure>
<p>初始化完成后,电脑上就已经启用了ssh服务器了,其他电脑或者手机设备输入以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -p 服务器端口 远程ssh服务器用户名@远程ssh服务器IP</span><br></pre></td></tr></table></figure>
<p>就能用ssh连上该设备了,如果在外网则需要内网穿透之后才能连上.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器设置时区</title>
    <url>/2019/06/29/docker%E5%AE%B9%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA/</url>
    <content><![CDATA[<p>docker容器中的时区一般来说都是使用<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6">UTC</a>,但是中国的时区是使用<a href="https://zh.wikipedia.org/wiki/CST">CST</a>,所以当使用某些需要依赖时间的服务时时间就会对不上,这时候就要修改容器的时区.</p>
<p>Debian和ubuntu类似但是稍微有点不同.</p>
<h2 id="ubuntu">Ubuntu</h2>
<p>ubuntu镜像本身是没有安装一个叫tzdata的软件,这个软件可以帮我们设置时区,而且在首次安装后会自动帮我们设置已经指定了的时区,所以要做的有2步,在Dockerfile文件中添加以下命令,既可在原有的RUN指令之后添加,也可另起一行RUN,但必须在<strong>apt-get update</strong>命令之后:</p>
<span id="more"></span>
<ol type="1">
<li><p>设置<code>/etc/localtime</code>文件的内容为我们需要的时区.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装tzdata软件.这时候软件首次安装会自动帮我们设置第一步已经指定的时区.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y tzdata </span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>生成镜像后可以在容器终端输入date查看时间.</p>
<h2 id="debian">Debian</h2>
<p>Debian与Ubuntu不同,它本身已经安装了tzdata软件,所以并不能像Ubuntu那样在首次安装之后自动帮我们设置时区,而要手动使用命令重新配置,步骤如下,在Dockerfile文件中添加以下命令,所有以RUN开头的命令,既可在原有的RUN指令之后添加,也可另起一行RUN.</p>
<ol type="1">
<li><p>首先检查Dockerfile的起始部分中是否有<code>ENV DEBIAN_FRONTEND=noninteractive</code>这一句,这一句命令是设置环境变量<code>DEBIAN_FRONTEND</code>的值为<code>noninteractive</code>,作用是让Debian前端命令设置为非交互式,这种模式下设置dpkg不需要人为手动输入选择操作而是自动配置,如果没有这一句,请先在文件中添加这一句.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=noninteractive</span><br></pre></td></tr></table></figure></li>
<li><p>与ubuntu一样,设置/etc/localtime文件的内容为我们需要的时区.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过非交互模式重新配置tzdata.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> dpkg-reconfigure -f noninteractive tzdata</span></span><br></pre></td></tr></table></figure></li>
<li><p>这个时候就已经设置完成了,但是要将前端命令从非交互式的重新设置为交互式的,所以要在Dockerfile的末尾添加一句命令:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=dialog</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署Oracle12c</title>
    <url>/2020/01/12/docker%E9%83%A8%E7%BD%B2Oracle12c/</url>
    <content><![CDATA[<h2 id="本机安装docker">本机安装docker</h2>
<p>安装过程省略 , 注意docker for Windows 是依赖Win10的hyper-v功能的,而hyper-v的虚拟化技术目前与VMware并不兼容 , 所以使用了VMware安装虚拟机却想要使用docker for Windows , 有可能需要卸载VMware.</p>
<h2 id="卸载原本的oracle数据库">卸载原本的Oracle数据库</h2>
<p>参考下列文章 :</p>
<p><a href="https://zhuanlan.zhihu.com/p/34256436">Oracle 11g数据库安装和卸载教程</a></p>
<ol type="1">
<li><p>开始－&gt;设置－&gt;控制面板－&gt;管理工具－&gt;服务 停止所有Oracle服务.</p></li>
<li><p>开始－&gt;程序－&gt;Oracle - OraDb11g_home1－&gt;Oracle安装产品－&gt; Universal Installer 卸装所有Oracle产品.</p></li>
<li><p>运行regedit,删除下列所有注册表内容 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\\SOFTWARE\\ORACLE</span><br><span class="line">HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\ 中所有与Oracle有关的内容</span><br><span class="line">HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\ 中所有与Oracle有关的内容</span><br><span class="line">HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\ 中所有与Oracle有关的内容</span><br><span class="line">HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\ 中所有与Oracle有关的内容</span><br></pre></td></tr></table></figure></li>
<li><p>开始－&gt;设置－&gt;控制面板－&gt;系统－&gt;高级－&gt;环境变量 删除环境变量CLASSPATH和PATH中有关Oracle的设定.</p></li>
<li><p>重新启动计算机.</p></li>
</ol>
<span id="more"></span>
<h2 id="拉取oracle12c的docker镜像">拉取Oracle12c的docker镜像</h2>
<p>从此github仓库中拉取Oracle的docker镜像 :</p>
<p><a href="https://github.com/MaksymBilenko/docker-oracle-12c">MaksymBilenko/docker-oracle-12c</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull quay.io/maksymbilenko/oracle-12c</span><br></pre></td></tr></table></figure>
<p>拉取镜像 , 此镜像大小为3.6G , 中间不可以断点续传 , 所以拉取前请确定网络通畅.</p>
<p>拉取结束后 , 输入以下命令确认已经拉取成功 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<blockquote>
<p>quay.io/maksymbilenko/oracle-12c latest bdc272e2d9c9 5 months ago 8GB</p>
</blockquote>
<h2 id="启动oracle12c镜像">启动Oracle12c镜像</h2>
<p>执行下列命令即可启动容器 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name oracle12 --restart=always -d -p 8079:8080 -p 1521:1521 quay.io/maksymbilenko/oracle-12c</span><br></pre></td></tr></table></figure>
<p>此命令会启动一个Oracle12c镜像 , 并且将数据库的8080端口与本机的8079映射 , 不用本机的8080端口是因为默认的8080端口需要留给tomcat.</p>
<p>如果本机的1521已经被占用 , 也可以选择将容器的1521端口映射到其他端口.</p>
<p>添加--restart=always参数可使每次重启电脑导致docker重启时 , Oracle12容器也重新启动.</p>
<p>如果创建时忘记加入--restart=always , 对于已经存在的容器 , 可以使用下面命令 , 使之能够自动重新启动 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker update --restart=always oracle12</span><br></pre></td></tr></table></figure>
<p>如果想要保留数据库的内容到本地目录 , 可以执行下列命令 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name oracle12 --restart=always -d -p 8079:8080 -p 1521:1521 -v /my/oracle/data:/u01/app/oracle quay.io/maksymbilenko/oracle-12c</span><br></pre></td></tr></table></figure>
<p>将上述的/my/oracle/data更改为你想要保留数据库的本地目录.</p>
<p>启动数据库之后 , 输入下列命令可以查看Oracle 12的容器创建日志 , 如果没有error出现 , 即说明创建成功.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker logs <span class="operator">-</span>f oracle12</span><br><span class="line"></span><br><span class="line">Database <span class="keyword">not</span> initialized. Initializing database.</span><br><span class="line">Starting tnslsnr</span><br><span class="line">[WARNING] [DBT<span class="number">-11209</span>] <span class="keyword">Current</span> available physical memory <span class="keyword">is</span> less than the required physical memory (<span class="number">2</span>,<span class="number">048</span>MB) <span class="keyword">for</span> creating the database.</span><br><span class="line">[WARNING] [DBT<span class="number">-11217</span>] Unable <span class="keyword">to</span> <span class="keyword">check</span> available shared memory <span class="keyword">on</span> specified node(s) (b68f267b42c8).</span><br><span class="line">[WARNING] [DBT<span class="number">-06208</span>] The <span class="string">&#x27;SYS&#x27;</span> password entered does <span class="keyword">not</span> conform <span class="keyword">to</span> the Oracle recommended standards.</span><br><span class="line">CAUSE:</span><br><span class="line">a. Oracle recommends that the password entered should be <span class="keyword">at</span> least <span class="number">8</span> characters <span class="keyword">in</span> length, contain <span class="keyword">at</span> least <span class="number">1</span> uppercase <span class="type">character</span>, <span class="number">1</span> lower <span class="keyword">case</span> <span class="type">character</span> <span class="keyword">and</span> <span class="number">1</span> digit [<span class="number">0</span><span class="number">-9</span>].</span><br><span class="line">b.The password entered <span class="keyword">is</span> a keyword that Oracle does <span class="keyword">not</span> recommend <span class="keyword">to</span> be used <span class="keyword">as</span> password</span><br><span class="line">ACTION: Specify a strong password. If required refer Oracle documentation <span class="keyword">for</span> guidelines.</span><br><span class="line">[WARNING] [DBT<span class="number">-06208</span>] The <span class="string">&#x27;SYSTEM&#x27;</span> password entered does <span class="keyword">not</span> conform <span class="keyword">to</span> the Oracle recommended standards.</span><br><span class="line">CAUSE:</span><br><span class="line">a. Oracle recommends that the password entered should be <span class="keyword">at</span> least <span class="number">8</span> characters <span class="keyword">in</span> length, contain <span class="keyword">at</span> least <span class="number">1</span> uppercase <span class="type">character</span>, <span class="number">1</span> lower <span class="keyword">case</span> <span class="type">character</span> <span class="keyword">and</span> <span class="number">1</span> digit [<span class="number">0</span><span class="number">-9</span>].</span><br><span class="line">b.The password entered <span class="keyword">is</span> a keyword that Oracle does <span class="keyword">not</span> recommend <span class="keyword">to</span> be used <span class="keyword">as</span> password</span><br><span class="line">ACTION: Specify a strong password. If required refer Oracle documentation <span class="keyword">for</span> guidelines.</span><br><span class="line">Copying database files</span><br><span class="line"><span class="number">1</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">2</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">18</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">33</span><span class="operator">%</span> complete</span><br><span class="line">Creating <span class="keyword">and</span> starting Oracle instance</span><br><span class="line"><span class="number">35</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">40</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">44</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">49</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">50</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">53</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">55</span><span class="operator">%</span> complete</span><br><span class="line">Completing Database Creation</span><br><span class="line"><span class="number">56</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">57</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">58</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">62</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">65</span><span class="operator">%</span> complete</span><br><span class="line"><span class="number">66</span><span class="operator">%</span> complete</span><br><span class="line">Executing Post Configuration Actions</span><br><span class="line"><span class="number">100</span><span class="operator">%</span> complete</span><br><span class="line">Look <span class="keyword">at</span> the log file &quot;/u01/app/oracle/cfgtoollogs/dbca/xe/xe.log&quot; <span class="keyword">for</span> further details.</span><br><span class="line">Configuring Apex console</span><br><span class="line">Database initialized. Please visit http:<span class="operator">/</span><span class="operator">/</span>#containeer:<span class="number">8080</span><span class="operator">/</span>em http:<span class="operator">/</span><span class="operator">/</span>#containeer:<span class="number">8080</span><span class="operator">/</span>apex <span class="keyword">for</span> extra configuration if needed</span><br><span class="line">Starting web management console</span><br><span class="line">PL<span class="operator">/</span><span class="keyword">SQL</span> <span class="keyword">procedure</span> successfully completed.</span><br><span class="line">Starting import <span class="keyword">from</span> <span class="string">&#x27;/docker-entrypoint-initdb.d&#x27;</span>:</span><br><span class="line">Import finished</span><br><span class="line">Database ready <span class="keyword">to</span> use. Enjoy<span class="operator">!</span> ;)</span><br><span class="line">ls: cannot access <span class="operator">/</span>docker<span class="operator">-</span>entrypoint<span class="operator">-</span>initdb.d<span class="comment">/*: No such file or directory</span></span><br></pre></td></tr></table></figure>
<p>启动需要一段时间 , 只要没有error , 都是正常现象 , 上述日志输出完成之后 , 键入Ctrl+c退出日志.</p>
<p>此时Oracle12c就已经创建完成 , 下面是默认的配置信息 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname: localhost</span><br><span class="line">port: 1521</span><br><span class="line">sid: xe</span><br><span class="line">service name: xe</span><br><span class="line">username: system</span><br><span class="line">password: oracle</span><br></pre></td></tr></table></figure>
<p>使用任意可视化数据库管理工具 , 输入上述信息即可成功连接安装sqlplus等工具.</p>
<h2 id="安装sqlplus等工具">安装sqlplus等工具</h2>
<p>如果本地此时已经不存在Oracle数据库 , 运行sql脚本时需要用到sqlplus等工具,需要单独下载sqlplus等.</p>
<p>进入页面下载并解压下列三个文件到同一目录 :</p>
<p><a href="https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html">Instant Client for Microsoft Windows (x64) 64-bit</a></p>
<figure>
<img src="https://i.loli.net/2020/01/12/4L5wXhUnZ6Qy1kI.png" alt="Untitled 1.png" /><figcaption aria-hidden="true">Untitled <em>1</em>.png</figcaption>
</figure>
<figure>
<img src="https://i.loli.net/2020/01/12/UIVj2FXTCetY3k1.png" alt="Untitled.png" /><figcaption aria-hidden="true">Untitled.png</figcaption>
</figure>
<figure>
<img src="https://i.loli.net/2020/01/12/p7uDmBvqjdKP4Mi.png" alt="Untitled 2.png" /><figcaption aria-hidden="true">Untitled <em>2</em>.png</figcaption>
</figure>
<p>这些文件都是免安装的 , 所以只需在环境变量Path中设置该地址即可 :</p>
<figure>
<img src="https://i.loli.net/2020/01/12/LYpnoesHA7URDgm.png" alt="Untitled 3.png" /><figcaption aria-hidden="true">Untitled <em>3</em>.png</figcaption>
</figure>
<h2 id="创建tnsnames.ora文件解决ora-12154-tnscould-not-resolve-the-connect-identifier-specified">创建tnsnames.ora文件解决ORA-12154: TNS:could not resolve the connect identifier specified</h2>
<p>假如已经删除了本地的oracle</p>
<p>若执行指定ip地址和端口的连接命令能够成功 , 例如 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlplus user/password@localhost:1521/xe</span><br></pre></td></tr></table></figure>
<p>但是执行不指定ip地址和端口的连接命令 , 报错<strong>ORA-12154: TNS:could not resolve the connect identifier specified</strong> :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlplus user/password@xe</span><br></pre></td></tr></table></figure>
<p>在安装sqlplus的目录中创建一个名为tnsnames.ora文件 , 粘贴下面内容 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LISTENER_ORCL =</span><br><span class="line">  (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))</span><br><span class="line"></span><br><span class="line">xe =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SERVER = DEDICATED)</span><br><span class="line">      (SERVICE_NAME = xe)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>注意端口要与自身设置一致.</p>
<p>在环境变量中添加变量TNS_ADMIN , 值为该文件所在目录 :</p>
<figure>
<img src="https://i.loli.net/2020/01/12/nde2MIVhjkOQF4C.png" alt="Untitled 4.png" /><figcaption aria-hidden="true">Untitled <em>4</em>.png</figcaption>
</figure>
<p>此时不指定数据库ip和端口也能连接到对应数据库.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署elasticsearch</title>
    <url>/2021/05/27/docker%E9%83%A8%E7%BD%B2elasticsearch/</url>
    <content><![CDATA[<h2 id="部署elasticsearch">部署elasticsearch</h2>
<h3 id="使用单节点模式">使用单节点模式</h3>
<p>在本地或者测试环境可以使用单节点模式, 简单方便</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name elasticsearch --net elastic -v /path/to/data:/usr/share/elasticsearch/data -p 9200:9200 -p 9300:9300 -d -e discovery.type=single-node -e ELASTIC_PASSWORD=xxxxx -e xpack.security.enabled=true -e xpack.security.authc.api_key.enabled=true docker.elastic.co/elasticsearch/elasticsearch:7.13.0</span><br></pre></td></tr></table></figure>
<p>成功之后ES会以单节点模式启动.</p>
<span id="more"></span>
<h3 id="使用多节点模式">使用多节点模式</h3>
<p>如果想在生产环境使用多节点模式, 可以使用以下命令 : <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name es01 \</span><br><span class="line"> --network=elastic \</span><br><span class="line"> -v /path/to/elastic/elasticsearch/es01:/usr/share/elasticsearch/data \</span><br><span class="line"> -p 9200:9200 -p 9300:9300 \</span><br><span class="line"> -d \</span><br><span class="line"> -e node.name=es01 \</span><br><span class="line"> -e cluster.name=es-cluster \</span><br><span class="line"> -e discovery.seed_hosts=es02 \</span><br><span class="line"> -e cluster.initial_master_nodes=es01,es02 \</span><br><span class="line"> -e ELASTIC_PASSWORD=xxxx \</span><br><span class="line"> -e xpack.security.enabled=true \</span><br><span class="line"> docker.elastic.co/elasticsearch/elasticsearch:7.13.0</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name es02 \</span><br><span class="line"> --network=elastic \</span><br><span class="line"> -v /path/to/jiayao/elastic/elasticsearch/es02:/usr/share/elasticsearch/data \</span><br><span class="line"> -d \</span><br><span class="line"> -e node.name=es02 \</span><br><span class="line"> -e cluster.name=es-cluster \</span><br><span class="line"> -e discovery.seed_hosts=es01 \</span><br><span class="line"> -e cluster.initial_master_nodes=es01,es02 \</span><br><span class="line"> docker.elastic.co/elasticsearch/elasticsearch:7.13.0</span><br></pre></td></tr></table></figure>
<p>也可以使用docker-compose :</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es01</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ELASTIC_PASSWORD=xxxx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xpack.security.enabled=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es02</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ELASTIC_PASSWORD=xxxx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xpack.security.enabled=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es03</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ELASTIC_PASSWORD=xxxx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xpack.security.enabled=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data01:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data02:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data03:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>
<p>volumes数据卷也可以直接绑定本地目录.</p>
<h3 id="生产模式配置服务器">生产模式配置服务器</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure>
<h2 id="部署kibana">部署kibana</h2>
<p>注意, 在docker中如果想用-e参数将配置作为环境变量传入kibana中, 则所有的-e参数都是全大写且用下划线分割的： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name kibana \</span><br><span class="line">  --net elastic \</span><br><span class="line">  -p 5601:5601 \</span><br><span class="line">  -e ELASTICSEARCH_HOSTS=http://elasticsearch:9200 \</span><br><span class="line">  -e ELASTICSEARCH_PASSWORD=xxxxxxxx \</span><br><span class="line">  -e ELASTICSEARCH_USERNAME=elastic \</span><br><span class="line">  -e XPACK_SECURITY_ENABLED=true \</span><br><span class="line">  -e XPACK_SECURITY_ENCRYPTIONKEY=something_at_least_32_characters \</span><br><span class="line">  -e XPACK_REPORTING_ENCRYPTIONKEY=something_at_least_32_characters \</span><br><span class="line">  -e XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=something_at_least_32_characters \</span><br><span class="line">  -e I18N_LOCALE=zh-CN \</span><br><span class="line">  -d docker.elastic.co/kibana/kibana:7.13.1</span><br></pre></td></tr></table></figure></p>
<h2 id="部署filebeat收集日志">部署filebeat收集日志</h2>
<p>按照kibana中的指示安装filebeat之后, 配置filebeat.yml文件收集docker日志 :</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="comment"># 类型选择docker</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">docker</span></span><br><span class="line">  <span class="comment"># 容器ID使用&#x27;*&#x27;代替，表示获取所有容器</span></span><br><span class="line">  <span class="attr">containers.ids:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="comment"># 配置处理器</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">   <span class="comment"># 添加docker元数据</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">add_docker_metadata:</span> <span class="string">~</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接输出到es</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;localhost:9200&quot;</span>]</span><br><span class="line">  <span class="attr">username:</span> <span class="string">&quot;elastic&quot;</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">&quot;xxxx&quot;</span></span><br><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">&quot;http://localhost:5601&quot;</span></span><br><span class="line"><span class="attr">setup.ilm.rollover_alias:</span> <span class="string">&quot;自定义的索引命名&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署nginx反向代理</title>
    <url>/2021/05/27/docker%E9%83%A8%E7%BD%B2nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="创建nginx.conf配置文件">创建nginx.conf配置文件</h2>
<p>通过nginx官方镜像创建nginx.conf模板, 然后在该模板上进行修改即可</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">user</span>  <span class="string">nginx;</span></span><br><span class="line"><span class="attr">worker_processes</span>  <span class="string">auto;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">error_log</span>  <span class="string">/var/log/nginx/error.log notice;</span></span><br><span class="line"><span class="attr">pid</span>        <span class="string">/var/run/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">events</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">worker_connections</span>  <span class="string">1024;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">include</span>       <span class="string">/etc/nginx/mime.types;</span></span><br><span class="line">    <span class="attr">default_type</span>  <span class="string">application/octet-stream;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">log_format</span>  <span class="string">main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="meta">&#x27;$status</span> <span class="string">$body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="meta">&#x27;&quot;$http_user_agent&quot;</span> <span class="string">&quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">access_log</span>  <span class="string">/var/log/nginx/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">sendfile</span>        <span class="string">on;</span></span><br><span class="line"><span class="comment">    #tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">keepalive_timeout</span>  <span class="string">65;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">include</span> <span class="string">/etc/nginx/conf.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">server&#123;</span></span><br><span class="line">        <span class="attr">server_name</span> <span class="string">被访问的域名;</span></span><br><span class="line">        <span class="attr">listen</span> <span class="string">8080;</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">            <span class="attr">proxy_pass</span> <span class="string">http://target-server;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">target-server&#123;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">xx.xx.xx.xx:xxxx;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="运行nginx">运行nginx</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name nginx -p 80:8080 -v /host/path/nginx.conf:/etc/nginx/nginx.conf:ro -d nginx:stable</span><br></pre></td></tr></table></figure>
<p>注意这里最关键的是对端口的映射, 观察这个命令, 并不是直接将host的80端口和容器的80端口进行映射, 而是先将host的80和nginx的8080进行绑定, 然后nginx再对8080端口进行监听然后反向代理.</p>
<p>这么做的原因是默认普通权限下容器内nginx是不能够监听1024以下的端口的, 需要提升权限, 但是通过80-&gt;8080的映射转换, 就可以正常启动了.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>frp配置文件记录</title>
    <url>/2021/05/27/frp%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="下载frp">下载frp</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_linux_amd64.tar.gz</span><br><span class="line">tar -zxvf ./*.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="frpc.ini">frpc.ini</h2>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="string">xx.xx.xx.xx</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="string">7000</span></span><br><span class="line"><span class="attr">token</span>=<span class="string">xxxxxxxxxx</span></span><br><span class="line"><span class="attr">login_fail_exit</span>=<span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[rdp]</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">tcp</span></span><br><span class="line"><span class="attr">local_ip</span> = <span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="string">3389</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="string">3389</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>login_fail_exit=false这个配置能够让程序即使链接失败也不会自动退出, 例如当设置frpc为开机启动, 但是刚开机电脑会没有网络这种情况, 如果不设置该配置项, 失败次数过多之后frpc会自动退出.</p>
</blockquote>
<span id="more"></span>
<h2 id="frps_full.ini">frps_full.ini</h2>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vhost_http_port = 80</span></span><br><span class="line"><span class="comment">#vhost_https_port = 443</span></span><br><span class="line"><span class="attr">dashboard_user</span> = <span class="string">xxx</span></span><br><span class="line"><span class="attr">dashboard_pwd</span> = <span class="string">xxxxx</span></span><br><span class="line"><span class="attr">token</span> = <span class="string">xxxxx</span></span><br><span class="line"><span class="attr">allow_ports</span> = <span class="string">2000-50000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[plugin.user-manager]</span></span><br><span class="line"><span class="comment">#addr = 127.0.0.1:9000</span></span><br><span class="line"><span class="comment">#path = /handler</span></span><br><span class="line"><span class="comment">#ops = Login</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[plugin.port-manager]</span></span><br><span class="line"><span class="comment">#addr = 127.0.0.1:9001</span></span><br><span class="line"><span class="comment">#path = /handler</span></span><br><span class="line"><span class="comment">#ops = NewProxy</span></span><br></pre></td></tr></table></figure>
<p>下面两个插件如果用不上需要手动注释.</p>
<h2 id="安装frp为systemd服务">安装frp为systemd服务</h2>
<p>编辑对应的service文件, 如果需要配置服务端, 则编辑frps.service, 如果需要配置客户端, 则编辑frpc.service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nano ./systemd/frpc.service</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=<span class="string">Frp Client Service</span></span><br><span class="line"><span class="attr">After</span>=<span class="string">network.target</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=<span class="string">simple</span></span><br><span class="line"><span class="attr">User</span>=<span class="string">nobody</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="string">on-failure</span></span><br><span class="line"><span class="attr">RestartSec</span>=<span class="string">5s</span></span><br><span class="line"><span class="attr">ExecStart</span>=<span class="string">/usr/bin/frpc -c /etc/frp/frpc.ini</span></span><br><span class="line"><span class="attr">ExecReload</span>=<span class="string">/usr/bin/frpc reload -c /etc/frp/frpc.ini</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span><br></pre></td></tr></table></figure>
<p>这里要将User=nobody改成对应的用户名.</p>
<p>移动执行文件frpc和配置文件frpc.ini到对应的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp ./frpc /usr/bin</span><br><span class="line">sudo mkdir /etc/frp</span><br><span class="line">sudo cp ./frpc.ini /etc/frp/frpc.ini</span><br></pre></td></tr></table></figure>
<p>复制服务文件到systemd目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp ./systemd/frpc.service /etc/systemd/system/</span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service frpc start</span><br><span class="line">sudo service frpc status</span><br></pre></td></tr></table></figure>
<p>如果能成功启动, 则将服务配置为开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable frpc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>git项目换行符LF与CRLF导致的大量更改解决办法</title>
    <url>/2019/06/26/git%E9%A1%B9%E7%9B%AE%E6%8D%A2%E8%A1%8C%E7%AC%A6LF%E4%B8%8ECRLF%E5%AF%BC%E8%87%B4%E7%9A%84%E5%A4%A7%E9%87%8F%E6%9B%B4%E6%94%B9%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h2 id="产生该问题的原因">产生该问题的原因</h2>
<p>产生该问题的原因是由于Windows平台和linux平台的默认换行符是不一样的,linux使用的是<code>0x0A(LF)</code>而Windows使用的是<code>0x0D0A(CRLF)</code>,这就导致了当Windows下的代码放到linux下运行时,虽然代码没有错,但是linux下的git检测到项目的换行符为CRLF时会自动换成LF.</p>
<span id="more"></span>
<h2 id="该问题的症状">该问题的症状</h2>
<p>出现这个问题的症状表现为git会提示项目的每一个文件的所有位置都发生了修改,但是查看diff的时候发现其实哪都没修改,这是因为换行符被换了但是我们是看不出来的.</p>
<h2 id="解决该问题的方法">解决该问题的方法</h2>
<p>由于代码多是运行在linux,所以现在主流的换行符标准就是LF,所以我们的项目一开始就应该有将换行符设置为LF的意识.</p>
<p>项目一开始创建,还没有加入git仓库的时候就应该将换行符设置为LF,vscode等工具都提供了这个简单的功能,</p>
<figure>
<img src="https://i.loli.net/2019/06/09/5cfc7e70d69e995247.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>如果项目已经加入了git仓库,那就让git帮我们解决问题,git有一个<code>autocrlf</code>配置,可以在我们提交时自动转换换行符,它有3个选项:</p>
<ul>
<li><strong>true:</strong> 提交时转换为 LF，检出时转换为 CRLF</li>
<li><strong>false:</strong> 提交检出均不转换</li>
<li><strong>input:</strong> 提交时转换为LF，检出时不转换</li>
</ul>
<p>另一个设置项<code>safecrlf</code>用于检查文件是否包含着混合换行符,也有3个选项:</p>
<ul>
<li><strong>true:</strong> 拒绝提交包含混合换行符的文件</li>
<li><strong>false:</strong> 允许提交包含混合换行符的文件</li>
<li><strong>warn:</strong> 提交包含混合换行符的文件时给出警告</li>
</ul>
<p>所以,如果我们要将已经加入git的大量CRLF结尾文件批量转换成LF结尾的文件,可以这样设置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br><span class="line">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure>
<p>这样设置之后,先将项目提交一次,这样所有的文件就都会被改成LF结尾.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux安装docker</title>
    <url>/2019/06/26/linux%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<h2 id="不要直接安装apt仓库内的docker.io">不要直接安装apt仓库内的docker.io</h2>
<p>apt仓库中的docker.io是很老版本的docker,现在新版的docker是直接叫做docker-ce,不要直接<code>sudo apt install docker.io</code></p>
<p>如果你已经这样安装了docker.io,请输入以下命令卸载:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>
<p>此时docker.io会被卸载,但是以前下载的images, containers,volumes都会得以保留.</p>
<span id="more"></span>
<h2 id="通过仓库安装">通过仓库安装</h2>
<ol type="1">
<li><p>升级仓库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li>
<li><p>通过apt安装以下软件使得可以通过https使用仓库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure></li>
<li><p>添加Docker的官方GPG密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li>
<li><p>使用下面命令添加稳定版仓库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>开始安装docker-ce:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">   sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="通过deb包安装">通过deb包安装</h2>
<ol type="1">
<li><p>去<a href="https://download.docker.com/linux/ubuntu/dists/"><code>https://download.docker.com/linux/ubuntu/dists/</code></a>选择你的Ubuntu版本，在<code>pool/stable/</code>里找到合适你版本的deb包.</p></li>
<li><p>通过下面命令直接安装deb包,注意找到自己下载deb包的目录和包名.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i /path/to/package.deb</span><br></pre></td></tr></table></figure></li>
<li><p>如果想要升级docker-ce,要再去下载新的deb包重复安装.</p></li>
</ol>
<h2 id="使用脚本安装">使用脚本安装</h2>
<p>这个方法好处是非常的简单,一个脚本全部搞完,并且树莓派只能以这种方式安装docker.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<p>以后更新只要在apt内更新即可,不需要重新运行脚本.</p>
<h2 id="添加用户到docker组">添加用户到docker组</h2>
<p>如果不想每次运行docker都要在前面加入sudo,那可以将当前用户加入docker组:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker 用户名</span><br></pre></td></tr></table></figure>
<p>注销,并且重新登录即可生效.</p>
<h2 id="卸载docker-ce">卸载docker-ce</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure>
<p>主机上的镜像,容器都不会自动删除,想要手动删除,可以输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10下UWP应用使用系统代理</title>
    <url>/2019/06/28/windows10%E4%B8%8BUWP%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>由于UWP本身运行在沙盒中,默认情况下是不能直接访问localhost的,所以也就不能直接访问本机的代理服务,但是Win10自身有一个叫CheckNetIsolation.exe 的命令行工具可以将uwp应用设置为使用代理.</p>
<h2 id="单独指定某个uwp应用可以代理">单独指定某个UWP应用可以代理</h2>
<ol type="1">
<li><p>通过Win+S在搜索框输入"注册表"来打开<strong>注册表编辑器</strong><img src="https://i.loli.net/2019/06/28/5d16280329cd127618.png" /></p></li>
<li><p>在上图的蓝色框处,输入下面的地址:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings</span><br></pre></td></tr></table></figure>
<p>就会定位到上图的位置,左边的的密密麻麻的都是电脑上UWP应用的SID值,而右边绿色框的DIsplayName就是你点击的某个uwp应用的名字,现在要做的就是慢慢按方向键下键,寻找你需要进行代理的uwp软件.</p></li>
<li><p>找到需要代理的软件之后,复制该软件红色框处的SID,然后在CMD中输入以下命令:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">CheckNetIsolation.exe loopbackexempt <span class="literal">-a</span> <span class="literal">-p</span>=UWP的SID</span><br></pre></td></tr></table></figure>
<p>就可以直接生效了.</p></li>
<li><p>如果需要取消代理,恢复原样,在CMD中输入以下命令:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">CheckNetIsolation.exe loopbackexempt <span class="literal">-d</span> <span class="literal">-p</span>=UWP的SID</span><br></pre></td></tr></table></figure>
<h2 id="对所有uwp应用设置可以代理">对所有UWP应用设置可以代理</h2>
<p>从上面的方法可以知道,想要对某个uwp使用代理,就只要知道它的SID然后设置就可以了,现在想要对所有uwp进行设置,也就是只要知道所有uwp的SID.</p>
<p>在CMD中输入以下命令即可对所有UWP进行设置:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> /F <span class="string">&quot;tokens=11 delims=\&quot;</span> %p <span class="keyword">IN</span> (<span class="string">&#x27;REG QUERY &quot;HKCU\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings&quot;&#x27;</span>) <span class="keyword">DO</span> CheckNetIsolation.exe LoopbackExempt <span class="literal">-a</span> <span class="literal">-p</span>=%p</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10专业版激活</title>
    <url>/2019/05/03/windows10%E4%B8%93%E4%B8%9A%E7%89%88%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<h2 id="激活windows的原理">激活Windows的原理</h2>
<p>GitHub上的这个开源的<a href="https://github.com/Wind4/vlmcsd">KMS模拟器项目</a>能够让你的服务器成为一台kms,所以只要你有一台服务器,在服务器上运行这个软件,即可用于激活Windows.</p>
<p>而你在服务器运行这个软件之后,需要激活的电脑只需要在命令行中输入几句激活的指令就可以连接到该服务器进行激活验证,<strong>这个过程不需要安装任何不安全的软件,和网上的所谓破解激活软件完全不一样</strong>.</p>
<p>如果你没有服务器,也可以用网上别人公开的服务器,理论上只要对方的服务器没有挂掉,你就可以一直激活使用,而且kms服务器只是一个激活服务器,并不能操作客户端,所以最多只是这个激活服务器不能用了,网上说的能用kms服务器控制你的电脑,那就是扯淡.</p>
<span id="more"></span>
<h2 id="激活windows10专业版">激活Windows10专业版</h2>
<ol type="1">
<li><p>以管理员身份运行powershell</p></li>
<li><p>输入以下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">slmgr.vbs <span class="literal">-upk</span></span><br><span class="line">slmgr.vbs <span class="literal">-ipk</span> W269N<span class="literal">-WFGWX</span><span class="literal">-YVC9B</span><span class="literal">-4J6C9</span><span class="literal">-T83GX</span></span><br><span class="line">slmgr.vbs <span class="literal">-skms</span> <span class="number">119.29</span>.<span class="number">248.79</span></span><br><span class="line">slmgr.vbs <span class="literal">-ato</span></span><br><span class="line">slmgr.vbs <span class="literal">-dlv</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="激活windows10企业版">激活Windows10企业版</h2>
<ol type="1">
<li><p>以管理员身份运行powershell</p></li>
<li><p>输入以下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">slmgr.vbs <span class="literal">-upk</span></span><br><span class="line">slmgr.vbs <span class="literal">-ipk</span> NPPR9<span class="literal">-FWDCX</span><span class="literal">-D2C8J</span><span class="literal">-H872K</span><span class="literal">-2YT43</span></span><br><span class="line">slmgr.vbs <span class="literal">-skms</span> <span class="number">119.29</span>.<span class="number">248.79</span></span><br><span class="line">slmgr.vbs <span class="literal">-ato</span></span><br><span class="line">slmgr.vbs <span class="literal">-dlv</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10安装MySQL</title>
    <url>/2019/04/24/windows10%E5%AE%89%E8%A3%85MySQL/</url>
    <content><![CDATA[<h2 id="安装mysql">安装MySQL</h2>
<p>使用<a href="https://jiayaoo3o.github.io/2019/01/30/Windows%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8-scoop/">scoop</a>直接安装mysql:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scoop install mysql</span><br></pre></td></tr></table></figure>
<p>scoop会自动帮我们设置好环境变量.</p>
<span id="more"></span>
<h2 id="配置mysql">配置MySQL</h2>
<p>编辑mysql安装目录下的my.ini文件,对应位置添加如下数据:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir=C:/Users/jiayao/scoop/apps/mysql/current</span><br><span class="line">default-time-zone = &#x27;+8:00&#x27;</span><br></pre></td></tr></table></figure>
<p>因为scoop已经自动配置好了mysql,所以直接使用启动命令启动mysql即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>
<p>登录数据库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>不用输入密码直接回车,即可进入数据库.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter password:</span><br></pre></td></tr></table></figure>
<p>进入数据库之后,执行以下命令修改用户密码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure>
<p>刷新用户权限:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>关闭数据库,再重新启动:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>
<p>输入用户名和密码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>即可连上数据库.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下的软件管理神器:scoop</title>
    <url>/2019/01/30/windows%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8-scoop/</url>
    <content><![CDATA[<h1 id="scoop是什么">scoop是什么</h1>
<p><a href="https://scoop.sh/">Scoop</a>是一款Windows下的命令行软件管理工具,类似于ubuntu下的apt,它存在的意义,就是为了解决Windows下没有一个统一包管理器的痛点,有了scoop,在Windows下也能一条命令直接安装,升级,卸载,切换软件的不同版本等</p>
<span id="more"></span>
<hr />
<h1 id="安装scoop">安装scoop</h1>
<p>scoop的使用与安装都要依赖PowerShell,所以电脑系统最好是Windows10的.安装方法很简单,以下命令都在PowerShell中输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set-executionpolicy remotesigned -s currentuser</span><br></pre></td></tr></table></figure>
<p>会提示是否允许执行远程脚本,输入a同意全部.</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">iex</span> (<span class="built_in">new-object</span> net.webclient).downloadstring(<span class="string">&#x27;https://get.scoop.sh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行上面这条命令,scoop就会安装在你的C: 用户名,这时候在PowerShell中输入</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scoop help</span><br></pre></td></tr></table></figure>
<p>就会显示出scoop的基本操作命令</p>
<p><img src="https://i.loli.net/2019/01/31/5c528038a674b.png" /></p>
<hr />
<h1 id="使用scoop">使用scoop</h1>
<p>scoop的用法与一般的Linux软件类似,都是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop 操作 对象软件</span><br></pre></td></tr></table></figure>
<h2 id="查找软件">查找软件</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop search 软件名</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop search vim</span><br></pre></td></tr></table></figure>
<p>如果后面不跟软件名,直接输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop search			</span><br></pre></td></tr></table></figure>
<p>那scoop会直接显示仓库目前有的所有软件,可以一个一个慢慢看</p>
<h2 id="安装软件">安装软件</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install 软件名</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install vim</span><br><span class="line">scoop install python</span><br><span class="line">scoop install nodejs</span><br></pre></td></tr></table></figure>
<p>即可安装vim</p>
<h2 id="卸载软件">卸载软件</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop uninstall 软件名</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop uninstall vim</span><br></pre></td></tr></table></figure>
<h2 id="升级软件">升级软件</h2>
<p>如果想要查看今天仓库更新了哪些软件,输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop update</span><br></pre></td></tr></table></figure>
<p>就会显示所有今天升级更新的软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop update 软件名</span><br></pre></td></tr></table></figure>
<p>即可更新对应软件</p>
<p>如果想要直接升级所有软件,输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop update *</span><br></pre></td></tr></table></figure>
<p>即可升级所有软件</p>
<h2 id="检查软件状态">检查软件状态</h2>
<p>如果想要知道自己有哪些软件可以升级,输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop status</span><br></pre></td></tr></table></figure>
<p>如果想要查看scoop是否出现了问题,输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop checkup</span><br></pre></td></tr></table></figure>
<h2 id="清理缓存">清理缓存</h2>
<p>每当scoop下载了软件之后,再卸载这个软件,当初下载的这个软件包文件还会存在,所以下一次安装就不用再下载了,想要清理缓存,可以输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop cache rm 软件名</span><br></pre></td></tr></table></figure>
<p>想要清除所有缓存,可以输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop cache rm *</span><br></pre></td></tr></table></figure>
<h2 id="删除软件旧版本">删除软件旧版本</h2>
<p>每当scoop升级了软件之后,旧版本仍会保留在电脑上,以便于切换到旧版本,想要删除软件旧版本,输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop cleanup 软件名</span><br></pre></td></tr></table></figure>
<p>想要删除所有软件的所有旧版本,输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop cleanup *</span><br></pre></td></tr></table></figure>
<h2 id="查看软件主页">查看软件主页</h2>
<p>如果你想了解仓库中的某一个软件,输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop home 软件名</span><br></pre></td></tr></table></figure>
<p>即可打开软件的主页</p>
<h2 id="切换软件版本">切换软件版本</h2>
<p>如果同时安装了某个软件的不同大版本,例如python(默认的python是python3)和python27,或者同时安装了java8和java11,可以通过:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop reset 想要使用的版本名称</span><br></pre></td></tr></table></figure>
<p>进行切换</p>
<h2 id="设置使用代理">设置使用代理</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop config proxy 127.0.0.1:10809</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="添加额外的仓库bucket">添加额外的仓库bucket</h1>
<p>scoop中的仓库被叫做bucket,安装好的scoop默认会带有一个主仓库,名字就叫Scoop,主仓库里面的软件,有很多,但是基本都是比较适合程序员的软件,更重要的一点是,要入选主仓库的软件,都是没有GUI的,也就是说都是命令行软件,而scoop官方还有一个第三方bucket,里面有更多的常用软件,所以我们要添加额外的仓库</p>
<h2 id="查看可添加仓库">查看可添加仓库</h2>
<p>想要查看可添加仓库,输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket known</span><br></pre></td></tr></table></figure>
<p>即可显示仓库列表</p>
<p><img src="https://i.loli.net/2019/01/31/5c529f03b26cc.png" /></p>
<p>一般来说,比较有用的仓库如下,要添加仓库,输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket add extras</span><br><span class="line">scoop bucket add java</span><br><span class="line">scoop bucket add jetbrains</span><br></pre></td></tr></table></figure>
<p>添加了java库之后,就可以安装各个版本的jdk了,而且scoop会帮你自动设置好环境变量,真正做到了开箱即用,爽翻.</p>
<p>如果想要添加不在上述列表的非官方仓库的话,输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket add 仓库名 仓库的github地址</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket add Ash258 &#x27;https://github.com/Ash258/scoop-Ash258.git&#x27;</span><br></pre></td></tr></table></figure>
<p>即可添加非官方仓库</p>
<h2 id="查看已经添加的仓库">查看已经添加的仓库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket list</span><br></pre></td></tr></table></figure>
<h2 id="删除已经添加的仓库">删除已经添加的仓库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket rm 仓库名</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="scoop的本地文件目录">Scoop的本地文件目录</h1>
<p>上面已经说了,scoop是安装在用户目录下的,目录格式为:</p>
<p><img src="https://i.loli.net/2019/01/31/5c52a47d6b568.png" /></p>
<p>这里最值得称道的是persist文件夹,因为我们知道,scoop安装的所有软件都是安装在scoop文件夹下的,那如果软件升级了的话,以前旧软件的设置和数据是不是全部清除了呢?例如vscode上的设置和安装的插件,是不是升级了之后,都没有了呢?不是的,因为scoop会将各个软件的设置数据,例如vscode软件的data文件夹(vscode的设置和插件都放在data文件夹),单独放到persist文件夹中,在用软链接链接到软件所在的文件夹,这样,每次升级软件,persist文件夹的各个软件的设置数据都会保持不变,从而保存设置.</p>
<p>另一个需要注意的是,所有的对scoop操作都不要在文件夹中进行,因为有可能会破坏scoop的文件结构,想要对scoop进行任何操纵,都需要在命令行中进行</p>
<hr />
<h1 id="scoop的优缺点分析">scoop的优缺点分析</h1>
<p>scoop作为一款Windows下的包管理器,意义是非凡的,尤其是对于程序员而言,它极大地解决了程序员安装各种开发环境的麻烦,一键自动设置环境变量,包括:</p>
<ul>
<li>dotnet core</li>
<li>java</li>
<li>python</li>
<li>nodejs</li>
<li>go</li>
<li>kotlin</li>
<li>ruby</li>
</ul>
<p>各种软件,包括:</p>
<ul>
<li>idea</li>
<li>vscode</li>
<li>vim</li>
<li>git</li>
<li>pycharm</li>
<li>maven</li>
<li>make</li>
<li>gcc</li>
<li>gdb</li>
<li>mysql</li>
<li>gradle</li>
<li>android-sdk</li>
</ul>
<p>等,可以说,scoop真的是每一个程序员的必备神器</p>
<h2 id="scoop的优点">scoop的优点</h2>
<ol type="1">
<li>干净,不会污染系统,保持最高度清洁.scoop安装的所有软件都会放在用户目录的scoop文件夹下</li>
<li>简单,一句命令即可安装软件,开箱即用,不用再去各个软件的官网下载软件</li>
<li>省心,升级软件及时,软件数量多,解决问题快</li>
</ol>
<h2 id="scoop的缺点">scoop的缺点</h2>
<p>虽然scoop这么强大,但是它还是有缺点的</p>
<ol type="1">
<li>网络问题,因为scoop是外国人发明的,而且scoop里面的软件有一些也是外国软件,并且scoop的每一个软件下载地址都是软件的官网,所以有时候必须要科学上网才能下载,并且下载速度也不稳定,有一些软件很快,有一些软件却很慢</li>
<li>安装问题,scoop的安装会有一个问题,就是如果你安装某个软件失败了,再安装一次,这时候scoop会提示你软件已经安装过了,但是安装失败又用不了,所以这个时候要先执行一次scoop uninstall卸载刚刚失败的软件,再安装</li>
</ol>
<hr />
<h1 id="总结">总结</h1>
<p>scoop可以说是我2018年遇到的最好用,对我帮助最大的软件,我第一次用这个软件的时候,马上拿出信用卡进行捐赠了,希望你也能喜欢这一款神器,💉 💧 🐮 🍺</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
        <tag>包管理器</tag>
        <tag>scoop</tag>
      </tags>
  </entry>
  <entry>
    <title>下载vs2017离线安装包</title>
    <url>/2019/03/19/%E4%B8%8B%E8%BD%BDvs2017%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85/</url>
    <content><![CDATA[<ol type="1">
<li><p>前往微软<a href="https://visualstudio.microsoft.com/zh-hans/downloads/">VisualStudio官网</a>下载vs2017在线安装器,下载完成后的文件名字应该是类似这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vs_community__1377279628.1540623861.exe</span><br></pre></td></tr></table></figure></li>
<li><p>将该exe文件复制到准备要下载离线安装包的目录,例如D:.</p></li>
<li><p>按住shift键,鼠标在当前文件夹下右键点击在此处打开powershell.</p></li>
<li><p>输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\vs_community__1377279628.1540623861.exe --layout D:\vs2017 --lang zh-CN</span><br></pre></td></tr></table></figure>
<p>即可开始下载,大小应该是20G起步,所以注意网络环境,而且下载时最好科学上网,不然某些组件会下载失败.</p></li>
<li><p>下载完成后,双击运行下载目录下的vs_community.exe即可进入安装界面开始安装.</p></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>备忘</tag>
        <tag>VisualStudio2017</tag>
      </tags>
  </entry>
  <entry>
    <title>优质软件集锦</title>
    <url>/2019/03/26/%E4%BC%98%E8%B4%A8%E8%BD%AF%E4%BB%B6%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<h2 id="操作系统">操作系统</h2>
<h3 id="windows10-1903"><a href="https://jiayaoo3o.github.io/2019/03/11/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E7%BB%9D%E5%AF%B9%E7%BA%AF%E5%87%80%E7%9A%84Windows10%E9%95%9C%E5%83%8F/">Windows10</a> 1903+</h3>
<p>最好用的linux发行版</p>
<hr />
<h2 id="软件包管理器">软件包管理器</h2>
<h3 id="scoop"><a href="https://jiayaoo3o.github.io/2019/01/30/Windows%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8-scoop/">scoop</a></h3>
<h2 id="section"><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set-executionpolicy</span> remotesigned <span class="literal">-s</span> currentuser</span><br><span class="line"><span class="built_in">iex</span> (<span class="built_in">new-object</span> net.webclient).downloadstring(<span class="string">&#x27;https://get.scoop.sh&#x27;</span>)</span><br><span class="line">scoop bucket add java</span><br><span class="line">scoop bucket add extras</span><br><span class="line">scoop bucket add Ash258 <span class="string">&#x27;https://github.com/Ash258/scoop-Ash258.git&#x27;</span></span><br><span class="line">scoop bucket add jetbrains</span><br></pre></td></tr></table></figure></h2>
<span id="more"></span>
<h2 id="开发环境">开发环境</h2>
<h3 id="python">python</h3>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install python</span><br></pre></td></tr></table></figure> ### dotnet core</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install dotnet-sdk</span><br></pre></td></tr></table></figure>
<h3 id="java">java</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install openjdk11</span><br><span class="line">scoop isntall corretto8</span><br></pre></td></tr></table></figure>
<h3 id="kotlin">kotlin</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install kotlin</span><br></pre></td></tr></table></figure>
<h3 id="maven">maven</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install maven</span><br></pre></td></tr></table></figure>
<h3 id="gradle">gradle</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install gradle</span><br></pre></td></tr></table></figure>
<h3 id="tomcat">tomcat</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install tomcat</span><br></pre></td></tr></table></figure>
<h3 id="gcc">gcc</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install gcc</span><br></pre></td></tr></table></figure>
<h3 id="gdb">gdb</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install gdb</span><br></pre></td></tr></table></figure>
<h3 id="cmake">cmake</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install cmake</span><br></pre></td></tr></table></figure>
<h3 id="nodejs">nodejs</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install nodejs</span><br></pre></td></tr></table></figure>
<h3 id="go">go</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install go</span><br></pre></td></tr></table></figure>
<h3 id="android">android</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install android-sdk</span><br></pre></td></tr></table></figure>
<h3 id="flutter">flutter</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install flutter</span><br></pre></td></tr></table></figure>
<h3 id="dart">dart</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install dart</span><br></pre></td></tr></table></figure>
<h3 id="mongodb">mongodb</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install mongodb</span><br></pre></td></tr></table></figure>
<h3 id="mysql">mysql</h3>
<h2 id="section-1"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install mysql</span><br></pre></td></tr></table></figure></h2>
<h2 id="开发工具">开发工具</h2>
<h3 id="vscode">vscode</h3>
<p>宇宙第一编辑器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install vscode-portable</span><br></pre></td></tr></table></figure></p>
<h3 id="visual-studio-2019"><a href="https://visualstudio.microsoft.com/zh-hans/">Visual Studio 2019</a></h3>
<p>宇宙第一ide ### <a href="https://jiayaoo3o.github.io/2019/03/21/Git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/">git</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install git</span><br></pre></td></tr></table></figure>
<h3 id="svn">svn</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install tortoisesvn</span><br></pre></td></tr></table></figure>
<h3 id="android-studio">android-studio</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install android-studio</span><br></pre></td></tr></table></figure>
<h3 id="idea">idea</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install IntelliJ-IDEA-portable</span><br></pre></td></tr></table></figure>
<h3 id="pycharm">pycharm</h3>
<h2 id="section-2"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install pycharm</span><br></pre></td></tr></table></figure></h2>
<h2 id="文本编辑器">文本编辑器</h2>
<h3 id="vim">vim</h3>
<p>命令行文本编辑器,退出请按esc,输入:!q <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install vim</span><br></pre></td></tr></table></figure></p>
<h3 id="typora">typora</h3>
<p>体验优异的markdown编辑器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install typora</span><br></pre></td></tr></table></figure> ------ ## 命令行工具</p>
<h3 id="cmder">cmder</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install cmder</span><br></pre></td></tr></table></figure>
<h3 id="terminus">terminus</h3>
<p>高颜值命令行终端 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install terminus</span><br></pre></td></tr></table></figure> ### WindowsTerminal</p>
<p>微软新出的terminal工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install WindowsTerminal</span><br></pre></td></tr></table></figure>
<table style="width:10%;">
<colgroup>
<col style="width: 9%" />
</colgroup>
<tbody>
<tr class="odd">
<td>## 浏览器</td>
</tr>
<tr class="even">
<td>### chrome</td>
</tr>
<tr class="odd">
<td><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install chrome</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="even">
<td>### firefox</td>
</tr>
<tr class="odd">
<td><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install firefox</span><br></pre></td></tr></table></figure> ### 新edge</td>
</tr>
</tbody>
</table>
<h2 id="文件解压工具">文件解压工具</h2>
<h3 id="bandizip">bandizip</h3>
<h2 id="section-3"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install bandizip</span><br></pre></td></tr></table></figure></h2>
<h2 id="文件搜索工具">文件搜索工具</h2>
<h3 id="everything">everything</h3>
<p>体验优异的文件搜索工具,请将everything开机启动并且一直放在后台 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install everything</span><br></pre></td></tr></table></figure> ------ ## 软件卸载工具</p>
<h3 id="geekuninstaller">geekuninstaller</h3>
<p>卸载软件后自动检测文件残留 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install geekuninstaller</span><br></pre></td></tr></table></figure> ------ ## 视频播放器</p>
<h3 id="potplayer">potplayer</h3>
<p>最好用的视频播放器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install potplayer</span><br></pre></td></tr></table></figure> ------ ## 科学上网</p>
<h3 id="shadowsocksr">shadowsocksr</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install shadowsocksr-csharp</span><br></pre></td></tr></table></figure>
<h3 id="v2rayn">V2rayN</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install v2rayn</span><br></pre></td></tr></table></figure>
<table style="width:10%;">
<colgroup>
<col style="width: 9%" />
</colgroup>
<tbody>
<tr class="odd">
<td>## 下载工具</td>
</tr>
<tr class="even">
<td>### aria2 多线程下载,但是bt种子该没速度还是没有 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install aria2</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>### Free Download Manger</td>
</tr>
<tr class="even">
<td><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install freedownloadmanger</span><br></pre></td></tr></table></figure></td>
</tr>
</tbody>
</table>
<h2 id="密码管理工具">密码管理工具</h2>
<h3 id="bitwarden"><a href="https://bitwarden.com/">bitwarden</a></h3>
<p>体验最好的开源密码管理器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install bitwarden</span><br></pre></td></tr></table></figure> ------ ## 影音制作</p>
<h3 id="adobe2019全家桶"><a href="https://jiayaoo3o.github.io/2019/03/22/AdobeCC2019%E6%BF%80%E6%B4%BB%E8%A1%A5%E4%B8%81/">Adobe2019全家桶</a></h3>
<h3 id="万兴神剪手"><a href="https://www.shencut.com/">万兴神剪手</a></h3>
<p>适合新手入门的视频剪辑软件 ### <a href="https://arctime.org/">arctime</a></p>
<p>强大的字幕软件 ### 格式工厂</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop insatll format-factory</span><br></pre></td></tr></table></figure>
<h3 id="screentogif">screentogif</h3>
<p>将视频或录屏转换成gif <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop insatll screentogif</span><br></pre></td></tr></table></figure></p>
<h3 id="obs-studio">obs-studio</h3>
<p>体验最好的直播软件与录屏软件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop insatll obs-studio</span><br></pre></td></tr></table></figure> ------ ## 远程控制</p>
<h3 id="微软远程桌面">微软远程桌面</h3>
<p>性能最好的局域网远程桌面软件,外网远程控制需要<a href="https://jiayaoo3o.github.io/2019/03/01/Sakura-Frp-%E5%85%8D%E8%B4%B9%E7%9A%84%E9%AB%98%E9%80%9F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/">内网穿透</a>.</p>
<p>全面屏,刘海屏等非16:9手机请打开手机的自动旋转,等app横屏之后再关闭自动旋转,否则会有显示错位.</p>
<h3 id="teamviewer">teamviewer</h3>
<h2 id="section-4"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install teamviewer</span><br></pre></td></tr></table></figure></h2>
<h2 id="截图工具">截图工具</h2>
<h3 id="snipaste">Snipaste</h3>
<h2 id="section-5"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install snipaste</span><br></pre></td></tr></table></figure></h2>
<h2 id="磁盘管理">磁盘管理</h2>
<h3 id="diskgenius">Diskgenius</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install diskgenius</span><br></pre></td></tr></table></figure>
<h3 id="spacesniffer">SpaceSniffer</h3>
<p>直观的磁盘占用分析软件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop insatll SpaceSniffer</span><br></pre></td></tr></table></figure> ------ ## 游戏管理</p>
<h3 id="steam">steam</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install steam</span><br></pre></td></tr></table></figure>
<h3 id="uplay">uplay</h3>
<p>免费游戏领取器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop insatll uplay</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>个人安利</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>使用mklink命令软连接Onedrive同步任意文件夹</title>
    <url>/2019/12/20/%E4%BD%BF%E7%94%A8mklink%E5%91%BD%E4%BB%A4%E8%BD%AF%E8%BF%9E%E6%8E%A5Onedrive%E5%90%8C%E6%AD%A5%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p>一般来说,想要让Onedrive将某个目录下的文件上传到云,得将对应的文件或者文件夹拷贝到Onedrive目录下,但是有时候却又不方便将文件挪动到Onedrive,例如D盘是仓库盘,存放着大量视频,但是Onedrive却在C盘,这个时候将视频移动到Onedrive会占用大量空间,并且本来D盘作为仓库盘就是用于存放资料的,现在挪动到C盘,影响文件规划.</p>
<p>所以可以使用mklink命令来在存放文件的目录和Onedrive目录中创建一个连接,让Onedrive识别到.</p>
<p>使用管理员权限打开CMD,输入以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mklink /J OneDrive文件夹下的目录绝对路径 需要链接到Onedrive的目录绝对路径</span><br></pre></td></tr></table></figure>
<p>即可.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
        <tag>Onedrive</tag>
      </tags>
  </entry>
  <entry>
    <title>删除Win10右键菜单Radeon设置选项</title>
    <url>/2020/06/15/%E5%88%A0%E9%99%A4win10%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95Radeon%E8%AE%BE%E7%BD%AE%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<ol type="1">
<li><p>打开regedit.</p></li>
<li><p>输入 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算机\HKEY_CLASSES_ROOT\Directory\Background\shellex\ContextMenuHandlers\</span><br></pre></td></tr></table></figure></li>
<li><p>删除ACE文件夹.</p></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>如何下载绝对纯净的Windows10镜像</title>
    <url>/2019/03/11/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E7%BB%9D%E5%AF%B9%E7%BA%AF%E5%87%80%E7%9A%84Windows10%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="在微软官网下载windows10镜像">1. 在微软官网下载Windows10镜像</h1>
<p>很多人要下载一个Windows10镜像时,都会尝试去<a href="https://www.microsoft.com/zh-cn/software-download/Windows10">微软的官网</a>,但是微软的官网是不直接提供下载镜像的途径的,因为当你使用Windows系统下的浏览器去访问微软官网时,微软检测到你正在使用Windows,并不提供下载镜像而是倾向于让你下载一个升级工具,让你用升级工具去升级系统:</p>
<p><img src="https://i.loli.net/2019/03/11/5c867a7439291.png" /></p>
<span id="more"></span>
<p>这个时候只要将浏览器模拟成非Windows系统,就可以直接得到下载地址了:</p>
<ol type="1">
<li><p>chrome键盘按F12,进入开发者模式</p></li>
<li><p>按照如图的步骤,进行操作</p>
<p><img src="https://i.loli.net/2019/03/11/5c867d03951f9.png" /></p></li>
<li><p>刷新网页</p>
<p>此时可以看到,网页已经发生改变,可以选择下载的版本了</p>
<p><img src="https://i.loli.net/2019/03/11/5c867db499a30.png" /></p>
<p>这个方法的优点是,下载的镜像绝对100%是纯净,安全,可靠的,不可能出现任何问题,但是缺点是,下载速度不一定能保证.</p>
<h1 id="在-msdn-i-tell-you-下载">2. 在 MSDN I tell you 下载</h1>
<p><a href="https://msdn.itellyou.cn/">MSDN I tell you</a>是一个广为人知的运营了多年的Windows资源下载网站,该网站致力于提供纯净,安全的镜像给大家免费下载.</p>
<p>进入网站之后,找到自己需要的系统镜像,复制下载链接,打开下载工具即可下载.</p>
<p>这个站唯一的缺点就是只提供ed2k下载链接,必须要使用下载工具而没法直接用浏览器下载.</p>
<p><img src="https://i.loli.net/2019/03/11/5c867f4e237f2.png" /></p>
<h1 id="使用techbench-下载">3. 使用Techbench 下载</h1>
<p><a href="https://tb.rg-adguard.net/public.php?lang=zh-CN">Techbench</a>不仅能提供纯净的Windows镜像,还能顺便下载Office和其他微软家的工具,</p>
<p>进入网站,选择想要下载的系统镜像参数,即可下载纯净的系统镜像.</p>
<p><img src="https://i.loli.net/2019/03/11/5c8680b4b72b4.png" /></p></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>小米手机刷机教程</title>
    <url>/2019/03/19/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>小米作为为数不多的还愿意开放bootloader锁的厂家,刷机其实是比较简单的,总的来说可以归纳为以下4步:</p>
<ol type="1">
<li>为自己的小米账号申请解锁权限.</li>
<li>用该账号解锁自己的手机</li>
<li>刷机(可选卡刷或者线刷).</li>
<li>(可选)刷magisk获得root权限.</li>
</ol>
<p>第一次刷机需要准备的东西比较多,但是只要第一次成功了,以后刷机只需要更换一个刷机包就行了,其他都是现成不变的,而且失败了也没关系,手机没这么容易坏,还是能救回来的,哪怕真的刷坏了也没关系,小米依然保修的.</p>
<p>接下来详细讲解各个步骤.</p>
<span id="more"></span>
<h2 id="申请解锁权限">申请解锁权限</h2>
<p>进入miui网站的<a href="http://www.miui.com/unlock/index.html">申请解锁页面</a>,用自己的账号登录来申请解锁权限,注意:</p>
<ol type="1">
<li>此时有可能需要0到360个小时的审核时间,有的账号申请马上可以过,有的账号要等15天,这个是小米决定的.</li>
<li>不要借别人的账号给自己的手机解锁,因为现在解锁要求手机和电脑同时登录同一个账号,而让自己的手机登录别人的账号是十分不安全的.</li>
<li>单个账号,一个月内只能解锁同一台设备,即你的A手机一个月内可以反复解锁,但是要等一个月后才能解锁你的B手机.</li>
<li>解锁权限获得之后一直有效,不需要再次申请.</li>
</ol>
<h2 id="解锁你的手机">解锁你的手机</h2>
<p>(警告,<strong>解锁</strong>会<strong>删除你的手机内的所有数据,格式化整个手机</strong>,请做好备份)</p>
<p>申请成功之后,<a href="http://miuirom.xiaomi.com/rom/u1106245679/3.3.1212.33/miflash_unlock-3.3.1212.33.zip">下载解锁工具</a>,开始解锁你的手机,步骤如下:</p>
<ol type="1">
<li><p>手机登录该账号.</p></li>
<li><p>手机关机,按住<strong>音量下键+开机键</strong>,会进入fastboot界面,如果失败请反复尝试.</p>
<p><img src="http://www.miui.com/unlock/images/bl_apply_2.png" /></p></li>
<li><p>电脑端启动解锁工具,用同一个账号登录,开始解锁.<img src="https://i.loli.net/2019/03/19/5c9106a03faff.png" /></p></li>
<li><p>解锁完成后,手机会重启,<strong>恢复出厂设置</strong>. (再次警告,解锁会<strong>删除你的手机内的所有数据,格式化整个手机</strong>,请做好备份)</p></li>
</ol>
<h2 id="开始刷机">开始刷机</h2>
<p>刷机分为两种模式,一种叫<strong>线刷</strong>,即手机用数据线连接到电脑,用电脑刷机;另一种叫<strong>卡刷</strong>,即把刷机包放在手机里,用手机刷机(当年是用内存卡的,所以叫卡刷).</p>
<p>接下来分别介绍.</p>
<h3 id="线刷刷机">1.线刷刷机</h3>
<ol type="1">
<li><p>在<a href="http://www.miui.com/shuaji-393.html">线刷包下载页面</a>下载属于你手机的系统刷机包,注意线刷包都带有<strong>fastboot</strong>字眼的.</p>
<p>小米的系统分为开发板和稳定版,开发板基本每周更新,稳定版大约一个月更新一次.</p>
<p>下载完成之后,解压该刷机包.</p></li>
<li><p>手机关机,按住<strong>音量下键+开机键</strong>,进入fastboot界面,手机连接电脑.</p></li>
<li><p>下载<a href="http://bigota.d.miui.com/tools/MiFlash2018-5-28-0.zip">小米线刷刷机工具MiFlash</a>,解压,打开该软件.</p>
<p><img src="https://i.loli.net/2019/03/20/5c911352c2331.png" /></p>
<p>点击蓝色框的<strong>加载设备</strong>,会加载已经连接的手机设备.</p>
<p>点击红色框的<strong>选择</strong>,选择刚刚解压的线刷包.</p>
<p>点击黄色框的三个选项中的一个,其中:</p>
<ul>
<li><strong>全部删除</strong>会删除手机的所有数据,不会有任何残留,不需要再次解锁.</li>
<li><strong>全部删除并且lock</strong>在删除的基础上,会锁定你的手机,即下次刷机还得用账号解锁一次.</li>
<li><strong>保留用户数据</strong>会保留用户的文件和所安装的app,不需要再次解锁.</li>
</ul>
<p>建议选择全部删除.</p></li>
<li><p>确定无误之后,点击绿色框的<strong>刷机</strong>,即可开始刷机,刷机过程只要进度条没有红色警告就是正常现象,刷机完成后手机会自动重启.</p></li>
</ol>
<p>注意,线刷是一个非常底层的操作,所以只要手机能进入fastboot界面,都能通过线刷救回来,线刷也是最彻底,最干净的一种刷机方式,<strong>但是一定要注意备份资料</strong>.</p>
<hr />
<h3 id="卡刷刷机">2.卡刷刷机</h3>
<p>卡刷相对于线刷会更快,也更灵活,步骤如下:</p>
<ol type="1">
<li><p>在小米<a href="http://www.miui.com/download.html">miui官网</a>下载你手机的卡刷包(文件名中没有fastboot字眼,以.zip结尾).</p></li>
<li><p>在<a href="https://twrp.me/Devices/Xiaomi/">TWRP官网</a>或者小米论坛,下载你手机的第三方recovery(也叫第三方re)镜像(文件后缀名是.img).</p>
<p>这里要解释一下什么是第三方recovery.</p>
<p>recovery的作用是给手机恢复出厂设置,更新系统,备份系统的,但是由于官方recovery功能太少,限制太多,所以我们要刷入第三方的recovery,而<a href="https://zh.wikipedia.org/wiki/TWRP">twrp</a>就是一个开源的,成熟的第三方re.</p>
<p>注意:如果你是在小米论坛下载的第三方re,那他们一般会顺便提供一个叫"<strong>电脑端一键刷入recovery.bat</strong>"的文件,此时你只要手机进入fastboot界面,连接电脑,双击该文件,然后按照指示下一步就行了,不需要下面345步.</p></li>
<li><p>点击下载<a href="https://dl.google.com/android/repository/platform-tools-latest-Windows.zip">fastboot工具</a>,解压到某个文件夹中,将刚刚下载的img文件也放到该文件夹.</p></li>
<li><p>电脑按住shift键,鼠标在该文件夹右键,打开powershell.</p></li>
<li><p>输入以下命令:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\fastboot.exe flash recovery twrp<span class="literal">-3</span>.<span class="number">2.3</span><span class="literal">-0</span><span class="literal">-gemini</span>.img (最后一个文件填你刚刚下载的文件的名称)</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\fastboot.exe boot twrp<span class="literal">-3</span>.<span class="number">2.3</span><span class="literal">-0</span><span class="literal">-gemini</span>.img (最后一个文件填你刚刚下载的文件的名称)</span><br></pre></td></tr></table></figure>
<p>手机就已经成功刷入第三方re,并且会重新启动进入第三方re界面.</p>
<p>刷入了第三方re之后,关机状态下按住<strong>音量上键+电源键</strong>即可再次进入,以后卡刷就都在第三方re里面刷了,不需要电脑.</p></li>
<li><p>这时你的手机进入了第三方re界面,应该是长这样的:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/TWRP_2.7.0.0.png/360px-TWRP_2.7.0.0.png" /></p>
<p>点击Settings进入设置,点击最右边的一项设置语言,找到中文(Chinese),点击设置,即可设置成中文.</p></li>
<li><p>再返回到主页,点击<strong>清除</strong>,滑动按钮恢复出厂设置</p>
<p>注意,这里的恢复出厂设置,和在fastboot里线刷删除所有数据不一样,<strong>这里的恢复出厂设置,不会删除你手机上存储文件</strong>.</p></li>
<li><p>再返回到主页,将手机连接到电脑,将刚刚下载的刷机包复制到手机上(如果你是用手机下载的刷机包,那就不需要复制了).</p>
<p>点击<strong>安装</strong>,选择刚刚的刷机包,开始刷机.</p>
<p>刷机完成之后点击重启,即可刷机成功.</p>
<hr />
<h2 id="可选刷入magisk获得root权限">(可选)刷入magisk获得root权限</h2>
<p>经过刚刚的步骤,刷机就已经完成了,如果想要进一步体验强大的<a href="https://sspai.com/post/53043">magisk</a>,可以继续以下步骤,非常简单.</p>
<ol type="1">
<li><p>进入<a href="https://github.com/topjohnwu/Magisk/releases">magisk下载页面</a>,分别下载下载最新的magisk和magisk manager.</p>
<p>这里要解释一下,magisk分成两部分,一部分是magisk本身,另一部分是magisk manager这个管理magisk的app,刷入了magisk之后,手机再安装这个app就可以正常安装模块了.</p></li>
<li><p>关机状态下,音量上键+开机键,进入第三方re,不需要清除数据,<strong>直接点击安装</strong>,选择刚刚下载的magisk文件.</p></li>
<li><p>重启之后,安装magisk manager这个app,就可以正常使用,并且手机现在已经有了root权限了.<img src="https://i.loli.net/2019/03/20/5c91e7e69e316.png" /></p>
<hr />
<h2 id="总结">总结</h2>
<p>以上就是刷机的全部步骤了,总的来说,只要按照步骤来基本都不会失败,而且哪怕是失败了,手机也不会轻易坏掉的,只要能进入fastboot界面,总是能救回来的,但是要注意,<strong>一定一定要记得备份自己的资料,资料没了就真的没了</strong>.<img src="https://i.loli.net/2019/03/21/5c93791231408.jpg" /></p></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>备忘</tag>
        <tag>刷机</tag>
        <tag>小米</tag>
      </tags>
  </entry>
  <entry>
    <title>广东海洋大学三种路由器上网方式</title>
    <url>/2019/01/29/%E5%B9%BF%E4%B8%9C%E6%B5%B7%E6%B4%8B%E5%A4%A7%E5%AD%A6%E4%B8%89%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>2019.12.25摸鱼更新:</p>
<p>据闻时间从9小时变得更短了, 但是老子毕业了嘿嘿嘿 , 再见了辣鸡电信.</p>
<p>不知道现在网费一年多少钱 , 如果wifi热点更便宜 , 还是开热点吧.</p>
<p>5g信号覆盖日 , Email无忘告师兄.</p>
</blockquote>
<blockquote>
<p>2019.2.30更新:</p>
<p>从2019年学期开始,电信在服务端进行了调整,每次登录的存活期只有9个小时,也就是说,不管你用任何方法上网,9个小时之后都必须打开天翼app重新登录一次,以前的方法是登录一次用一天,现在是登录一次用9个小时,其他不变.</p>
</blockquote>
<hr />
<h2 id="海大电信限制学生使用路由器的原因">海大电信限制学生使用路由器的原因</h2>
<p>为了赚钱,其他任何理由都是扯淡. 所以电信选择限制学生使用路由器,每个账号只能登录一台手机和一台电脑,迫使大家每个人都开通一个账号.</p>
<h2 id="海大电信限制学生使用路由器的原理">海大电信限制学生使用路由器的原理</h2>
<p>海大电信是通过验证学生登录设备的ip地址来确保单账号单设备登录的,一台手机或电脑在海大想要上网,会经过以下几个步骤:</p>
<span id="more"></span>
<ol type="1">
<li>手机或电脑连接到已经<strong>关闭了DHCP</strong>的路由器</li>
<li>这台手机根据自己的<strong>mac地址</strong>,获得从海大电信分配的以<strong>10.8开头的ip地址</strong></li>
<li>手机打开天翼校园app,准备登录账号</li>
<li>天翼校园app<strong>检查手机的ip地址是否是以10.8开头</strong>的<strong>经由海大电信分配的合法ip地址</strong></li>
<li>点击登录,登录成功</li>
<li>手机可以持续上网,期间电信的服务器会持续检测该设备是否有数据传输,如果长时间没有数据传输,则判断为设备掉线,需要重新登录.</li>
</ol>
<p>可以看到,电信想要获取学生设备的ip地址分配权,第一步就是<strong>要求学生将自己的路由器关闭DHCP</strong>,只有关闭了路由器的DHCP,电信才能从上一级直接分配ip给每一台学生设备.</p>
<hr />
<h2 id="方法1电信官方允许的使用路由器上网方式">方法1:电信官方允许的使用路由器上网方式</h2>
<h3 id="优点">优点</h3>
<ol type="1">
<li>基本不需要任何额外的操作,按照官方的指导,只需要一台路由器即可</li>
</ol>
<h3 id="缺点">缺点</h3>
<ol type="1">
<li>只能进行<strong>单账号单客户</strong>端登录,<strong>即一个账号只能允许登录一台手机,一台电脑</strong>,所以基本全宿舍每人都需要一个账号</li>
<li>电脑需要安装<strong>极其恶心</strong>的天翼校园软件,并且要让该软件一直运行</li>
<li>如果掉线了需要再次重复登录</li>
<li>电脑客户端毛病极多,经常随机抽风</li>
</ol>
<h3 id="步骤">步骤</h3>
<ol type="1">
<li>手机或电脑连接已经通电的路由器,输入路由器管理界面的地址进入路由器管理界面(一般是192.168.1.1,不同的路由器一般地址不一样,可以查看路由器底部,一般会有)</li>
<li>关闭路由器的DHCP功能</li>
<li>将外网线(即学校提供的,连接到外部上网的网线)插入路由器的<a href="https://www.192ly.com/qiu-zhu/wan-lan-qb.html">LAN口</a></li>
<li>手机连上该路由器,打开天翼校园app,即可登录上网</li>
</ol>
<table style="width:15%;">
<colgroup>
<col style="width: 15%" />
</colgroup>
<tbody>
<tr class="odd">
<td>## 方法2:单路由器的mac克隆上网方式 ### 优点</td>
</tr>
<tr class="even">
<td>1. 只需要一台路由器即可 2. 每天只需一次登录(因为海大每晚断网),即可全天<strong>单账号,多设备</strong>登录,意味着全宿舍公用一个账号成为可能 3. 因为路由器自身总是会有极小量数据与服务器传输,所以可以做到全天不掉线 4. 该方法由于只需要手机登录账号,所以电脑并不需要安装天翼校园软件</td>
</tr>
<tr class="odd">
<td>### 缺点</td>
</tr>
<tr class="even">
<td>1. 由于只有一个路由器,所以操作步骤略微繁琐,需要一定动手能力</td>
</tr>
<tr class="odd">
<td>### 原理</td>
</tr>
<tr class="even">
<td>该方法是通过将路由器的mac地址克隆成登录手机的mac地址,从而欺骗电信服务器,让服务器将路由器误以为是手机设备,所以可以上网</td>
</tr>
<tr class="odd">
<td>### 步骤</td>
</tr>
<tr class="even">
<td>1. 手机打开wifi高级设置,找到手机的<strong>mac地址</strong> 2. 电脑连接路由器,进入路由器管理界面,找到<strong>mac地址克隆设置</strong>,输入刚刚手机的mac地址,保存 2. 关闭路由器的DHCP(此时请务必不要刷新网页,保持页面不要动,因为关闭了DHCP之后,电脑没有了ip地址,是无法直接连接到路由器管理界面的,但是没有关闭的旧路由器管理界面仍能进行操作,所以不能刷新页面,刷新了直接就进不去了) 2. 外网线接入LAN口 3. 手机连接路由器,打开天翼校园app进行登录 4. 登录成功之后,电脑在网页端打开DHCP 5. 将外网线从LAN口拔出,插入WAN口(此时已经登陆成功,并且由于手机和路由器mac地址相同,所以服务器会误以为路由器是手机) 6. <strong>手机清除天翼校园app后台</strong>,关闭手机wifi再重新打开WiFi</td>
</tr>
<tr class="odd">
<td>此时整个过程都已经完成,路由器已经能够正常上网了</td>
</tr>
<tr class="even">
<td>### 注意</td>
</tr>
<tr class="odd">
<td>可以看到,以上的步骤,除了输入mac地址那一步,<strong>其他的每一天都要操作一次</strong>,过程要用到电脑,还要拔网线,所以说稍微有点繁琐,并且如果你使用的是<a href="http://www.mercurycom.com.cn/">水星mercury路由器</a>,步骤会更加麻烦,因为水星的辣鸡低端路由器自身固件原因,关闭了DHCP再打开之后,是不能够自动获取IP地址的,所以步骤会变成 1. 关闭路由器DHCP 2. 外网线接入LAN口 3. 手机连接路由器,打开天翼校园app进行登录 4. 登录成功之后,电脑在网页端打开DHCP 5. 查看手机的WiFi高级设置,看看手机现在的<strong>ip地址,子网掩码,网关(路由器)</strong>是什么 6. 在路由器管理界面选择<strong>手动输入ip地址</strong>(有的路由器也叫静态ip),填入上方的三个数据 7. 将外网线从LAN口拔出,插入WAN口 8. 手机清除天翼校园app后台,关闭手机wifi再重新打开WiFi</td>
</tr>
<tr class="even">
<td>可以看到,使用水星路由器会使得整个过程变得更加繁琐,所以建议不要使用水星路由器</td>
</tr>
</tbody>
</table>
<h2 id="方法3双路由器的mac克隆上网方式">方法3:双路由器的mac克隆上网方式</h2>
<h3 id="优点-1">优点</h3>
<ol type="1">
<li>操作步骤大大减少,简单快捷</li>
<li>参考单路由器方法</li>
</ol>
<h3 id="缺点-1">缺点</h3>
<ol type="1">
<li>需要两个路由器,这是最大的缺点了,如果你没有两个路由器,可能需要额外购买一个</li>
</ol>
<h3 id="原理">原理</h3>
<p>双路由器的本质原理和单路由器是一样的,但是单路由器上网方法之所以会繁琐,是因为在这些步骤中,有"关闭DHCP,打开DHCP"这一个操作,而只要使用两个路由器,就可以让一个路由器打开DHCP,另一个路由器DHCP关闭,这样就能减少很多个步骤了.</p>
<h3 id="步骤-1">步骤</h3>
<p>我们将两个路由器分别叫做<strong>1号路由器,2号路由器</strong></p>
<ol type="1">
<li><strong>1号路由器</strong>关闭DHCP</li>
<li><strong>2号路由器</strong>找到mac克隆选项,输入手机的mac地址,保存</li>
<li>将外网线插入<strong>1号路由器</strong>的LAN口</li>
<li>找来一根短短的网线,将<strong>1号路由器的LAN口</strong>和<strong>2号路由器的WAN口</strong>连接,此时的路由器接线应该是下面那样的 <img src="https://i.loli.net/2019/01/29/5c500a6ab700a.png" alt="路由器接线方式" /></li>
<li>手机连上<strong>1号路由器</strong>的WiFi,登录天翼校园app</li>
<li>手机清除天翼校园app后台,并且连上<strong>2号路由器</strong>,此时<strong>2号路由器</strong>已经能够正常上网了.</li>
</ol>
<h3 id="注意">注意</h3>
<p>上面的步骤只是第一次设置的时候需要做的,以后每天上网只需要3步</p>
<ol type="1">
<li>手机连接1号路由器</li>
<li>登录app</li>
<li>清除app后台,连接2号路由器正常上网</li>
</ol>
<p>上面的操作对路由器的品牌没有限制,<strong>但是水星路由器由于无法自动获取ip地址,所以不建议水星路由器充当2号路由器</strong>,而且如果两个路由器中一个性能很强,一个很垃圾,建议用垃圾路由器充当1号路由器,用性能强的作为2号路由器.</p>
<h2 id="mac克隆能成功的原理">mac克隆能成功的原理</h2>
<p>可以观看下方的视频解释为什么可以用mac克隆方法对电信服务器进行欺骗 <iframe src="//player.bilibili.com/player.html?aid=21369496&cid=35146763&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="480"> </iframe></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>路由器上网</tag>
        <tag>mac欺骗</tag>
        <tag>广东海洋大学</tag>
      </tags>
  </entry>
  <entry>
    <title>开启Windows的远程桌面功能</title>
    <url>/2019/04/09/%E5%BC%80%E5%90%AFwindows%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>微软的远程桌面功能从xp时代就已经有了,但是却很多人不知道要如何开启,下面就来介绍一下如何开启远程桌面功能</p>
<span id="more"></span>
<h2 id="确定windows版本">确定Windows版本</h2>
<p>这是一切的开始,微软的<strong>Windows家庭版</strong>,<strong>教育版</strong>默认情况下:</p>
<ul>
<li>可以远程连接别的电脑</li>
<li>但是不能够被远程连接</li>
</ul>
<p>这是因为<strong>被远程连接</strong>这是一个高级功能,起码要专业版以上(专业版,企业版,服务器版)才行.教育版,家庭版虽然可以强行通过某些软件开启,但是并不是今天的主题,所以如果你的系统如果是家庭版,可以选择重装系统,或者强行升级成专业版,又或者去找别的教程看家庭版如何使用远程桌面.</p>
<h2 id="设置账号和密码">设置账号和密码</h2>
<p>第一步,你的电脑必须要设置有密码,没有密码的话,远程桌面会连接失败</p>
<h2 id="开启远程桌面">开启远程桌面</h2>
<ol type="1">
<li>右键"我的电脑",点击属性</li>
<li>点击左边的"远程设置"</li>
</ol>
<p><img src="https://i.loli.net/2019/04/09/5cabfc686b60a.png" /></p>
<ol start="3" type="1">
<li>选择"允许远程连接到此电脑"</li>
</ol>
<p><img src="https://i.loli.net/2019/04/09/5cabfcfa741dc.png" /></p>
<ol start="4" type="1">
<li>点击蓝色箭头的"选择用户",这个时候你会看到你的账户已经可以进行远程连接了.</li>
</ol>
<p><img src="https://i.loli.net/2019/04/09/5cac0bb7bd5f1.png" /></p>
<h2 id="进行远程连接局域网">进行远程连接(局域网)</h2>
<h3 id="电脑连接电脑">电脑连接电脑</h3>
<p>此时,只要是和你的电脑在<strong>同一个局域网</strong>(也可以说同一个路由器下)的设备,都可以使用"微软远程桌面"来远程连接到你的电脑</p>
<ul>
<li>winxp或者win7:可以直接在开始菜单-附件里面找到"远程桌面连接"</li>
<li>Win10: 可以直接在搜索框搜索"远程桌面",就可以打开远程桌面的设置界面了.(我这里只是设置了系统语言是英文,但是你打开的时候会是中文的)</li>
</ul>
<p><img src="https://i.loli.net/2019/04/09/5cac0cc664270.png" /></p>
<p>要设置的其实只有两个地方,一个是上面图片的<strong>电脑</strong>和<strong>用户名</strong>,电脑是指被连接的电脑的ip地址,现在是你的电脑要被连接,所以就写上你自己电脑的局域网ip地址.用户名就是你的账号名称.</p>
<p><img src="https://i.loli.net/2019/04/09/5cac0e911bbf0.png" /></p>
<p>另外一个可以设置的是红色箭头的体验选项,这里是你要告诉远程卓面这个软件,你的网络怎么样,如果网络好,就可以给你多一点动画效果,如果网络不好,那就少一点动画效果,这里建议取消勾选桌面背景和菜单动画,剩下的可以勾上.</p>
<p>点击连接,<strong>输入账号的密码</strong>,就可以在局域网下远程连接到电脑上了.</p>
<p><img src="https://i.loli.net/2019/04/09/5cac0fa8238e0.png" /></p>
<h3 id="手机连接电脑">手机连接电脑</h3>
<p>手机连接电脑和电脑连接电脑的步骤基本一样,只是电脑上都内置了"远程桌面连接"这个软件,而手机上要使用的话,要去下载一个"微软远程桌面"(也叫"RD Client"),这个软件默认是英文版的,但是单词都比较简单,或者评论区一般也会有发出汉化版地址的.</p>
<p>确保手机和电脑在同一个局域网下(同一个路由器),然后打开软件.</p>
<p><img src="https://i.loli.net/2019/04/09/5cac1128c4b31.jpg" /></p>
<p>点击右上角的加号,添加一个远程电脑 <img src="https://i.loli.net/2019/04/09/5cac1127e4b05.jpg" /> 点击ADD MANUAlLY</p>
<p><img src="https://i.loli.net/2019/04/09/5cac1128bf48c.jpg" /></p>
<p>PC name输入电脑的ip地址</p>
<p>User name 点击 添加一个账户,输入电脑的用户名和密码,就可以了</p>
<p><img src="https://i.loli.net/2019/04/09/5cac1127e849a.png" /></p>
<p><strong>在手机设置上取消"方向锁定"</strong>,有的手机叫"自动方向",或者"自动旋转",一定要让手机<strong>可以自动旋转</strong>,也就是指手机横屏时,软件也会横过来这个状态.取消方向锁定是因为这个app到现在对全面屏(刘海屏,水滴屏)的适配还没有到位,直接设置它的横屏模式会导致鼠标位置偏移等问题.</p>
<p><img src="https://i.loli.net/2019/04/09/5cac13959f4a3.jpg" /></p>
<p>关闭了方向锁定之后,进入软件,点击连接,手机就可以连接到电脑上了.</p>
<p><img src="https://i.loli.net/2019/04/09/5cac1395849d7.jpg" /></p>
<p>注意,现在这台被连接的电脑,同一时间内只能被一个账号连接,而一个账号只能在一台设备上连接,也就是说,你的A账号用手机连接电脑的时候,电脑会被踢下线,而电脑登录A账号的时候,手机就被踢下线,并且如果你的电脑有B账号,手机用B账号连接电脑,A账号也会被踢下线.</p>
<p>解决方法,请看这篇文章:</p>
<p><a href="https://jiayaoo3o.github.io/2019/04/09/%E8%A7%A3%E9%99%A4Windows10%E5%A4%9A%E8%B4%A6%E6%88%B7%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E9%99%90%E5%88%B6/">解除Windows10多账户远程桌面连接限制</a></p>
<h2 id="进行远程连接内网穿透">进行远程连接(内网穿透)</h2>
<p>虽然现在可以使用远程连接,但是得让两个设备都在同一个路由器下面,功能上有局限性,而想要外网也能够远程连接,我们需要内网穿透,具体操作请看这篇文章:</p>
<p><a href="https://jiayaoo3o.github.io/2019/03/01/Sakura-Frp-%E5%85%8D%E8%B4%B9%E7%9A%84%E9%AB%98%E9%80%9F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/">Sakura frp--免费的高速内网穿透工具</a></p>
<p>进行了内网穿透之后,就可以按照这篇教程的操作继续连接了.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
        <tag>远程桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>数学笔记-第一章-极限</title>
    <url>/2019/12/25/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%81%E9%99%90/</url>
    <content><![CDATA[<p>极限是学习高等数学的第一个知识点 , 这一章学习极限 , 主要就是学习计算极限.而计算极限最重要的一步 , 也是第一步 , 就是<strong>判断极限的型</strong>.</p>
<h2 id="极限的型">极限的型</h2>
<p>极限的型可以粗略地分为4种 , 分别为 : <span class="math display">\[
\frac cc=C , \frac 0c=0 , \frac c0=\infty , \frac 00=未定型
\]</span> 所谓的未定型 , 就是结果是未知的 , 不可预料的 , 而前面三种的答案都是唯一固定的 , 所以考试只会考未定型.</p>
<h2 id="计算极限的方法">计算极限的方法</h2>
<p>这里的方法细分可以分为9种 , 有一些方法在以后学了更高级的方法后就没用了 , 但也是用来打基础的.</p>
<span id="more"></span>
<h3 id="利用连续求极限">1.利用连续求极限</h3>
<blockquote>
<p>用于<span class="math inline">\(x\)</span>在<span class="math inline">\(f\left(x\right)\)</span>内有意义的<span class="math inline">\(\frac cc\)</span>题型</p>
</blockquote>
<p>简单来说 , 就是直接将x代入题目.</p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow2}\frac1{x-1}=1
\]</span> 因为<span class="math inline">\(x=2\)</span>在<span class="math inline">\(f\left(x\right)\)</span>上有意义 , 直接代入就可以了.</p>
<h3 id="利用无穷小与无穷大的关系求极限">2.利用无穷小与无穷大的关系求极限</h3>
<blockquote>
<p>解决<span class="math inline">\(\frac\infty\infty\)</span>型有理函数的题型</p>
</blockquote>
<p>无穷小于无穷大的关系 : <span class="math display">\[
\frac 10=\infty  , \frac 1\infty=0
\]</span> 由于无穷大<span class="math inline">\(\infty\)</span>是不允许参与极限的四则运算的 , 因此一个题目如果出现了无穷大必须变成无穷小才可以运算.</p>
<p>要把<span class="math inline">\(\infty\)</span>转变为0 , 方法是把无穷<span class="math inline">\(\infty\)</span>放到分母 , <strong>也就是分子分母同时除以<span class="math inline">\(x\)</span>的最高次幂</strong>.</p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow\infty}\frac{3x+2}x
\]</span> 由于<span class="math inline">\(x\)</span>的最高次幂是1次就让分子分母同时除以<span class="math inline">\(x\)</span> , 变成 : <span class="math display">\[
\frac{3x+2}x=3+\frac2x
\]</span> <span class="math display">\[
\because\frac 2\infty=0
\]</span> <span class="math display">\[
\therefore\lim_{x\rightarrow\infty}\frac{3x+2}x=3
\]</span> 这个方法 , 是解决这类型题目的通用方法 , 但是我们还有一些小技巧 , 去快速得到结果的那就是 :</p>
<blockquote>
<p>当遇到<span class="math inline">\(\frac\infty\infty\)</span>型有理函数时 - 当分子最高次幂与分母最高次幂相同时 , 极限值是各个最高次幂的系数和之商 - 当分子最高次幂小于分母时 , 极限为0 - 当分子最高次幂大于分母时 , 极限为<span class="math inline">\(\infty\)</span> - 口诀 : 上大无穷下大零</p>
</blockquote>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow\infty}\frac{3x+2}x
\]</span> <span class="math inline">\(x\)</span>最高次幂1次 , 结果是<span class="math inline">\(x\)</span>的<strong>系数和的商</strong> , 就是<span class="math inline">\(\frac31=3\)</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow\infty}\frac{\left(2x-1\right)^{30}\left(3x-2\right)^{20}}{\left(2x+1\right)^{50}}
\]</span> 分子的最高次幂是<span class="math inline">\(x^{30}\cdot x^{20}=x^{50}\)</span> , 分母最高也是50次幂 , 不用算 , 答案就是系数和商 : <span class="math display">\[
=\frac{2^{30}\cdot3^{20}}{2^{50}}=\left(\frac32\right)^{20}
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow\infty}\frac{x^2+x}{x^4-3x^3+1}
\]</span> 最高次幂是4次 , 分母比分子大 , 答案就是0.</p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{n\rightarrow\infty}\frac{\left(n+2\right)^3+\left(2n+3\right)^3}{\left(n-1\right)\left(2n-1\right)\left(3n-3\right)}
\]</span> 分子最高3次 , 分母各个<span class="math inline">\(n\)</span>乘了之后也是3次 , 看系数 , 分子第一个<span class="math inline">\(n\)</span>的系数是1 , 第二个<span class="math inline">\(n\)</span>的系数是<span class="math inline">\(2^3=8\)</span> , 相加是9;分母系数为6 , 所以答案就是<span class="math inline">\(\frac96=\frac32\)</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{n\rightarrow\infty}\frac{\left(n+1\right)\left(n+2\right)\left(n+3\right)}{5n^3}
\]</span> 答案就是<span class="math inline">\(\frac15\)</span></p>
<p>这个方法非常好用 , 但是要注意的是 , 首先要判断题目是不是<span class="math inline">\(\frac\infty\infty\)</span>型有理函数 , 否则不能直接这样使用 , 而且虽然通过奇技淫巧一眼看出答案 , 但是考试时<strong>除以<span class="math inline">\(x\)</span>的最高次幂</strong>这个过程还是要写的.</p>
<h3 id="题外话-如何将变形体转化为四大类型">题外话 : 如何将变形体转化为四大类型</h3>
<blockquote>
<p>考试的时候很多情况下不会直接考四大型的原型 , 而是考它们的变形体 , 因此我们最终目的都是<strong>要把这些变形体改变成四大类型</strong>.</p>
</blockquote>
<p>而其中最常见的变形体有两种 : <span class="math display">\[
\infty-\infty型 , 即一个无穷减去一个无穷的形式
\]</span></p>
<p><span class="math display">\[
0\times\infty型 , 即一个0与一个无穷相乘的形式
\]</span></p>
<p>遇到<span class="math inline">\(\infty-\infty型\)</span>这种情况 , 通常会有两种形式 , 对应两种解法 :</p>
<ul>
<li>有根号 , 要有理化</li>
<li>无根号 , 要通分</li>
</ul>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow+\infty}(\sqrt{x^2+x+1}-\sqrt{x^2-x+1})
\]</span> 这道题就是 , 一个无穷减去另一个无穷的题型 , 也就是<span class="math inline">\(\infty-\infty型\)</span> , 并且有根号 , 所以按照解法 , 就是有理化 , 通过平方差公式将<span class="math inline">\(\infty-\infty\)</span>转变成<span class="math inline">\(\frac\infty\infty\)</span> : <span class="math display">\[
=\lim_{x\rightarrow+\infty}\frac{2x}{\sqrt{x^2+x+1}+\sqrt{x^2-x+1}}
\]</span> 这个时候就变成了上面说的<span class="math inline">\(\frac\infty\infty\)</span>型有理函数了 , 直接用奇技淫巧 , 看<span class="math inline">\(x\)</span>最高次幂 , 分子和分母都是1次 ,</p>
<blockquote>
<p>注意分母的根号 , 这里<span class="math inline">\(x\)</span>开了根号后是1次 , 不是2次</p>
</blockquote>
<p>当分子最高次幂与分母最高次幂相同时 , 极限值是各个最高次幂的系数之商 : <span class="math display">\[
=\frac2{1+1}=1
\]</span> <strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow 1}\left(\frac1{1-x}-\frac3{1-x^3}\right)
\]</span> 对于没有根号的<span class="math inline">\(\infty-\infty型\)</span> , 就需要进行通分 : <span class="math display">\[
=\lim_{x\rightarrow 1}\frac{1+x+x^2-3}{1-x^3}
\]</span> 这个时候代入<span class="math inline">\(x=1\)</span>就变成了<span class="math inline">\(\frac 00=未定型\)</span> , 还得继续进行约分.如果因为<span class="math inline">\(x\rightarrow 1\)</span>而导致一个极限是<span class="math inline">\(\frac 00\)</span> , 说明<span class="math inline">\(\left(x-1\right)\)</span>一定是这个方程的一个根 , 也就是说 , 分子和分母一定可以同时消去一个<span class="math inline">\(\left(x-1\right)\)</span> , 这可以为约分提供一个切入的思路. <span class="math display">\[
=\lim_{x\rightarrow 1}\frac{\left(x-1\right)\left(x+2\right)}{\left(1-x\right)\left(1+x+x^2\right)}
\]</span></p>
<p><span class="math display">\[
=-\lim_{x\rightarrow 1}\frac{x+2}{1+x+x^2}=-1
\]</span></p>
<p>这时候就直接变成<span class="math inline">\(\frac cc\)</span> , 代入<span class="math inline">\(x\rightarrow 1\)</span> , 结果就出来了 , 等于<span class="math inline">\(-1\)</span></p>
<p>遇到<span class="math inline">\(0\times\infty型\)</span>这种情况 , 就更简单了 , 因为无穷大和无穷小之间可以相互转化 : <span class="math display">\[
0\times\infty=\frac1\infty\times\infty=\frac\infty\infty
\]</span></p>
<p><span class="math display">\[
0\times\infty=\frac10\times0=\frac00
\]</span></p>
<p>所以我们遇到<span class="math inline">\(0\times\infty型\)</span>时只要通过转换 , 把任意一个变成分母 , 就可以变成标准型了.</p>
<h3 id="利用极限存在的充要条件求极限">3.利用极限存在的充要条件求极限</h3>
<blockquote>
<p>解决分段函数的分段点的极限问题</p>
</blockquote>
<p>极限存在的充要条件求极限 : &gt; 如果函数在该点的极限存在 , 则该点的<strong>左右极限存在并且相等</strong> &gt; 这句话说明 , 通过充要条件 , 满足下面三点 , 即极限存在 : &gt; &gt; - 左极限存在 &gt; - 右极限存在 &gt; - 两者相等</p>
<p><strong>例如 :</strong> <span class="math display">\[
设f\left(x\right)=\left\{\begin{array}{l}3x+2 , x\leq0\\x^2+1 , 0&lt;x\leq1\\\frac2x , 0&lt;x\end{array}\right.
\]</span></p>
<p><span class="math inline">\(分别讨论x\rightarrow 0以及x\rightarrow 1时f(x)的极限是否存在\)</span></p>
<p>使用极限存在的充要条件 : <span class="math display">\[
当x\rightarrow 0时
\]</span></p>
<p><span class="math display">\[
左极限 :\lim_{x\rightarrow0^-}f\left(x\right)=\lim_{x\rightarrow0^-}\left(3x+2\right)=2
\]</span></p>
<p><span class="math display">\[
右极限 :\lim_{x\rightarrow0^+}f\left(x\right)=\lim_{x\rightarrow0^+}\left(x^2+1\right)=1
\]</span></p>
<p><span class="math display">\[
\because\lim_{x\rightarrow0^-}f\left(x\right)\neq\lim_{x\rightarrow0^+}f\left(x\right)
\]</span></p>
<p><span class="math display">\[
\therefore\lim_{x\rightarrow0}f\left(x\right)不存在
\]</span></p>
<p><span class="math display">\[
当x\rightarrow 1时
\]</span></p>
<p><span class="math display">\[
左极限 :\lim_{x\rightarrow1^-}f\left(x\right)=\lim_{x\rightarrow1^-}\left(x^2+1\right)=2
\]</span></p>
<p><span class="math display">\[
右极限 :\lim_{x\rightarrow1^+}f\left(x\right)=\lim_{x\rightarrow1^+}\left(\frac2x\right)=2
\]</span></p>
<p><span class="math display">\[
\because\lim_{x\rightarrow1^-}f\left(x\right)\neq\lim_{x\rightarrow1^+}f\left(x\right)
\]</span></p>
<p><span class="math display">\[
\therefore\lim_{x\rightarrow1}f\left(x\right)存在
\]</span></p>
<blockquote>
<p>注意 : 分段函数分为显分段和隐分段 , 显分段是直接可以看出来的 , 就像上面那题 , 一眼看出是分段函数 , 但是隐分段函数可能不能一下子被想起来 , 例如下面两种形式 , 要意识到是分段函数 : - 绝对值函数 - <span class="math inline">\(a^\infty\)</span>对于<span class="math inline">\(+\infty\)</span>和<span class="math inline">\(-\infty\)</span>有区别 , 例如<span class="math inline">\(\left(\frac12\right)^\infty\)</span> , 当是<span class="math inline">\(+\infty\)</span>时 , 极限是0 ; 当是<span class="math inline">\(-\infty\)</span>时 , 极限是无穷大.</p>
</blockquote>
<h3 id="利用夹逼准则求极限冷门">4.利用夹逼准则求极限(冷门)</h3>
<blockquote>
<p>解决<strong>数列和</strong>与<strong>含有n次方阶乘</strong>的极限问题</p>
</blockquote>
<p>数列和的极限问题有4种 : &gt; - 等差数列求极限 &gt; - 等比数列求极限 &gt; - 可以裂项数列求极限 &gt; - 夹逼准则求极限</p>
<p>一个题目只有当前面三种数列形式都不符合时 , 才使用最后一个夹逼准则求极限.</p>
<p><strong>例如 :</strong></p>
<p>等差数列 : <span class="math display">\[
\lim_{n\rightarrow\infty}\frac{1+2+3+\dots+\left(n-1\right)}{n^2}
\]</span> 有通项公式 : <span class="math display">\[
=\lim_{n\rightarrow\infty}\frac{\frac{\left(n-1\right)\left(n-1+1\right)}2}{n^2}=\frac 12
\]</span> <strong>例如 :</strong></p>
<p>等比数列 : <span class="math display">\[
\lim_{n\rightarrow\infty}\left(1+\frac12+\frac1{2^2}+\dots+\frac1{2^n}\right)
\]</span> 有通项公式 : <span class="math display">\[
=\lim_{n\rightarrow\infty}\frac{1-\frac1{2^{n+1}}}{1-\frac12}=2
\]</span> 上面两种题型 , 就是等差与等比数列 , 有直接的解法 , 并不需要使用夹逼准则.</p>
<blockquote>
<p><strong>夹逼准则 :</strong> 如果数列<span class="math inline">\(x_n\)</span> , <span class="math inline">\(y_n\)</span> , <span class="math inline">\(z_n\)</span>满足下列条件 :</p>
<ul>
<li><span class="math inline">\(y_n\leq x_n\leq z_n\)</span> <span class="math inline">\((n=1 , 2 , 3 , \dots)\)</span></li>
<li><span class="math inline">\(\lim_{n\rightarrow\infty}y_n=\lim_{n\rightarrow\infty}z_n=a\)</span></li>
</ul>
<p>那么数列<span class="math inline">\(x_n\)</span>的极限存在 , 且<span class="math inline">\(\lim_{n\rightarrow\infty}x_n=a\)</span></p>
</blockquote>
<p>夹逼准则的使用方法是 :</p>
<p><strong>左边数列<span class="math inline">\(y_n\)</span>要取所有的最小项 , 右边数列<span class="math inline">\(z_n\)</span>取所有的最大项</strong>.</p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{n\rightarrow\infty}n\left(\frac1{n^2+\pi}+\frac1{n^2+2\pi}+\dots+\frac1{n^2+n\pi}\right)
\]</span> 按照上面说的夹逼准则的使用方法 , 左边选择这个数列的最小项 , 右边选择这个数列的最大项 <span class="math display">\[
当x\rightarrow \infty , 最小项为y_n=\frac1{n^2+n\pi} , 最大项为z_n=\frac1{n^2+\pi}
\]</span></p>
<p><span class="math display">\[
\therefore n\cdot\frac1{n^2+n\pi}\leq n\left(\frac1{n^2+\pi}+\frac1{n^2+2\pi}\right)\leq n\cdot\frac1{n^2+\pi}
\]</span></p>
<p><span class="math display">\[
\lim_{n\rightarrow\infty}y_n=\lim_{n\rightarrow\infty}\left(n\cdot\frac n{n^2+n\pi}\right)=\lim_{n\rightarrow\infty}\frac1{1+\frac\pi n}=1
\]</span></p>
<p><span class="math display">\[
\lim_{n\rightarrow\infty}z_n=\lim_{n\rightarrow\infty}\left(n\cdot\frac n{n^2+\pi}\right)=\lim_{n\rightarrow\infty}\frac1{1+\frac\pi {n^2}}=1
\]</span></p>
<p><span class="math display">\[
\because\lim_{n\rightarrow\infty}y_n=\lim_{n\rightarrow\infty}z_n=1
\]</span></p>
<p><span class="math display">\[
\therefore\lim_{n\rightarrow\infty}n\left(\frac1{n^2+\pi}+\frac1{n^2+2\pi}+\dots+\frac1{n^2+n\pi}\right)=1
\]</span></p>
<blockquote>
<p>注意 : 夹逼准则只用来解决数列问题 , 函数问题会有比夹逼准则更好的方法 , 所以函数问题不要用夹逼准则.</p>
</blockquote>
<h3 id="利用重要极限一求极限">5.利用重要极限一求极限</h3>
<blockquote>
<p>解决<span class="math inline">\(\frac\infty\infty型\)</span>三角函数极限问题</p>
</blockquote>
<p>重要极限一公式 : <span class="math display">\[
\lim_{x\rightarrow0}\left(\frac{\sin X}X\right)=1
\]</span></p>
<p><span class="math display">\[
\lim_{x\rightarrow0}\left(\frac{\tan X}X\right)=1
\]</span></p>
<p><span class="math display">\[
\lim_{x\rightarrow0}\left(\frac X{\sin X}\right)=1
\]</span></p>
<p>这里的<span class="math inline">\(X\)</span>可以指一个<span class="math inline">\(f(x)\)</span>整体 , 例如分子假如是<span class="math inline">\(\sin 3x\)</span> , 那么如果分母也一样是<span class="math inline">\(3x\)</span> , 那结论一样正确.</p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow0}\frac{x-\sin2x}{x+\sin2x}
\]</span></p>
<p><span class="math display">\[
=\lim_{x\rightarrow0}\frac{1-\frac{\sin2x}x}{1+\frac{\sin2x}x}
\]</span></p>
<p>这里<span class="math inline">\(\sin\)</span>后面是<span class="math inline">\(2x\)</span> , 但是分母只有一个<span class="math inline">\(x\)</span> , 所以得让分子和分母变为相同 : <span class="math display">\[
=\lim_{x\rightarrow0}\frac{1-2\frac{\sin2x}{2x}}{1+2\frac{\sin2x}{2x}}
\]</span> 此时使用重要极限一 : <span class="math display">\[
=\frac {1-2}{1+2}
\]</span></p>
<h3 id="利用重要极限二求极限重要">6.利用重要极限二求极限(重要)</h3>
<blockquote>
<p>主要解决<strong>幂指函数</strong>的极限问题</p>
</blockquote>
<blockquote>
<p>幂指函数 : 指底数是变量 , 指数也是变量的函数 , 例如 :</p>
<ul>
<li><span class="math inline">\(x^x\)</span></li>
<li><span class="math inline">\(xln\left(x\right)\)</span></li>
<li><span class="math inline">\(\sqrt[x]x\)</span></li>
</ul>
<p>都是幂指函数的常见形态</p>
</blockquote>
<p>重要极限二公式 : <span class="math display">\[
\lim_{X\rightarrow\infty}\left(1+\frac1X\right)^X=e
\]</span></p>
<p><span class="math display">\[
\lim_{X\rightarrow0}\left(1+X\right)^\frac1X=e
\]</span></p>
<p>一个求极限题目 , 必须是<strong>1加无穷小的无穷大次方型</strong> , 才能使用上述的重要极限二公式.</p>
<p>这种题型的解法比较单一 , 就是要<strong>配出1+</strong> , 然后按照上面两个公式去凑就行了.</p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{n\rightarrow\infty}\left(1+\frac1n\right)^{n+3}
\]</span> 首先判断当<span class="math inline">\(x\rightarrow \infty\)</span>时 , 是不是<strong>1加无穷小的无穷大次方</strong> , 发现是 , 所以用重要极限二公式来解决.</p>
<p>由题目可知 , 重要极限二公式中的<span class="math inline">\(X\)</span>是<span class="math inline">\(n\)</span> , 但是指数部分是<span class="math inline">\(n+3\)</span> , 所以要变成<span class="math inline">\(n\)</span> : <span class="math display">\[
=\lim_{n\rightarrow\infty}\left(1+\frac1n\right)^{n\times\frac1n\times(n+3)}
\]</span></p>
<p><span class="math display">\[
=\lim_{n\rightarrow\infty}e^{\frac1n\left(n+3\right)}
\]</span></p>
<p><span class="math display">\[
=e^1
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow0}\left(1-2x\right)^\frac1x
\]</span> 也是要配出一个<strong>1加无穷小的无穷大次方</strong> : <span class="math display">\[
=\lim_{x\rightarrow0}\left(1+\left(-2x\right)\right)^{\frac1{-2x}(-2x){(\frac 1x})}
\]</span> 这时候使用重要极限二 : <span class="math display">\[
=\lim_{x\rightarrow0}e^{\frac1x\left(-2x\right)}=e^{-2}
\]</span> <strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow\infty}\left(1+\frac kx\right)^x
\]</span> 也要配出<strong>1加无穷小的无穷大次方</strong> : <span class="math display">\[
=\lim_{x\rightarrow\infty}\left[\left(1+\frac kx\right)^\frac xk\right]^k
\]</span> 这时候使用重要极限二 : <span class="math display">\[
=e^k
\]</span> <strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow\infty}\left(\frac{x^2}{x^2-1}\right)^x
\]</span> 配出<strong>1加无穷小的无穷大次方</strong> : <span class="math display">\[
=\lim_{x\rightarrow\infty}\left(1+\frac1{x^2-1}\right)^x
\]</span> 此时指数和分母仍然不一致 , 继续变 : <span class="math display">\[
=\lim_{x\rightarrow\infty}\left[\left(1+\frac1{x^2-1}\right)^{x^2-1}\right]^\frac x{x^2-1}
\]</span></p>
<p><span class="math display">\[
=e^0=1
\]</span></p>
<h3 id="下落不明">7.下落不明</h3>
<h3 id="利用有界函数与无穷小相乘仍为无穷小求极限">8.利用有界函数与无穷小相乘仍为无穷小求极限</h3>
<blockquote>
<p>主要解决下面4种有界函数的极限 : - <span class="math inline">\(sin\infty\)</span> - <span class="math inline">\(cos \infty\)</span> - <span class="math inline">\(arctan\infty\)</span> - <span class="math inline">\(arccot \infty\)</span></p>
</blockquote>
<p>上述四种函数都是有界函数 , 它们与0相乘 , 结果就是0</p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow\infty}\frac{\sin x}x
\]</span></p>
<p><span class="math display">\[
\because当x\rightarrow\infty时 , \frac 1x是无穷小量 , \sin x是有界量
\]</span></p>
<p><span class="math display">\[
\therefore\lim_{x\rightarrow\infty}\frac{\sin x}x=0
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow\infty}\frac{\arctan x}x
\]</span></p>
<p><span class="math display">\[
\because当x\rightarrow\infty时 , \frac 1x是无穷小量 , \arctan x是有界量 , \left|\arctan\;x\right|&lt;\frac\pi2
\]</span></p>
<p><span class="math display">\[
\therefore\lim_{x\rightarrow\infty}\frac{\arctan x}x=0
\]</span></p>
<h3 id="利用等价求极限">9.利用等价求极限</h3>
<blockquote>
<p>只适用于无穷小的题型</p>
</blockquote>
<blockquote>
<p>等价无穷小 : 默认<span class="math inline">\(A\)</span> , <span class="math inline">\(B\)</span>是无穷小函数 , 即为0 , 则当<span class="math inline">\(\lim\left(\frac AB\right)=1\)</span>时称做<span class="math inline">\(A\)</span> , <span class="math inline">\(B\)</span>等价无穷小. 在此前提下当<span class="math inline">\(x\rightarrow 0\)</span> , 有以下等价关系 : - <span class="math inline">\(\sin x\rightleftharpoons x\)</span> - <span class="math inline">\(\tan x\rightleftharpoons x\)</span> - <span class="math inline">\(\arcsin x\rightleftharpoons x\)</span> - <span class="math inline">\(\arctan x\rightleftharpoons x\)</span> - <span class="math inline">\(1-\cos x\rightleftharpoons\frac12x^2\)</span> - <span class="math inline">\(\ln\left(1+x\right)\rightleftharpoons x\)</span> - <span class="math inline">\(\left(1+x\right)^2-1\rightleftharpoons ax , 其中a \neq 0且为常数\)</span> - <span class="math inline">\(e^x-1\rightleftharpoons x\)</span> - <span class="math inline">\(a^x-1\rightleftharpoons x\ln a , 其中a&gt;0\)</span></p>
<p>这里的<span class="math inline">\(x\)</span>不单单指<span class="math inline">\(x\)</span> , 也可以指一个<span class="math inline">\(f(x)\)</span>整体 , 即<span class="math inline">\(\sin f(x)\rightleftharpoons f(x)\)</span></p>
</blockquote>
<p>学习了等价变换之后 , 很多题目就变得简单起来了.</p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow0}\frac{\arctan 3x}{5x}
\]</span> <span class="math display">\[
\because \arctan 3x\rightleftharpoons 3x
\]</span> <span class="math display">\[
\therefore=\lim_{x\rightarrow0}\frac{3x}{5x}=\frac 35
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow0}\frac{\left(\sin x^3\right)\tan x}{1-\cos x^2}
\]</span></p>
<p><span class="math display">\[
\because \tan x\rightleftharpoons x , \sin x^3\rightleftharpoons x^3 , 1-\cos {(x^2)}\rightleftharpoons\frac12{(x^2)}^2
\]</span></p>
<p><span class="math display">\[
\therefore=\lim_{x\rightarrow0}\frac{x^3\times x}{\frac12\left(x^2\right)^2}=2
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow0}\frac{\ln\left(1+3x\sin x\right)}{\tan x^2}
\]</span></p>
<p><span class="math display">\[
=\lim_{x\rightarrow0}\frac{3x\sin x}{x^2}
\]</span></p>
<p><span class="math display">\[
=\lim_{x\rightarrow 0}\frac{3x^2}{x^2}=3
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow0}\frac{e^{5x}-1}x
\]</span></p>
<p><span class="math display">\[
=\lim_{x\rightarrow0}\frac{5x}x=5
\]</span></p>
<blockquote>
<p>等价求极限是一个非常强大的方法 , 但是在用的时候必须注意的两个点 : - 使用等价之前一定要看清楚是不是无穷小 - 满足上一个条件的情况下 , 等价只能用于乘除 , 不能用于加减 , 遇到加减必须转换成乘除</p>
</blockquote>
<p><strong>例如 :</strong> <span class="math display">\[
\lim_{x\rightarrow0}\frac{\tan x-\sin x}{\sin^32x}
\]</span></p>
<p><span class="math display">\[
当x\rightarrow0时 , \tan x\rightleftharpoons x , \sin x\rightleftharpoons x
\]</span></p>
<p><span class="math display">\[
\therefore原式等价于\lim_{x\rightarrow0}\frac{x-x}{\left(2x\right)^3}=0
\]</span></p>
<p><strong>上述方法是绝对的错误的!!!</strong></p>
<p>这就是上面说的 , 等价求极限 , 只能用于乘除 , 不能用于加减.</p>
<p>正确方法是先得将加减转换成乘除 : <span class="math display">\[
\because\tan x-\sin x=\tan x\left(1-\cos x\right)\rightleftharpoons\frac12x^3 , \sin2x\rightleftharpoons2x
\]</span></p>
<p><span class="math display">\[
\therefore\lim_{x\rightarrow0}\frac{\tan x-\sin x}{\sin^32x}=\lim_{x\rightarrow0}\frac{\frac12 x^3}{\left(2x\right)^3}=\frac 1{16}
\]</span></p>
<h2 id="结束">结束</h2>
<p>高数第一章是比较有意思的一章 , 大一新生高考完还有点学习的劲头 , 赶紧假装努力奋斗一下吧 , 后面的课你就没啥激情了.</p>
]]></content>
      <categories>
        <category>数学笔记</category>
        <category>第一章</category>
      </categories>
      <tags>
        <tag>广东海洋大学</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学笔记-第一章-连续与间断</title>
    <url>/2019/12/26/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BF%9E%E7%BB%AD%E4%B8%8E%E9%97%B4%E6%96%AD/</url>
    <content><![CDATA[<h2 id="连续">连续</h2>
<p>连续就是指 :</p>
<p>函数在该点的<strong>极限值 = 函数值</strong></p>
<p>这是函数连续的<strong>最重要概念</strong>.</p>
<blockquote>
<p>注意 : 函数连续可以推导出函数的极限值存在 , 但是反过来 , 函数的极限值存在 , 却不能说明函数连续.</p>
</blockquote>
<h3 id="连续的充要条件">连续的充要条件</h3>
<blockquote>
<p>解决<strong>分段函数</strong>的<strong>分段点</strong>的连续问题</p>
</blockquote>
<p>充要条件 :</p>
<p>如果函数在<span class="math inline">\(x_0\)</span>处连续 , 则函数在<span class="math inline">\(x_0\)</span>处的左右极限存在并相等 , 并且极限值等于函数值.</p>
<p>这句话说明了4件事情 :</p>
<p>如果一个函数连续 , 则 :</p>
<ul>
<li>左极限存在</li>
<li>右极限存在</li>
<li>左右极限相等</li>
<li>极限值等于函数值</li>
</ul>
<p>上面四点有任意一点不满足 , 则说明函数在该点不连续.</p>
<span id="more"></span>
<p><strong>例如 :</strong> <span class="math display">\[
试证函数f\left(x\right)=\left\{\begin{array}{l}x\sin\frac1x , x\neq0\\0 , x=0\end{array}\right.
\]</span></p>
<p><span class="math display">\[
在x=0处连续
\]</span></p>
<p>证明 : <span class="math display">\[
\because\lim_{x\rightarrow0}x\sin\frac1x=0 , 左极限存在
\]</span></p>
<p><span class="math display">\[
f(0)=0 , 右极限存在
\]</span></p>
<p><span class="math display">\[
且\lim_{x\rightarrow0}x\sin\frac1x=f(0)
\]</span></p>
<p><span class="math display">\[
\therefore f(x)在x=0处连续
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
讨论f\left(x\right)=\left\{\begin{array}{l}x+2 , x&gt;0\\x-2 , x&lt;0\end{array}\right.在x=0处的连续性
\]</span></p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^+}f\left(x\right)=\lim_{x\rightarrow 0^+}\left(x+2\right)=2 , 右极限存在
\]</span></p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^-}f\left(x\right)=\lim_{x\rightarrow 0^-}\left(x-2\right)=-2 , 左极限存在
\]</span></p>
<p><span class="math display">\[
但是\lim_{x\rightarrow 0^+}f\left(x\right)\neq\lim_{x\rightarrow 0^-}f\left(x\right)
\]</span></p>
<p><span class="math display">\[
\therefore f(x)在x=0处不连续
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
a取何值时 , f\left(x\right)=\left\{\begin{array}{l}\cos x , x&lt;0\\a+x , x\geq0\end{array}\right.在x=0处连续
\]</span></p>
<p><span class="math display">\[
\because f(0)=a
\]</span></p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^-}f\left(x\right)=\lim_{x\rightarrow 0^-}\cos x=1
\]</span></p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^+}f\left(x\right)=\lim_{x\rightarrow 0^+}(a+x)=a
\]</span></p>
<p><span class="math display">\[
\therefore a=1
\]</span></p>
<h2 id="间断">间断</h2>
<p>间断和连续的概念是相对的 , <strong>不连续就是间断</strong> , 任何一个点不满足连续的4个条件 , 都是间断点 , 而只要是没有意义的点一定是间断的.例如分母为零.</p>
<h3 id="间断点的种类">间断点的种类</h3>
<h4 id="第一类间断点">第一类间断点</h4>
<p>左右极限存在的间断点.</p>
<p>这句话有2个意思 :</p>
<ol type="1">
<li>这个点有左右极限.</li>
<li>这个点间断.</li>
</ol>
<p>所以第一类间断点有两种 :</p>
<ul>
<li>跳跃间断点 : 左右极限都有 , 但是两者不相等.</li>
<li>可去间断点 : 左右极限都有且相等 , 但是极限值不等于函数值.</li>
</ul>
<h4 id="第二类间断点">第二类间断点</h4>
<p>除了第一类间断点 , 剩下的都是第二类间断点.</p>
<h3 id="间断点的判断">间断点的判断</h3>
<ul>
<li>只要是没有意义的点 , 例如分母为零的点 , 一定是间断点.</li>
<li>当题目问某个点是哪种类型的间断点时 , 可以被消去的是第一类 , 不可被消去的是第二类.</li>
</ul>
<p><strong>例如 :</strong> <span class="math display">\[
讨论f\left(x\right)=\left\{\begin{array}{l}-x , x\leq0\\1+x , x&gt;0\end{array}\right.在x=0处的连续性
\]</span></p>
<p><span class="math display">\[
\lim_{x\rightarrow0^-}f\left(x\right)=0 , 左极限存在
\]</span></p>
<p><span class="math display">\[
\lim_{x\rightarrow0^+}f\left(x\right)=1 , 右极限存在
\]</span></p>
<p><span class="math display">\[
\because \lim_{x\rightarrow0^-}f\left(x\right)\neq\lim_{x\rightarrow0^+}f\left(x\right)
\]</span></p>
<p><span class="math display">\[
\therefore x=0为函数f(x)的跳跃间断点
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
讨论f\left(x\right)=\left\{\begin{array}{l}2\sqrt x , 0\leq x&lt;1\\1 , x=1\\1+x , x&gt;1\end{array}\right.在x=1处的连续性
\]</span></p>
<p><span class="math display">\[
\lim_{x\rightarrow1^-}f\left(x\right)=2
\]</span></p>
<p><span class="math display">\[
\lim_{x\rightarrow1^+}f\left(x\right)=2
\]</span></p>
<p><span class="math display">\[
\because \lim_{x\rightarrow1}f\left(x\right)\neq f(1)=1
\]</span></p>
<p><span class="math display">\[
\therefore x=1为函数f(x)的可去间断点
\]</span></p>
<p>再解释一下什么叫可以消去的叫第一类 , 不可以消去的叫第二类</p>
<p><strong>例如 :</strong></p>
<p>判断下列函数的指定点所属的间断点类型 : <span class="math display">\[
y=\frac{x^2-1}{x^2-3x+2}
\]</span> 上面说过 , 使得函数没有意义的点肯定是间断点 , 也就是说 , 这里要使分母为零 , 即<span class="math inline">\(x_1=1\)</span>和<span class="math inline">\(x_2=2\)</span>这两个点就一定是间断点.</p>
<p>而当<span class="math inline">\(x=1\)</span> , 即<span class="math inline">\(x-1=0\)</span>时 , 分子和分母都能同时约去一个<span class="math inline">\(x-1\)</span> , 所以我们知道这个点就是第一类间断点.</p>
<p>又因为此点左右极限相等 , 所以<span class="math inline">\(x_1=1\)</span>是第一类的可去间断点.</p>
<p>而当<span class="math inline">\(x=2\)</span> , 即<span class="math inline">\(x-2=0\)</span>时 , 分子和分母不能约分 , 所以是第二类间断点.</p>
<h2 id="结束">结束</h2>
<p>下一篇写连续函数闭区间三大定理 , 溜了.</p>
]]></content>
      <categories>
        <category>数学笔记</category>
        <category>第一章</category>
      </categories>
      <tags>
        <tag>广东海洋大学</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学笔记-第一章-连续函数闭区间三大定理</title>
    <url>/2019/12/27/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%BA%E9%97%B4%E4%B8%89%E5%A4%A7%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="最值定理">最值定理</h2>
<p>若<span class="math inline">\(y=f(x)\)</span>在<span class="math inline">\([a , b]\)</span>上连续 , 则<span class="math inline">\(y\)</span>在<span class="math inline">\([a , b]\)</span>上总有最大值和最小值.</p>
<h2 id="零点定理">零点定理</h2>
<p>若<span class="math inline">\(y=f(x)\)</span>在<span class="math inline">\([a , b]\)</span>连续 , 且<span class="math inline">\(f(a)\)</span>和<span class="math inline">\(f(b)\)</span>异号 , 即<span class="math inline">\(f(a)\cdot f(b)&lt;0\)</span> , 则在<span class="math inline">\([a , b]\)</span>中至少存在一点<span class="math inline">\(x_0\)</span>使得<span class="math inline">\(f(x_0)=0\)</span> , 即图像与<span class="math inline">\(x\)</span>轴至少有一个交点 .</p>
<h3 id="零点定理的作用">零点定理的作用</h3>
<p>三大定理的作用都是用来解决证明题的 , 包括第三章的中值定理 , 和第五章定积分那里 , 整个第一学期能考证明题的只有这三个地方.</p>
<p>零点定理主要是用来解决需要证明一切关于<span class="math inline">\(\xi\)</span>为0的证明题.</p>
<span id="more"></span>
<blockquote>
<p><strong>关于<span class="math inline">\(\xi\)</span></strong> 的意思就是<strong>一切与<span class="math inline">\(\xi\)</span>有关的东西</strong></p>
</blockquote>
<p><strong>例如 :</strong> <span class="math display">\[
证明在(a , +\infty)上至少有一点\xi , 使f(\xi)为0.
\]</span> 这就叫关于<span class="math inline">\(\xi\)</span>为0.</p>
<blockquote>
<p>注意 : 只要是可以移项的<span class="math inline">\(\xi\)</span> , 把<span class="math inline">\(\xi\)</span>移项 , 仍叫关于<span class="math inline">\(\xi\)</span>为零</p>
</blockquote>
<p><strong>例如 :</strong> <span class="math display">\[
证明\exists\xi\in\left(a , b\right) , 使得f(\xi)=\xi
\]</span> 这里的<span class="math inline">\(\xi\)</span>只要被移动到左边 , 变成<span class="math inline">\(f(\xi)-\xi=0\)</span> , 依然是关于<span class="math inline">\(\xi\)</span>为0的题目 , 仍然使用零点定理来证明.</p>
<p>用零点定理解决证明问题 , 要紧紧记住零点定理的内容.根据零点定理的内容 , 证明分为4步 :</p>
<ul>
<li>构造一个<span class="math inline">\(F(x)\)</span>函数</li>
<li>说明这个函数连续</li>
<li>得到两个闭区间端点异号</li>
<li>说明存在<span class="math inline">\(\xi\)</span></li>
</ul>
<p>初等函数(高中函数)在定义域内都连续 , 不需要什么理由 , 直接写就行了.</p>
<p>证明 : <span class="math display">\[
令 F(x)=f(x)-x , 则F(x)在[a , b]上连续
\]</span></p>
<p><span class="math display">\[
而 F(a)=f(a)-a&lt;0
\]</span></p>
<p><span class="math display">\[
F(b)=f(b)-b&gt;0
\]</span></p>
<p><span class="math display">\[
\therefore 由零点定理 , \exists\xi\in\left(a , b\right) , 使得
\]</span></p>
<p><span class="math display">\[
F(\xi)=f(\xi)-\xi=0 , 即f(\xi)=\xi
\]</span></p>
<blockquote>
<p>注意 : 如果等式的右边是常数 , 那么只要将常数移到左边 , 仍是关于<span class="math inline">\(\xi\)</span>为零的题目</p>
</blockquote>
<p><strong>例如 :</strong> <span class="math display">\[
证明\exists\xi\in\left(a , b\right) , 使得f(\xi)=1
\]</span> 这里的1只要被移动到左边 , 变成<span class="math inline">\(f(\xi)-1=0\)</span> , 依然是关于<span class="math inline">\(\xi\)</span>为0的题目 , 仍然使用零点定理来证明.</p>
<p>用零点定理解题的一个比较常用的出题方向是<strong>证明有根问题</strong>.</p>
<p><strong>例如 :</strong> <span class="math display">\[
证明方程x^5-3x=1至少有一个根介于1和2之间
\]</span> 这道题就很明显属于证明有根问题 , 解法还是按照上面说的4步.</p>
<p>证明 : <span class="math display">\[
令F(x)=x^5-3x=1 , 则F(x)在[1 , 2]上连续
\]</span></p>
<p><span class="math display">\[
\because F(1)=-3&lt;0 , F(2)=25&gt;0
\]</span></p>
<p><span class="math display">\[
\therefore 由零点定理可知 , 至少存在一点\xi\in(1 , 2) , 使得F(\xi)=0
\]</span></p>
<p><span class="math display">\[
即方程x^5-3x=1至少有一个根介于1和2之间
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
证明方程x=a\sin x+b , (a&gt;0 , b&gt;0)
\]</span></p>
<p><span class="math display">\[
至少有一个正根 , 且它不超过a+b
\]</span></p>
<p>证明 : <span class="math display">\[
令F(x)=x-a\sin x -b , 则F(x)在[0 , a+b]上连续
\]</span></p>
<p><span class="math display">\[
F(0)=0-a\sin 0-b=-b&lt;0
\]</span></p>
<p><span class="math display">\[
F(a+b)=a+b-a\sin(a+b)-b=a[1-\sin(a+b)]\geqslant0
\]</span></p>
<p><span class="math display">\[
\therefore 如果F(a+b)=0 , 则a+b就是方程不超过a+b的正根
\]</span></p>
<p><span class="math display">\[
如果F(a+b)&gt;0 , 在(0 , a+b)内至少存在一个不超过(a+b)的正根
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
证明y=x^4-3x^2+7x-10在x=1和x=2之间至少与x轴有一个交点
\]</span> 这道题也是很明显需要使用零点定理 , 因为也相当于是证明有根问题.</p>
<p>证明 : <span class="math display">\[
函数y=x^4-3x^2+7x-10在[1 , 2]上连续
\]</span></p>
<p><span class="math display">\[
y(1)=-5&lt;0 , y(2)=8&gt;0
\]</span></p>
<p><span class="math display">\[
由零点定理可知 , 至少存在一点\xi\in(1 , 2)使y(\xi)=0
\]</span></p>
<p><span class="math display">\[
\therefore y=x^4-3x^2+7x-10在x=1和x=2之间至少与x轴有一个交点
\]</span></p>
<p>换另一种问法 , 也得意识到需要用零点定理来解决.</p>
<p><strong>例如 :</strong> <span class="math display">\[
设f(x)=e^x-2 , 求证在区间(0 , 2)内至少有一点x_0
\]</span></p>
<p><span class="math display">\[
使得e^x-2=x_0
\]</span></p>
<p>证明 : <span class="math display">\[
令F(x)=e^x-2-x , 则F(x)在[0 , 2]上连续
\]</span></p>
<p><span class="math display">\[
F(0)=-1&lt;0 , F(2)=e^2-4&gt;0
\]</span></p>
<p><span class="math display">\[
由零点定理可知 , 至少存在一点x_0\in(1 , 2)使F(x_0)=0
\]</span></p>
<p><span class="math display">\[
即e^{x_0}-2=x_0
\]</span></p>
<blockquote>
<p>下面这一段内容 , 到了后面学了罗尔定理才用得上 , 可以先跳过 , 学到了罗尔定理才回来看.</p>
<p>如何分辨证明题要用零点定理还是罗尔定理来证明?</p>
<p>零点定理和后面学到的罗尔定理都是证明<strong>关于<span class="math inline">\(\xi\)</span>为零</strong>的 , 所以尤其困难的一点是如何分辨一道题该用零点定理还是罗尔定理去解决.</p>
<p>判断的方法是 :</p>
<p>看<strong>已知函数</strong>和<strong>结论函数</strong>之间有没有<strong>导数的增加</strong> , 例如 :</p>
<ul>
<li>已知<span class="math inline">\(f(x)\)</span> , 证明<span class="math inline">\(f’(x)\)</span></li>
<li>已知<span class="math inline">\(f&#39;(x)\)</span> , 证明<span class="math inline">\(f&#39;’(x)\)</span></li>
<li>已知<span class="math inline">\(f(x)\)</span> , 证明<span class="math inline">\(f’&#39;(x)\)</span></li>
</ul>
<p>都属于有导数的增加 , 都使用罗尔定理.</p>
<p>而</p>
<ul>
<li>已知<span class="math inline">\(f(x)\)</span> , 证明<span class="math inline">\(f(x)\)</span></li>
<li>已知<span class="math inline">\(f&#39;(x)\)</span> , 证明<span class="math inline">\(f&#39;(x)\)</span></li>
<li>已知<span class="math inline">\(f&#39;&#39;(x)\)</span> , 证明<span class="math inline">\(f&#39;&#39;(x)\)</span></li>
</ul>
<p>都没有导数的增加 , 都使用零点定理.</p>
</blockquote>
<h2 id="介值定理">介值定理</h2>
<p>若<span class="math inline">\(y=f(x)\)</span>在<span class="math inline">\([a , b]\)</span>连续 , 且在区间端点取不同的函数值<span class="math inline">\(f(a)=A , f(b)=B\)</span> , 则对于<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>之间的任意一个数<span class="math inline">\(U\)</span> , 在开区间<span class="math inline">\((a , b)\)</span>内至少有一个点<span class="math inline">\(c\)</span>使得<span class="math inline">\(f(c)=U\)</span>.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e2/Intermediatevaluetheorem.svg/1024px-Intermediatevaluetheorem.svg.png" /></p>
<h3 id="介值定理的作用">介值定理的作用</h3>
<p>介值定理是用来解决证明关于<span class="math inline">\(\xi\)</span>不为零的题目 , 这里的<strong>关于<span class="math inline">\(\xi\)</span>不为零</strong>与零点定理做比较就能理解 , 首先<strong>关于<span class="math inline">\(\xi\)</span></strong>这三个字上面已经解释过了 , 这里的<strong>不为零</strong>的意思是函数的右边是一坨与<span class="math inline">\(\xi\)</span>无关的式子 , 而且无法与<span class="math inline">\(\xi\)</span>融合的东西 , 例如 : <span class="math display">\[
f\left(\xi\right)=\frac{f(x_1)+f(x_2)+\dots+f(x_n)}n
\]</span></p>
<p>这样的函数 , 右边完全没有<span class="math inline">\(\xi\)</span> , 也不是常数 , 也不能移项 , 也不能够与<span class="math inline">\(f(\xi)\)</span>融合 , 与<span class="math inline">\(\xi\)</span>符号毫无关系 , 这样的题目 , 就是用介值定理来解决.</p>
<p>介值定理证明题的解题步骤 , 基本也分为3步 :</p>
<ul>
<li>引入<strong>最值定理</strong> , 说明函数一定存在一个最小值<span class="math inline">\(m\)</span>和最大值<span class="math inline">\(M\)</span></li>
<li>用待证明等式右边的式子(如上述的<span class="math inline">\(\frac{f(x_1)+f(x_2)+\dots+f(x_n)}n\)</span>)构造出一个<span class="math inline">\(m\leq 右边式子\leq M\)</span>的结论</li>
<li>回顾我们的介值定理的内容 , 这时候其实就可以得到证明结果了</li>
</ul>
<p>整个过程看似很简单 , 但是到底是如何得到结论的 , 可以回顾一下介值定理的内容 :</p>
<blockquote>
<p>若<span class="math inline">\(y=f(x)\)</span>在<span class="math inline">\([a , b]\)</span>连续 , 且在区间端点取不同的函数值<span class="math inline">\(f(a)=A , f(b)=B\)</span> , 则对于<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>之间的任意一个数<span class="math inline">\(U\)</span> , 在开区间<span class="math inline">\((a , b)\)</span>内至少有一个点<span class="math inline">\(c\)</span>使得<span class="math inline">\(f(c)=U\)</span>.</p>
</blockquote>
<p>介值定理说 , 在<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>之间的任意一个<span class="math inline">\(U\)</span> , 在开区间<span class="math inline">\((a , b)\)</span>之内都一定会有一个<span class="math inline">\(c\)</span>使得<span class="math inline">\(f(c)=U\)</span>.</p>
<p>因此假设想要使用介值定理 , 就必须构造出介值定理所需要的东西 , 只要这些东西都齐全了 , 就可以使用介值定理了 :</p>
<p><span class="math inline">\(f(a)=A , f(b)=B\)</span> , 对应上面步骤的最小值<span class="math inline">\(m\)</span>和最大值<span class="math inline">\(M\)</span> , 因为由最值定理得知 , 每一个函数在<span class="math inline">\([a , b]\)</span>内必有最大值或者最小值 , 所以我们通过拿一个一定存在的最小值<span class="math inline">\(m\)</span>和最大值<span class="math inline">\(M\)</span> , 代替了<span class="math inline">\(f(a)=A , f(b)=B\)</span>.</p>
<p>第二步 , 只要用待证明的等式右边构造出一个<span class="math inline">\(m\leq 等式右边\leq M\)</span> , 那这个格式刚好就对应介值定理里面 :</p>
<blockquote>
<p>对于<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>之间的任意一个数<span class="math inline">\(U\)</span></p>
</blockquote>
<p>这个格式.</p>
<p>上面两步 , 就满足了构造出介值定理所需要的东西 , 所以就可以得到介值定理的结论 :</p>
<blockquote>
<p>一定存在一个点<span class="math inline">\(\xi\)</span> , 使得<span class="math inline">\(f(\xi)=U\)</span></p>
</blockquote>
<p><strong>例如 :</strong> <span class="math display">\[
证明若f(x)在[a , b]上连续 , a&lt;x_1&lt;x_2&lt;\dots&lt;x_n&lt;b , 
\]</span></p>
<p><span class="math display">\[
则在[x_1 , x_n]上必有\xi , 使得f\left(\xi\right)=\frac{f(x_1)+f(x_2)+\dots+f(x_n)}n
\]</span></p>
<p>证明 :</p>
<p>第一步 , 引入最值定理 , 得到最大值和最小值 : <span class="math display">\[
根据最值定理 , 知f(x)在[x_1 , x_n]上存在最小值m和最大值M
\]</span></p>
<p>第二步 , 尝试构造出待证明的等式右边式子 :</p>
<p><span class="math display">\[
\therefore m\leq f(x_i)\leq M , (i=1 , 2 , 3\dots , n)
\]</span></p>
<p>注意思考这一步怎么构造出右边式子的 :</p>
<p><span class="math display">\[
\therefore m\leq \frac{f(x_1)+f(x_2)+\dots+f(x_n)}n\leq M
\]</span></p>
<p>构造完成后 , 整个格式就已经符合介值定理了 , 直接使用介值定理的结论 : <span class="math display">\[
在[x_1 , x_n]上运用介值定理 , 可知在[x_1 , x_n]上必有\xi
\]</span></p>
<p><span class="math display">\[
使得f\left(\xi\right)=\frac{f(x_1)+f(x_2)+\dots+f(x_n)}n
\]</span></p>
<h2 id="结束">结束</h2>
<p>这些证明题里面 , 最重要的就是<strong>构造出一个符合这些定理格式的构造函数</strong>.</p>
<p>因为定理是一直成立的 , 而我们的题目如果和定理的格式一样 , 说明我们的题目也是被证明为成立的.</p>
<p>为什么使用零点定理前要构造出一个右边为0的式子?因为零点定理结论就是右边式子为0的 ;</p>
<p>为什么使用介值定理前要构造出一个最小值和一个最大值?因为介值定理的格式就是<span class="math inline">\(A\leq U\leq B\)</span></p>
<p>只有这样 , 我们才能够说 , 因为题目符合定理成立的一切条件 , 所以这个题目可以得到定理的结论 , 证明完毕.</p>
]]></content>
      <categories>
        <category>数学笔记</category>
        <category>第一章</category>
      </categories>
      <tags>
        <tag>广东海洋大学</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学笔记-第二章-导数</title>
    <url>/2019/12/31/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%BC%E6%95%B0/</url>
    <content><![CDATA[<h2 id="导数的含义">导数的含义</h2>
<p>导数是<strong>增量比的极限</strong>.</p>
<blockquote>
<p>这句话揭露了导数的本质是极限, 也说明了为什么第一章要学极限, 因为导数就是极限.</p>
</blockquote>
<h2 id="导数要解决的问题">导数要解决的问题</h2>
<ul>
<li>用导数的定义求导</li>
<li>复合函数求导</li>
<li>高阶求导</li>
<li>隐函数求导</li>
<li>参数方程求导</li>
</ul>
<span id="more"></span>
<h2 id="用定义求导">用定义求导</h2>
<p>导数的三大定义形式 : <span class="math display">\[
f&#39;\left(x_0\right)=\lim_{\Delta x\rightarrow0}\frac{\Delta y}{\Delta x}=\lim_{\Delta x\rightarrow0}\frac{f\left(x_0+\Delta x\right)-f\left(x\right)}{\Delta x}
\]</span></p>
<p><span class="math display">\[
f&#39;\left(x_0\right)=\lim_{ h\rightarrow0}\frac{f\left(x_0+h\right)-f\left(x_0\right)}h
\]</span></p>
<p><span class="math display">\[
f&#39;\left(x_0\right)=\lim_{ x\rightarrow x_0}\frac{f\left(x\right)-f\left(x_0\right)}{x-x_0}
\]</span></p>
<p>为什么要用定义求导, 而不是直接用求导公式, 那是因为使用求导公式之前题目必须已知<span class="math inline">\(f(x)\)</span>可导, 可导可以推出连续, 连续可以推出极限, 但是反过来却不成立. <span class="math display">\[
可导\rightarrow连续\rightarrow极限
\]</span></p>
<p><span class="math display">\[
可导\nleftarrow连续\nleftarrow极限
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
设f(x)在x=2处连续, 且\lim_{x\rightarrow2}\frac{f\left(x\right)}{x-2}=2, 求f&#39;(2)
\]</span> 题目只是说了在<span class="math inline">\(x=2\)</span>处连续, 但是连续不一定可导, 所以不能用公式, 也不能用其他方法去解决, 只能用定义.</p>
<p><strong>例如 :</strong> <span class="math display">\[
设\varphi\left(x\right)在x=a处连续, f(x)=(x^2-a^2)\varphi\left(x\right), 求f&#39;(x)
\]</span> 题目只是说了连续, 但是连续不一定可导, 所以只能用定义来算. <span class="math display">\[
f&#39;\left(a\right)=\lim_{x\rightarrow a}\frac{f\left(x\right)-f\left(a\right)}{x-a}
\]</span></p>
<p><span class="math display">\[
=\lim_{x\rightarrow a}\frac{\left(x^2-a^2\right)\varphi\left(x\right)-0}{x-a}
\]</span></p>
<p><span class="math display">\[
=\lim_{x\rightarrow a}\left(x+a\right)\varphi\left(x\right)
\]</span></p>
<p><span class="math display">\[
=2a\varphi\left(a\right)
\]</span></p>
<p>可以看出, 导数与极限的关系, 导数就是极限, 也遵守极限的计算规则.</p>
<h3 id="用定义解决几何问题">用定义解决几何问题</h3>
<p>用定义求导的另一个出题方向是解决几何问题, 主要是解决切线方程和法线方程.</p>
<blockquote>
<p>法线就是与切线垂直的线, 法线斜率与切线斜率相乘为-1</p>
</blockquote>
<p><strong>例如 :</strong> <span class="math display">\[
求曲线y=e^x在点(0, 1)处的切线方程和法线方程
\]</span></p>
<p><span class="math display">\[
\because y&#39;(0)=e^x\vert _{x=0}=e^0=1
\]</span></p>
<p><span class="math display">\[
\therefore 切线方程y-1=1\cdot(x-0)
\]</span></p>
<p><span class="math display">\[
即x-y+1=0
\]</span></p>
<p><span class="math display">\[
法线方程y-1=-\frac 11\cdot (x-0)
\]</span></p>
<p><span class="math display">\[
即x+y-1=0
\]</span></p>
<h3 id="用定义解决分段函数分段点可导问题">用定义解决分段函数分段点可导问题</h3>
<blockquote>
<p>可导的充要条件 :</p>
<p><span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处的左右导数存在且相等.</p>
</blockquote>
<p><span class="math display">\[
左导数:f&#39;_-(x_0)=\lim_{x\rightarrow x_{0^-}}\frac{f\left(x\right)-f\left(x_0\right)}{x-x_0}
\]</span></p>
<p><span class="math display">\[
右导数:f&#39;_+(x_0)=\lim_{x\rightarrow x_{0^+}}\frac{f\left(x\right)-f\left(x_0\right)}{x-x_0}
\]</span></p>
<p>这种题目与当时分段函数分段点求极限的步骤基本一致.</p>
<p><strong>例如 :</strong> <span class="math display">\[
求函数f\left(x\right)=\left\{\begin{array}{l}\sin x, x&lt;0\\x, x\geq0\end{array}\right., 在x=0处的导数.
\]</span></p>
<p><span class="math display">\[
f&#39;_-(0)=\lim_{\Delta x\rightarrow 0^-}\frac{\Delta y}{\Delta x}=\lim_{\Delta x\rightarrow 0^-}\frac{\Delta \sin x}{\Delta x}=1
\]</span></p>
<p><span class="math display">\[
f&#39;_+(0)=\lim_{\Delta x\rightarrow 0^+}\frac{\Delta y}{\Delta x}=\lim_{\Delta x\rightarrow 0^+}\frac{\Delta x}{\Delta x}=1
\]</span></p>
<p><span class="math display">\[
\because f&#39;_-(0)=f&#39;_+(0)=1
\]</span></p>
<p><span class="math display">\[
\therefore f&#39;(0)=1
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
函数f\left(x\right)=\left\{\begin{array}{l}x^2+1, 0\leq x&lt;1\\3x-1, 1\leq x\end{array}\right., 在x=1处是否可导?
\]</span></p>
<p><span class="math display">\[
f&#39;_-(1)=\lim_{x\rightarrow 1^-}\frac{f(x)-f(1)}{x-1}=\lim_{x\rightarrow 1^-}\frac{x^2+1-2}{x-1}=2
\]</span></p>
<p><span class="math display">\[
f&#39;_+(1)=\lim_{x\rightarrow 1^+}\frac{f(x)-f(1)}{x-1}=\lim_{x\rightarrow 1^+}\frac{3x-1-2}{x-1}=3
\]</span></p>
<p><span class="math display">\[
\because f&#39;_-(1)\neq f&#39;_+(1)
\]</span></p>
<p><span class="math display">\[
\therefore f(x)在x=1处不可导
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
求f\left(x\right)=\left\{\begin{array}{l}x, x&lt;0\\\ln \left(1+x\right), x\geq0\end{array}\right., 在x=0处的导数
\]</span></p>
<p><span class="math display">\[
f&#39;_-(0)=\lim_{x\rightarrow 0^-}\frac{f(x)-f(0)}{x-0}=\lim_{x\rightarrow 0^-}\frac{x-0}{x-0}=1
\]</span></p>
<p><span class="math display">\[
f&#39;_+(0)=\lim_{x\rightarrow 0^+}\frac{f(x)-f(0)}{x-0}=\lim_{x\rightarrow 0^+}\frac{\ln (1+x)}{x-0}=1
\]</span></p>
<p><span class="math display">\[
\because f&#39;_-(0)=f&#39;_+(0)=1
\]</span></p>
<p><span class="math display">\[
\therefore f&#39;(0)=1
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
f\left(x\right)=\left\{\begin{array}{l}\sin x, x&lt;0\\x, x\geq 0\end{array}\right., 求f&#39;(x)
\]</span></p>
<p><span class="math display">\[
f&#39;_-(0)=\lim_{x\rightarrow 0^-}\frac{f(x)-f(0)}{x-0}=\lim_{x\rightarrow 0^-}\frac{\sin x}{x}=1
\]</span></p>
<p><span class="math display">\[
f&#39;_+(0)=\lim_{x\rightarrow 0^+}\frac{f(x)-f(0)}{x-0}=\lim_{x\rightarrow 0^-}\frac{x}{x}=1
\]</span></p>
<p><span class="math display">\[
f&#39;_-(0)=f&#39;_+(0)=1
\]</span></p>
<p><span class="math display">\[
\therefore f&#39;\left(x\right)=\left\{\begin{array}{l}\cos x, x&lt;0\\1, x\geq0\end{array}\right.
\]</span></p>
<h2 id="求导法则必须背诵">求导法则(必须背诵)</h2>
<p>基本求导公式 :</p>
<ul>
<li><span class="math inline">\((c)&#39;=0\)</span></li>
<li><span class="math inline">\(\left(x^\mu\right)&#39;=\mu x^{\mu -1}\)</span></li>
<li><span class="math inline">\((\sin x)&#39;=\cos x\)</span></li>
<li><span class="math inline">\((\cos x)&#39;=-\sin x\)</span></li>
<li><span class="math inline">\((\tan x)&#39;=\sec^2x\)</span></li>
<li><span class="math inline">\((\cot x)&#39;=-\csc^2x\)</span></li>
<li><span class="math inline">\((\sec x)&#39;=\sec x\tan x\)</span></li>
<li><span class="math inline">\((\csc x)&#39;=-\csc x \cot x\)</span></li>
<li><span class="math inline">\((a^x)&#39;=a^x\ln a\)</span></li>
<li><span class="math inline">\((e^x)&#39;=e^x\)</span></li>
<li><span class="math inline">\((\log_ax)&#39;=\frac1{x\ln a}\)</span></li>
<li><span class="math inline">\((\ln x)&#39;=\frac 1x\)</span></li>
<li><span class="math inline">\((\arcsin x)&#39;=\frac1{\sqrt{1-x^2}}\)</span></li>
<li><span class="math inline">\((\arccos x)&#39;=-\frac1{\sqrt{1-x^2}}\)</span></li>
<li><span class="math inline">\((\arctan x)&#39;=\frac1{1+x^2}\)</span></li>
<li><span class="math inline">\((arccotx)&#39;=-\frac1{1+x^2}\)</span></li>
</ul>
<p>函数的和, 差, 积, 商的求导法则 :</p>
<p>设<span class="math inline">\(U=u(x)\)</span>, <span class="math inline">\(V=v(x)\)</span>可导, 则 :</p>
<ul>
<li><span class="math inline">\((U\pm V)&#39;=U&#39;\pm V&#39;\)</span></li>
<li><span class="math inline">\((CU)&#39;=C\cdot U&#39;, (C为常数)\)</span></li>
<li><span class="math inline">\((U\cdot V)&#39;=U&#39;\cdot V+U\cdot V&#39;\)</span></li>
<li><span class="math inline">\(\left(\frac UV\right)&#39;=\frac{U&#39;\cdot V-U\cdot V&#39;}{V^2}, (V\neq0)\)</span></li>
</ul>
<h2 id="复合函数求导">复合函数求导</h2>
<p>复合函数求导公式 : <span class="math display">\[
y=f[g(x)]在点x可导, 则其导数为 \frac{dy}{dx} = f&#39;(u)\cdot g&#39;(x)
\]</span> 解题步骤 :</p>
<ol type="1">
<li>满足运算法则的的要优先运算.</li>
<li>数清楚有多少个函数复合, 这是最关键一步, 数错了就全错了.</li>
<li>有多少个函数复合就求多少次导, <strong>由外向内, 从左向右</strong>.</li>
<li>每求一次导, 就扔掉一个函数.</li>
</ol>
<p><strong>例如 :</strong> <span class="math display">\[
求函数y=\left(ln\left(tan\left(\frac x2\right)\right)\right)^3的导数
\]</span> 第一步先数清楚有多少个函数复合, 需要严格按照由<strong>外向内, 从左到右</strong>原则, 可以看到, 从按顺序分别为<span class="math inline">\(3次方\)</span>, <span class="math inline">\(ln\)</span>, <span class="math inline">\(tan\)</span>, <span class="math inline">\(\frac x2\)</span> 四个函数的复合, 所以计算的公式即为 : <span class="math display">\[
y&#39;=3\cdot 3\left(ln\left(tan\left(\frac x2\right)\right)\right)^2\cdot \frac1{\tan\left(\frac x2\right)}\cdot \sec^2\left(\frac x2\right)\cdot\frac 12
\]</span> 有四个函数, 所以要求4次导数, 严格按照<strong>由内向外, 从左到右</strong>的原则.</p>
<p><strong>例如 :</strong> <span class="math display">\[
求函数y=\cos(4-3x)的导数
\]</span> 第一步先数清楚有多少个函数复合, 从左到右, 分别为<span class="math inline">\(\cos\)</span>, <span class="math inline">\(4-3x\)</span> 这两个函数, 所以按照步骤: <span class="math display">\[
y&#39;=-\sin(4-3x)\cdot (4-3x)&#39;
\]</span></p>
<p><span class="math display">\[
=-\sin(4-3x)\cdot (-3)=3\sin(4-3x)
\]</span></p>
<p><strong>例如 :</strong> <span class="math display">\[
求函数y=\tan\left(x^2\right)
\]</span> 从左到右, 分别为<span class="math inline">\(\tan\)</span>, <span class="math inline">\(x^2\)</span> 这两个,然后依次求导 : <span class="math display">\[
y&#39;=\sec^2(x^2)\cdot (2x)=2x\sec^2(x^2)
\]</span></p>
]]></content>
      <categories>
        <category>数学笔记</category>
        <category>第二章</category>
      </categories>
      <tags>
        <tag>广东海洋大学</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学笔记-第零章-一切的开始</title>
    <url>/2019/12/24/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E9%9B%B6%E7%AB%A0-%E4%B8%80%E5%88%87%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h2 id="为什么要写这个数学笔记">为什么要写这个数学笔记</h2>
<p>我上大学遇到的高数老师 , 叫邝雪松 , 他是我认为的 , 我在大学遇到过的最厉害 , 最有激情 , 最会教课的老师 . 他的讲课风格非常厉害而且通俗易懂 , 基本完全放弃PPT . 每节他的课 , 前面几排都是要抢着去的 , 比其他那些只知道念课件的老师不知道强到哪里去了.</p>
<p>我非常钦佩他的上课水平 , 并且当时的我较为详细地将他的讲课内容记录到了笔记本中 , 在16年末到17年初 , 刚好准备过年的时候 , 制作了第一版word文档的数学笔记 :</p>
<p><img src="https://i.loli.net/2019/12/26/UJCGe4xFOVEqjWL.png" /></p>
<span id="more"></span>
<p>那时候的心情是非常开心的 , 但是这些数学笔记 , 基本没有给多少人看过 , 也没放到网上去 , 写完这一版之后 , 就一直放着没动过了.</p>
<p>到了现在19年年末准备过年了 , 我准备毕业了 , 突然想起还有这些东西 , 放在Onedrive上面吃灰 , 所以心血来潮又想要将这些数学笔记重新整理发布到博客上面 , 尽管应该也没啥人看 , 但是起码能让有机会见到的人 , 知道海洋大学还有一个这么好的数学老师.</p>
<p>当时大一用word写的数学笔记 , 很多用公式的地方基本都是直接截图 , 虽然内容没问题 , 但是样式比较丑 :</p>
<p><img src="https://i.loli.net/2019/12/26/1Zragc4NLPztKGq.png" /></p>
<p>现在要用markdown重新写 , 肯定就不能直接截图往上怼了 , 所以我决定所有公式都用LaTex来写 :</p>
<p><img src="https://i.loli.net/2019/12/26/XMGF5qzI4KhZWPa.png" /></p>
<p>算是有始有终 , 虽然内容都是偏考试解题技巧 , 对原理和理论涉及不多 , 希望这些知识能够帮到某个大一新生 , 如果你也是广东海洋大学的大一新生 , 记得去听邝雪松老师的课.</p>
<h2 id="通过什么工具链将这些数学笔记发布到的github的">通过什么工具链将这些数学笔记发布到的Github的</h2>
<ul>
<li>Github Page 存放静态博客</li>
<li>Hexo 生成博客页面</li>
<li>Github Actions 自动生成与部署</li>
<li>VSCode 基本上用来push到Github</li>
<li>Typora 编辑markdown</li>
</ul>
<p>博客本身是用Hexo发布在Github Page上面的 , 写数学笔记难就难在这些公式怎么写出来的 , 因为我完全不会LaTex , 本来是想着放弃的 , 但是居然让我找到了<a href="http://www.wiris.com/editor/demo/zh/developers#toolbars">这个网站</a> , 能够手写公式识别成LaTex :</p>
<p><img src="https://i.loli.net/2019/12/26/owVKLiyRQxYItu7.png" /></p>
<p>最麻烦的一步解决了之后 , 剩下的就是耐性了.</p>
<h2 id="发现文章的错误">发现文章的错误</h2>
<p>可以直接在Github上面提issues或者直接在博客页面发邮件给我 , 基本上都能直接联系到我.</p>
<h2 id="想要转载">想要转载</h2>
<p>完全不用通知我 , 直接复制文章底下那段版权声明 , 然后粘贴到你转载的文章里就可以了.</p>
]]></content>
      <categories>
        <category>数学笔记</category>
        <category>第零章</category>
      </categories>
      <tags>
        <tag>广东海洋大学</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>比frp更好用的内网穿透工具-ZeroTie One</title>
    <url>/2020/06/11/%E6%AF%94frp%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7-ZeroTier%20One/</url>
    <content><![CDATA[<p>曾经我觉得, 最好用的内网穿透工具是frp, 并且写了一篇文章来赞美免费提供8M带宽提供内网穿透的<a href="https://jiayaoo3o.github.io/2019/03/01/Sakura-Frp-%E5%85%8D%E8%B4%B9%E7%9A%84%E9%AB%98%E9%80%9F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/">Sakura Frp</a>, 但后来我发现, 哪怕是Sakura Frp免费提供了公网服务器, 使用起来还是有点繁琐了, 并且速度只有8M, 所以最终我找到了能够代替frp的内网穿透工具 : ZeroTier One.</p>
<h2 id="zerotier-one是什么">ZeroTier One是什么?</h2>
<p>ZeroTier One是一款内网穿透软件, 但是和frp的"内网客户端-远程公网服务器-内网客户端"模式不同的是, ZeroTier One是通过p2p方式在不同的设备之间进行连接的, 只要所有的设备都加入了同一个ZeroTier Network, 互相之间就可以像在局域网中那样访问对方, 并且是直接连接而不是走公网服务器, 速度上限基本取决与设备之间的网速而不是ZeroTier服务器.免费版的ZeroTier能够连接多达100各设备, 足够个人使用了.</p>
<span id="more"></span>
<h2 id="zerotier-one使用步骤">ZeroTier One使用步骤</h2>
<h3 id="下载并且安装zerotier-one客户端">下载并且安装ZeroTier One客户端</h3>
<p>进入ZeroTier的<a href="https://www.zerotier.com/download/">下载页面</a>点击对应系统的下载链接, 即可下载并且安装ZeroTier One客户端.</p>
<p><img src="https://i.loli.net/2020/06/10/S2ZB1lIfvdTMHCL.png" /></p>
<h3 id="注册并且登陆zerotier">注册并且登陆ZeroTier</h3>
<p><a href="https://accounts.zerotier.com/auth/realms/zerotier/protocol/openid-connect/auth?client_id=zt-central&amp;redirect_uri=https%3A%2F%2Fmy.zerotier.com%2Fapi%2F_auth%2Foidc%2Fcallback&amp;response_type=code&amp;scope=all&amp;state=state">点击链接</a>进入注册页面, 进行注册.</p>
<p><img src="https://i.loli.net/2020/06/10/qPHpS3lTxMInJ6R.png" /></p>
<h3 id="创建一个network">创建一个Network</h3>
<p>点击Networks标签, 再点击Create a Network按钮创建一个网络.</p>
<p><img src="https://i.loli.net/2020/06/10/rahZWlA5Ii4bjLu.png" /></p>
<h3 id="配置network基本信息">配置Network基本信息</h3>
<p>点击刚刚创建的网络, 可以进入到network配置页面, 配置的作用如下图.</p>
<figure>
<img src="https://i.loli.net/2020/06/10/9kjqKz6GnuXBwrH.png" alt="基本配置" /><figcaption aria-hidden="true">基本配置</figcaption>
</figure>
<figure>
<img src="https://i.loli.net/2020/06/10/m1gksjfd4JLzTSw.png" alt="网络设置" /><figcaption aria-hidden="true">网络设置</figcaption>
</figure>
<p>右键电脑上运行的ZeroTier One, 点击Join Network, 粘贴上面的Network ID.</p>
<p><img src="https://i.loli.net/2020/06/10/XwoKkQpeIlO7aqx.png" /></p>
<figure>
<img src="https://i.loli.net/2020/06/10/9b5kBj1ihzCRtgX.png" alt="成员管理" /><figcaption aria-hidden="true">成员管理</figcaption>
</figure>
<p>当两台设备都安装ZeroTier One并且加入了同一个网络, 即可互相通信.</p>
<p><img src="https://i.loli.net/2020/06/10/liIhXM6TAgJeyn8.png" /></p>
<p>此时, 已经可以直接使用<a href="https://jiayaoo3o.github.io/2019/04/09/%E5%BC%80%E5%90%AFWindows%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8A%9F%E8%83%BD/">远程桌面功能</a>, 对局域网机器进行访问.</p>
<p><img src="https://i.loli.net/2020/06/10/BSrL5VilUYnQauH.png" /></p>
<h2 id="加速zerotier-one之间的连接可选">加速ZeroTier One之间的连接(可选)</h2>
<p>虽然两个ZeroTier One客户端之间是通过p2p连接的, 但是设备A要首先连接到ZeroTier的行星根服务器(地球 Earth), 去获取到设备B的信息, 才能在两者之间进行通信, 而ZeroTier的全球唯一行星根服务器有可能离我们很遥远, 导致在某些时候"A-根服务器-B"这一过程速度会很慢, 这个时候可以通过在自己的公网服务器中架设根服务器(月球 Moons), 来加快"A-根服务器-B"这一过程.</p>
<ol type="1">
<li><p>执行下面的命令, 在公网服务器中安装ZeroTier</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s https://install.zerotier.com/ | sudo bash</span><br></pre></td></tr></table></figure></li>
<li><p>进入ZeroTier安装目录, 生成配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/lib/zerotier-one</span><br><span class="line">sudo zerotier-idtool initmoon identity.public &gt; moon.json</span><br></pre></td></tr></table></figure></li>
<li><p>修改moon.json配置文件, 找到对应的那一行, 添加你的公网服务器的ip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;stableEndpoints&quot;: [ &quot;123.123.123.123/9993&quot; ]</span><br></pre></td></tr></table></figure></li>
<li><p>生成文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo zerotier-idtool genmoon moon.json</span><br></pre></td></tr></table></figure>
<p>这个时候会在当前目录生成一个名字类似0000009b30156f58.moon的文件.</p></li>
<li><p>创建名为moons.d的文件夹, 并且将上面的moon文件移动进去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv 0000009b30156f58.moon moons.d</span><br></pre></td></tr></table></figure></li>
<li><p>重启服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service zerotier-one restart</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这个时候, 你的公网服务器就已经成为moon服务器了, 客户端想要加入moon, 只需要用管理员powershell执行下面命令, 即可看到设备已经添加了moon节点. 后面那段字符是moon文件生成的文件名去掉开头的6个0.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zerotier-cli orbit 9b30156f58 9b30156f58</span><br><span class="line">zerotier-cli listpeers</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>突破微软远程桌面帧率限制</title>
    <url>/2019/03/19/%E7%AA%81%E7%A0%B4%E5%BE%AE%E8%BD%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%B8%A7%E7%8E%87%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>根据微软的<a href="https://support.microsoft.com/zh-cn/help/2885213/frame-rate-is-limited-to-30-fps-in-Windows-8-and-Windows-server-2012-r">这一篇文章</a>所说,想要更改远程桌面帧率限制,可以采取以下步骤:</p>
<ol type="1">
<li><p>win+R键打开运行窗口,输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regedit</span><br></pre></td></tr></table></figure>
<p>进入注册表编辑器</p>
<span id="more"></span></li>
<li><p>找到并且单击以下的注册表子项:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations</span><br></pre></td></tr></table></figure></li>
<li><p>右键,点击新建,选择<strong>DWORD(32-bit)</strong>,输入文件名:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWMFRAMEINTERVAL</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/03/19/5c90b478429f4.png" /></p></li>
<li><p>右键该文件选择修改,点击<strong>十进制</strong>,在<strong>数值数据</strong>中输入<strong>15</strong>,点击确定<img src="https://i.loli.net/2019/03/19/5c90b5c463d20.png" /></p></li>
<li><p>注意,修改完成后只是理论上能到达60fps,实际上能不能到达该帧率由多方面因素决定,尤其是网络延迟,建议在千兆局域网内进行测试.</p></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>解决docker容器无法输入中文问题</title>
    <url>/2019/06/29/%E8%A7%A3%E5%86%B3docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一般情况下docker镜像产生的容器,都是无法直接在终端中输入中文的,因为docker镜像追求的就是最小化修改,没有必要的部分是不会进行添加与修改的.</p>
<p>虽然Debian和Ubuntu是爹和儿子,但是两者设置的方法略有不同.</p>
<p>总体的步骤就是:</p>
<ol type="1">
<li>修改文件<strong>/etc/locale.gen</strong>,将需要的语言注释取消掉.</li>
<li>运行<strong>locale-gen</strong>命令.</li>
</ol>
<span id="more"></span>
<h2 id="ubuntu">Ubuntu</h2>
<p>Ubuntu与debian不同的是Ubuntu仓库里有一个语言包,只要安装了语言包就会自动配置好<code>zh_CN.UTF-8</code>,所以我们要做的就是直接安装<strong>language-pack-zh-hans</strong></p>
<p>在Dockerfile文件中添加以下命令,所有以RUN开头的命令,既可在原有的RUN指令之后添加,也可另起一行RUN,但必须在<strong>apt-get update</strong>命令之后:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get -y install language-pack-zh-hans</span></span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> LANG=<span class="string">&#x27;zh_CN.utf8&#x27;</span></span><br></pre></td></tr></table></figure>
<p>生成镜像后即可在终端输入中文.</p>
<h2 id="debian">Debian</h2>
<p>由于debian不仅没有语言包,连locales都没有安装,所以要先安装locales,然后通过<strong>sed</strong>将<strong>locale.gen</strong>文件的<strong>zh_CN.UTF-8</strong>前的注释去掉,并且运行locale-gen,安装zh_CN.UTF-8</p>
<p>在Dockerfile文件中添加以下命令,所有以RUN开头的命令,既可在原有的RUN指令之后添加,也可另起一行RUN,但必须在<strong>apt-get update</strong>命令之后:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y locales \</span></span><br><span class="line"><span class="bash">    &amp;&amp; sed -i <span class="string">&#x27;/^#.* zh_CN.UTF-8 /s/^#//&#x27;</span> /etc/locale.gen \</span></span><br><span class="line"><span class="bash">    &amp;&amp; locale-gen </span></span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> LANG=<span class="string">&#x27;zh_CN.utf8&#x27;</span></span><br></pre></td></tr></table></figure>
<p>生成镜像后即可在终端输入中文.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>解除Windows10多账户远程桌面连接限制</title>
    <url>/2019/04/09/%E8%A7%A3%E9%99%A4windows10%E5%A4%9A%E8%B4%A6%E6%88%B7%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>从上一篇文章开启<a href="https://jiayaoo3o.github.io/2019/04/09/%E5%BC%80%E5%90%AFWindows%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8A%9F%E8%83%BD/">Windows的远程桌面功能</a>我们说到,Windows默认情况下只能同时登录一个账号,并且手机连上电脑,电脑就会退出登录,被踢下线,这是因为,能让多个账号远程连接到一个电脑,这个是服务器版才该有的功能,你想想,多个账号连接一台电脑,那这个电脑不应该就是服务器吗?所以想要让Windows10支持多账户远程桌面连接,我们需要一点点设置.</p>
<span id="more"></span>
<h2 id="创建新的账户">创建新的账户</h2>
<p>想要多账户连接到自己的电脑,那首先就得先创建一个新的账户,打开</p>
<blockquote>
<p>系统设置-账户-家庭&amp;其他用户</p>
</blockquote>
<p>点击<strong>添加一个其他用户</strong></p>
<p><img src="https://i.loli.net/2019/04/09/5cac4b60a2df4.png" /></p>
<p>这个时候就可以输入新建用户名和密码,完成账户的添加.</p>
<p>给该用户远程连接权限</p>
<p>现在这个新建的用户只是一个普通账户,并不是管理员账户,所以并没有远程连接的默认权限,我们要去允许该账户进行远程连接</p>
<blockquote>
<p>右键我的电脑-属性-远程设置-选择用户</p>
</blockquote>
<p><img src="https://i.loli.net/2019/04/09/5cac0bb7bd5f1.png" /></p>
<p>点击"添加"按钮,然后在框内输入你刚刚创建的用户名,点击"名字检查",系统就会找到这个用户</p>
<p><img src="https://i.loli.net/2019/04/09/5cac4cfa32e64.png" /></p>
<p>这个时候点击ok,这个用户就有了远程连接的权限了.</p>
<h2 id="配置本地组策略">配置本地组策略</h2>
<p>虽然现在已经有了两个账号,但是在默认情况下,A账号登录B就会被踢下来,B登录A也会被踢下来,所以现在要设置组策略</p>
<p>在左下角搜索框中输入gp,系统就会自动帮你找到<strong>组策略编辑器</strong>,打开后,依次点击:</p>
<blockquote>
<p>管理模板-Windows组件-远程桌面服务-远程桌面会话主机-连接</p>
</blockquote>
<ol type="1">
<li><p>双击右边的<strong>限制连接的数量</strong>,选择<strong>已启用</strong>,然后在下面选择你想开启的最大连接数,一般填个3都够用了.</p></li>
<li><p>双击右边的<strong>将远程桌面服务用户限制到单独的远程桌面服务会话</strong>,<em>这里很多的教程会建议改成<strong>已禁用</strong>,但是我的建议是把这里改成<strong>已启用</strong>!!!</em></p></li>
</ol>
<p>要知道为什么这么改,我们首先要知道这个设置是干嘛的.</p>
<p>将用户限制到单独的远程桌面服务,是指 : 如果我手机连上A账号,电脑就不能连上A账号,电脑连上了,手机就会掉线.</p>
<p>那为什么我们要启用这个功能?因为<strong>这时候手机和电脑使用的是同一个A账号的资源</strong>,举个例子,当你用手机连接电脑的A账号在远程看电影,这时候你的电脑用A账号登录,就会把手机踢下线,但是你会发现,电脑现在的界面就在播放着手机刚刚看的视频,因为这时候他们两个用的是同一个资源,所以会有一种无缝连接的感觉,远程桌面的内容,就是电脑本身的内容.</p>
<p>而你如果<strong>关闭</strong>了<strong>将远程桌面服务用户限制到单独的远程桌面服务会话</strong>这个功能,就会导致一个用户可以开启多个远程桌面服务会话,<strong>手机和电脑使用的是不同的A账号资源</strong>.这又是什么意思?</p>
<p>就是说,如果你电脑现在正在登录A账号,手机选择远程桌面登录A账号,<strong>此时电脑的A账号不会被踢下线,而是两个A账号同时工作</strong>!但是手机的A账户的资源是完全独立于电脑A账户的,电脑A账户打开了浏览器,但是手机A账户看不见,手机A账户远程打开电影,电脑A账户也看不见,两者互相独立的远程会话.</p>
<p>这样的问题在于,<strong>每次退出远程桌面连接都必须手动点击"注销"按钮</strong>,将你的远程A账户的资源清空掉,而不可以直接关闭远程桌面App,如果直接关闭App,这个单独的A账户就会显示"断开连接",然后就一直孤零零的在后台消耗资源,直到你主动连接到这个资源,然后注销.</p>
<p>如果你的手机退出远程桌面连接,然后又重新连接一次,<strong>并不会连上刚刚的断开连接的A账号,而是重新分配一个全新的A账号资源给你</strong>,这样你的电脑就有3个A账号在工作,系统资源就会被严重浪费,直接卡爆.</p>
<p>因此,我建议是把这个功能<strong>启用着</strong>,会更合适一般人.</p>
<h2 id="开启多用户连接功能">开启多用户连接功能</h2>
<p>虽然刚刚设置了最大连用户数,但是我们的系统本质上装的并不是服务器版本,所以到目前为止我们还是不能够多用户同时连接的,要去github上下载<a href="https://github.com/stascorp/rdpwrap/releases/download/v1.6.2/RDPWrap-v1.6.2.zip">RDPWrap</a>这个软件(不要去csdn等地方下载来路不明的文件,直接去github原作者那下载是最好的).</p>
<p>解压之后我们右键选择用管理员依次运行这三个文件</p>
<ul>
<li>install.bat</li>
<li>update.bat</li>
<li>RDPConf.exe</li>
</ul>
<p>如果你的系统版本太新,那你很可能箭头这里依然会显示[not supported]</p>
<p><img src="https://i.loli.net/2019/04/09/5cac551aa9a44.png" /></p>
<p>这时候<a href="https://github.com/stascorp/rdpwrap/files/2949950/rdpwrap.zip">点击下载</a>这个文件,解压后将里面的rdpwrap.ini文件替换到</p>
<blockquote>
<p>C:FilesWrapper</p>
</blockquote>
<p>再重复刚刚的步骤应该就可以看到[fully supported]的字眼了.</p>
<p>如果你的系统比1089还新,或者更换了rdpwrap.ini文件仍然不支持,就需要到这个代码仓库的<a href="https://github.com/stascorp/rdpwrap/issues">issues</a>里面搜索你的系统版本(也就是上面的<strong>10.0.17763.292</strong>字眼),一般来说都会有人贴出新系统的配置信息,你只要把这个配置信息粘贴到刚刚那个rdpurap.ini文件的末尾就行了.例如下图:</p>
<p><img src="https://i.loli.net/2019/04/14/5cb29e742f1c9.png" /></p>
<p>到这里,所有的步骤就都结束了,你的电脑现在可以让两个账户同时连接而不掉线了.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
        <tag>远程桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一个Win10 2004版本使用USB网络共享导致的bug</title>
    <url>/2020/06/19/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAWin10%202004%E7%89%88%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%89%8B%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C%E7%9A%84bug/</url>
    <content><![CDATA[<h2 id="触发状态">触发状态</h2>
<ul>
<li>系统 : Win10 2004</li>
<li>cpu : amd R7-4800U</li>
<li>手机 : 小米10Pro</li>
</ul>
<h2 id="bug症状">bug症状</h2>
<p>使用数据线连接电脑和手机, 手机开启<code>个人热点-USB网络共享功能</code>, 系统会变得卡顿, 点击任务栏反应会变慢, 点击左下角win键甚至要等待数秒到数十秒才会弹出窗口.</p>
<h2 id="解决方案">解决方案</h2>
<p>不使用USB网络共享功能, 用手机开热点算了.</p>
<h2 id="原因猜测">原因猜测</h2>
<ul>
<li>可能是amd的cpu驱动问题.</li>
<li>可能是Win10 2004问题.</li>
<li>可能是手机的USB网络共享功能有问题.</li>
</ul>
<p>由于设备不多, 难以测试, 并且影响不大, 所以就不深究了.</p>
<blockquote>
<p>2020.07.14更新</p>
</blockquote>
<p>我发现我是用红米5A接上microUSB数据线开启同样的USB网络共享功能啥事没有, 也不卡顿, 所以要么是微软偷偷修复了bug(?), 要么是amd的type-c驱动有问题(?) 要么是手机的接口有问题(?) 不好说, 但是现在用红米开热点就完事了.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次WSL2的网络代理配置</title>
    <url>/2020/06/23/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1WSL2%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>目标是在WSL2使用安装在Win10内的V2ray来实现科学上网.</p>
<h2 id="wsl2获取win10ip">WSL2获取Win10ip</h2>
<p>在Win10 -&gt; WSL2这个方向, 是可以直接通过Localhost来访问的, 但是WSL2 -&gt; Win10这个方向就不能直接访问Localhost了, 需要指定Win10的ip, 想要查看WSL2中Win10的ip, 只需要查看<code>resolve.conf</code> :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [network]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> generateResolvConf = <span class="literal">false</span></span></span><br><span class="line">nameserver 172.18.176.1</span><br></pre></td></tr></table></figure>
<p>这个172.18.176.1就是在WSL2中Win10的ip.</p>
<p>想要方便获取这个IP, 可以直接使用下方命令 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/resolv.conf|grep nameserver|awk &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="wsl2设置环境变量">WSL2设置环境变量</h2>
<p>由于上面已经可以获取到Win10的ip, 这个时候就可以很方便的对各种环境变量进行设置, 因为V2ray的默认http端口为10809, socks5端口为10808, 所以可以直接设置环境变量 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export windows_host=`cat /etc/resolv.conf|grep nameserver|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">export ALL_PROXY=socks5://$windows_host:10808</span><br><span class="line">export HTTP_PROXY=$ALL_PROXY</span><br><span class="line">export http_proxy=$ALL_PROXY</span><br><span class="line">export HTTPS_PROXY=$ALL_PROXY</span><br><span class="line">export https_proxy=$ALL_PROXY</span><br></pre></td></tr></table></figure>
<p>git也可以设置为使用代理 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global proxy.https socks5://$windows_host:10808</span><br></pre></td></tr></table></figure>
<p>如果想要这些环境变量和设置每次启动终端都生效, 可以在<code>~/.bashrc</code>文件最下方添加上述内容 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export windows_host=`cat /etc/resolv.conf|grep nameserver|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">export ALL_PROXY=socks5://$windows_host:10808</span><br><span class="line">export HTTP_PROXY=$ALL_PROXY</span><br><span class="line">export http_proxy=$ALL_PROXY</span><br><span class="line">export HTTPS_PROXY=$ALL_PROXY</span><br><span class="line">export https_proxy=$ALL_PROXY</span><br><span class="line"></span><br><span class="line">if [ &quot;`git config --global --get proxy.https`&quot; != &quot;socks5://$windows_host:10808&quot; ]; then</span><br><span class="line">            git config --global proxy.https socks5://$windows_host:10808</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="设置v2ray允许局域网连接">设置V2ray允许局域网连接</h2>
<p><img src="https://i.loli.net/2020/06/23/CynkNFRxavlXQ6E.png" /></p>
<h2 id="设置win10防火墙">设置Win10防火墙</h2>
<p>这一步是最重要的一步, 也是最坑的一步, 需要在Win10防火墙中允许V2ray进行公用和专用网络的访问! 只要设置这个就可以了, 不需要调整过其他设置!</p>
<p><img src="https://i.loli.net/2020/06/23/JY4RLDrScAuh6gE.png" /></p>
<p>找到所有带v2ray字眼的应用的选项, 全勾上就可以了. 在WSL2中输入<code>curl -vv www.google.com</code>验证是否正确访问谷歌.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
        <tag>WSL2</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次退休笔记本安装Ubuntu搭建NAS过程</title>
    <url>/2020/06/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%80%80%E4%BC%91%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85Uubuntu%E6%90%AD%E5%BB%BANAS%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="笔记本配置">笔记本配置</h2>
<ul>
<li>型号 : 坠机堡垒</li>
<li>服役时长 : 5年</li>
<li>cpu : i5-4200h</li>
<li>内存 : 8+4的ddr3内存</li>
<li>硬盘 : 240G用了4年的威刚SATA固态+1T机械硬盘用于存电影</li>
<li>屏幕 : 45%NTSC祖传普通15.6屏幕</li>
</ul>
<p>换了新电脑, 这台老机器就决定用来当NAS用了.</p>
<blockquote>
<p>2020.10.15更新</p>
</blockquote>
<p>刚好三个月过去了, 中间又换了两种方案, 现在终于确定了什么系统做nas适合我.</p>
<p>本来是从win10切过去了freenas, 因为我发现freenas原生就带有OneDrive云同步功能, 并且还有ZFS这种文件格式对数据进行保护, 所以一开始用起来觉得很完美, 但是由于以前没用过FreeBSD, 才发现freenas下的插件生态居然这么贫瘠, 第一次看到官方加上三方的插件一共就这么一点的时候我惊了, 就只有一个qBittorrent是能够开箱即用的, 并且由于我没有公网ip, 连装zerotier-one都失败了, 这就导致了这个freenas只能完全在内网, 没法远程访问.</p>
<p>本来我以为就得这么别扭地用着freenas的时候, 我突然发现freenas公司现在在做一个新的项目 : <a href="https://www.truenas.com/download-truenas-scale/">TrueNAS SCALE</a>, 这个项目是FreeNas公司目前在做的新的一款nas系统, 它让我感到兴奋的原因是这个新的系统<strong>是基于Debian而不是FreeBSD进行开发的!!!</strong>, 这就意味着可以原生使用Docker, 整个Docker镜像生态都可以直接接入到TrueNAS里面, 而不仅仅是以前的几十个插件, 甚至连zerotier都可以直接在DockerHub上面搜到镜像, 所以当我知道了这个系统之后, 马上就切换过去了, 但是由于目前这个系统还在非常早期的阶段, 有问题是很正常的, 各种各样的bug也经常出现, 如果想要稳定现在还是不适合上车. 现在可以说一下这个系统目前有什么坑.</p>
<p>首先第一点是, 尽量不要将这个系统安装在内存卡和U盘上, 经过我多次尝试, 只要是将系统安装到内存卡或U盘上, 就没有启动正常过, 要么是刚启动就完全卡住, 要么就是无法导入boot-pool, 需要手动import, 但是当我用硬盘安装时, 瞬间流畅进入系统.</p>
<p>第二点就是只要更新系统, Docker里面的镜像和容器会被全部清除, 所以启动容器要尽量挂在到本地, 并且保存好docker run命令, 以后更新系统之后方便重新启动容器.</p>
<p>上面这两点是目前比较大的坑, 其余的页面小bug还是能够接受的, 并且新的TrueNAS SCALE可以无缝导入以前freenas的存储池, 所以目前基本完美.</p>
<blockquote>
<p>2020.07.15更新</p>
</blockquote>
<p>还是选择装回去Win10 2004了, Ubuntu下还是没法做到完美的Ondrive方案,我几百个G的视频想要完美同步到Onedrive, 所以选择安装2004版本, 开WSL2使用docker来确保原来的服务都是可用的, 以后通过笔记本远程桌面到这台NAS做主力机算了, 现在的笔记本夏天发热太严重了, 所以选择将服务压力都放到NAS上面, 笔记本直接远程桌面上去当正常电脑用.</p>
<span id="more"></span>
<h2 id="安装ubuntu-20.04桌面版">安装Ubuntu 20.04桌面版</h2>
<p>前往Ubuntu官网下载Ubuntu 20.04桌面版, 因为这次是安装在笔记本电脑上, 有屏幕, 如果直接装服务器版本就有点浪费了, 安装有图形界面的Linux发行版都比较简单, 而且Ubuntu的汉化工作也比较到位, 就不多介绍了.</p>
<h2 id="更换中科大源">更换中科大源</h2>
<p>进入<a href="http://mirrors.ustc.edu.cn/">中科大镜像站官网</a>, 找到Ubuntu选项, 点击右边的help按钮就可以进入Ubuntu换源帮助页面.</p>
<p>首先先执行下方命令, 查看当前的源网址前面有没有country-code</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>如果看到了<code>cn.archive.ubuntu.com</code>则执行下方命令 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sed -i &#x27;s/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>如果只看到了<code>archive.ubuntu.com</code>则执行下方命令(少了一个cn) :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sed -i &#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>然后就可以执行下方命令进行源更新 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>更新所有软件 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade -y</span><br></pre></td></tr></table></figure>
<h2 id="取消笔记本ubuntu的盒盖挂起功能">取消笔记本Ubuntu的盒盖挂起功能</h2>
<p>默认情况下, 使用笔记本安装Ubuntu, 电脑盒盖时整个系统会被挂起, 这个功能相当的扯淡, 执行以下操作可以进行修改 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/systemd/logind.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">HandleLidSwitch=<span class="built_in">suspend</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">找到上面的选项, 修改成下面的内容, 注意要删掉前面的<span class="comment">#号</span></span></span><br><span class="line">HandleLidSwitch=ignore</span><br></pre></td></tr></table></figure>
<p>保存之后执行下方命令重启服务 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service systemd-logind restart</span><br></pre></td></tr></table></figure>
<h2 id="关闭终端响铃">关闭终端响铃</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/inputrc</span><br><span class="line">set bell-style off</span><br></pre></td></tr></table></figure>
<h2 id="开启远程ssh连接">开启远程ssh连接</h2>
<p>Ubuntu20.04默认没有安装sshd, 这个时候只要在终端输入sshd, 系统会提示没有安装sshd, 是否需要安装, 并且连命令都已经提示出来了, 执行下方命令安装sshd :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-server -y</span><br></pre></td></tr></table></figure>
<p>安装到这一步, 就可以不在这台笔记本上面操作了, 可以用另一台电脑远程连接到这台电脑上面.</p>
<h2 id="安装docker">安装docker</h2>
<p>因为笔记本电脑是x86架构的, 会比树莓派, 路由器等非x86架构的设备拥有更多的docker镜像, 搭建在NAS上面的服务都是使用docker而不是直接安装到本地.</p>
<p>因为docker本身对Ubuntu的兼容性就足够好, 官方脚本里面已经默认兼容Ubuntu, 只要执行下方命令即可安装docker :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install curl</span><br><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<p>安装完成之后, 执行下方命令, 将你的所在用户加入到docker组, 这样运行docker命令就不用每次都使用sudo :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker 你的用户名</span><br></pre></td></tr></table></figure>
<p>然后重启即可使用docker.</p>
<h2 id="部署portainer服务">部署Portainer服务</h2>
<p>Portainer是一个可视化的docker容器管理平台, 使用Portainer可以很方便地对docker容器进行各种操作, 部署Portainer也很简单, 两条命令即可 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create portainer_data #创建一个portainer_data卷, 由于portainer本身存储的东西不是很重要, 哪怕没了也没关系所以就懒得本地化挂载了.</span><br><span class="line">docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br></pre></td></tr></table></figure>
<p>部署完成进入设备的IP : 9000端口即可访问Portainer.</p>
<h2 id="部署adguardhome服务">部署adguardhome服务</h2>
<p>adguardhome是一款用于去除广告的开源DNS服务软件, 用户可以在自己的设备上搭建DNS服务用于去除广告和加速访问等等, 在<a href="https://hub.docker.com/r/adguard/adguardhome">adguardhome</a>的docker hub主页可以看到它的详细信息.</p>
<p>使用下方命令就可以直接拉取adguardhome镜像 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull adguard/adguardhome</span><br></pre></td></tr></table></figure>
<p>需要注意的是, 现在还不能直接使用adguardhome提供的容器启动, 因为目前还有2个问题没有解决 :</p>
<ul>
<li>DNS服务器需要使用53端口, 但是Ubuntu自身的53端口已经被systemd-resolved占用了, 使用<code>sudo lsof -i:53</code>命令可以看到systemd-resolved正在运行中.</li>
<li>adguardhome也需要使用68端口, 但是Ubuntu自身的DHCP会占用68端口, 不过由于我们不使用adguardhome的DHCP功能, 所以可以不用管, 换成映射成69端口即可</li>
</ul>
<p>要解决第一个问题, 其实adguardhome的docker hub主页就有提示要如何操作 :</p>
<p><img src="https://i.loli.net/2020/06/16/9LDSjlIrdJhMRE8.png" /></p>
<p>简单来说, 就是 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /etc/systemd/resolved.conf.d #如果没有这个文件夹就创建一个</span><br><span class="line">sudo touch /etc/systemd/resolved.conf.d/adguardhome.conf #创建一个文件</span><br><span class="line"><span class="meta">#</span><span class="bash">写入下方内容并且保存</span></span><br><span class="line">[Resolve]</span><br><span class="line">DNS=127.0.0.1</span><br><span class="line">DNSStubListener=no</span><br><span class="line"><span class="meta">#</span><span class="bash">对/etc/resolv.conf进行备份</span></span><br><span class="line">mv /etc/resolv.conf /etc/resolv.conf.backup</span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个链接</span></span><br><span class="line">ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">重启systemd-resolved</span></span><br><span class="line">sudo systemctl restart systemd-resolved</span><br></pre></td></tr></table></figure>
<p>搞完这套操作, 再执行<code>sudo lsof -i:53</code>就看不到占用了.</p>
<p>此时执行下方命令, 即可启动adguardhome容器(注意68端口已经被换成69端口) :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name adguardhome -v /home/jiayao/Docker/adguardhome/work:/opt/adguardhome/work -v /home/jiayao/Docker/adguardhome/conf:/opt/adguardhome/conf -p 53:53/tcp -p 53:53/udp -p 67:67/udp -p 69:68/tcp -p 69:68/udp -p 80:80/tcp -p 443:443/tcp -p 853:853/tcp -p 3000:3000/tcp -d adguard/adguardhome</span><br></pre></td></tr></table></figure>
<p>如果没有报错, 就可以打开浏览器, 输入该设备的ip : 3000即可进入配置页面, 配置完成之后输入ip : 80端口即可访问adguardhome页面.</p>
<p>使用adguardhome最重要的就是添加DNS过滤器, adguardhome就是根据这些过滤器来屏蔽广告和加速网页访问的, 分享一些我在使用的配置 :</p>
<blockquote>
<p>url: https://adguardteam.github.io/AdGuardSDNSFilter/Filters/filter.txt name: AdGuard Simplified Domain Names filter url: https://cdn.jsdelivr.net/gh/neoFelhz/neohosts@gh-pages/127.0.0.1/full/hosts name: neohosts url: http://git.oschina.net/halflife/list/raw/master/ad.txt name: My AdFilters url: https://easylist-downloads.adblockplus.org/easyprivacy.txt name: EasyPrivacy url: https://raw.githubusercontent.com/jdlingyu/ad-wars/master/hosts name: ad-wars url: https://raw.githubusercontent.com/googlehosts/hosts/master/hosts-files/hosts name: googlehosts url: https://filters.adtidy.org/android/filters/11_optimized.txt name: AdGuard Mobile Ads filter (Optimized) url: https://filters.adtidy.org/android/filters/3_optimized.txt name: AdGuard Tracking Protection filter (Optimized)</p>
</blockquote>
<p>到这里adguardhome算是装完了.</p>
<h2 id="部署aria2服务">部署aria2服务</h2>
<p>对我来说搭建NAS最重要的功能就是aria2了, 依然使用docker搭建aria2服务.</p>
<p>docker hub上面关于aria2的镜像有很多, 我选择了<a href="https://hub.docker.com/r/superng6/aria2">superng6/aria2</a>, 输入下方命令即可拉取aria2镜像 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull superng6/aria2</span><br></pre></td></tr></table></figure>
<p>先执行<code>id 你的用户名</code>查看一下PUID和PGID :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=1000(jiayao) gid=1000(jiayao) 组=1000(jiayao),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare),998(docker)</span><br></pre></td></tr></table></figure>
<p>使用下方命令即可启动容器 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name=aria2 -d -v /home/jiayao/Videos:/downloads -v /home/jiayao/Docker/aria2:/config -e TZ=Asia/Shanghai -e PUID=1000 -e PGID=1000 -e SECRET=.... -e CACHE=1024M -e UpdateTracker=true -e MOVE=true -e MOVE=dmof -e SMD=true -p 6800:6800 -p 6881:6881 -p 6881:6881/udp --restart=always superng6/aria2</span><br></pre></td></tr></table></figure>
<h2 id="部署jellyfin服务">部署jellyfin服务</h2>
<p>jellyfin是一个开源的媒体系统, 在国内因为没啥在线流式服务可以使用, 所以它最常用的功能就是播放NAS上面的视频, 只要部署了jellyfin, 就可以直接在网页上面播放视频.</p>
<p>想要部署jellyfin很简单, 首先执行下方命令拉取镜像 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jellyfin/jellyfin:latest</span><br></pre></td></tr></table></figure>
<p>然后在本地创建两个文件夹config和cache</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p jellyfin/&#123;config,cache&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以开始运行启动一个jellyfin容器 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name=jellyfin -v /home/jiayao/Docker/jellyfin/config:/config -v /home/jiayao/Docker/jellyfin/cache:/cache -v /home/jiayao/Videos:/media -p 4000:8096 jellyfin/jellyfin:latest</span><br></pre></td></tr></table></figure>
<p>访问4000端口即可进入jellyfin页面.</p>
<h2 id="安装zerotier-one">安装ZeroTier One</h2>
<p>ZeroTier One是一款免费的内网穿透软件, 安装之后就可以远程访问NAS里面的视频内容, 并且免费版可以让多达一百台设备加入同一网络, 具体部署可以参考我<a href="https://jiayaoo3o.github.io/2020/06/11/%E6%AF%94frp%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7-ZeroTier%20One/">这一篇文章</a>, 可惜我的腾讯云服务器的学生优惠到期了, 1元/月的服务器没得用了, 所以也没法部署moon节点了, 可惜可惜.</p>
<h2 id="部署vlmcsd服务">部署vlmcsd服务</h2>
<p>vlmcsd是一个开源的kms服务, 本来是挂在腾讯云上面的, 结果上面说了腾讯云到期了, 也顺便部署到NAS上面吧.</p>
<p>还是使用docker, 我使用的是<a href="https://hub.docker.com/r/mikolatero/vlmcsd">mikolatero/vlmcsd</a>镜像, 使用下面命令可以拉取镜像 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mikolatero/vlmcsd</span><br></pre></td></tr></table></figure>
<p>部署非常简单, 只要暴露1688端口即可 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 1688:1688 --restart=always --name vlmcsd mikolatero/vlmcsd</span><br></pre></td></tr></table></figure>
<h2 id="部署人人影视rrshareweb服务">部署人人影视rrshareweb服务</h2>
<p>人人影视官方有一个linux版本的客户端, 虽然感觉不怎么更新了, 但是无广告, 功能还是非常好用的, 有人做成了docker版本, 我也选择部署到NAS上.</p>
<p>使用<a href="https://hub.docker.com/r/liubing/rrshareweb">liubing/rrshareweb</a>的版本, 其实docker hub上面的rrhsareweb镜像都大同小异, 都可以.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull liubing/rrshareweb</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name rrshare -d -p 3001:3001 -v /home/jiayao/Videos:/opt/work/store liubing/rrshareweb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>搭建完发现官方已经废弃这个客户端了, 登陆上去啥都看不到, 也搜索不出来数据, 可惜了.</p>
</blockquote>
<h2 id="部署qbittorrent">部署qbittorrent</h2>
<p>qbittorrent是一个bt下载器, 好用, 虽然默认界面略丑, 但是绝对当得上"拿钱办事"四个字.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name=qbittorrent -e PUID=1000 -e PGID=1000 -e TZ=Asia/Shanghai -e UMASK_SET=022 -e WEBUI_PORT=8080 -p 6881:6881 -p 6881:6881/udp -p 8080:8080 -v /mnt/disk-alpha/Docker/qbittorrent:/config -v /mnt/disk-alpha/Downloads:/downloads --restart unless-stopped linuxserver/qbittorrent</span><br></pre></td></tr></table></figure>
<h2 id="配置硬盘开机自动挂载">配置硬盘开机自动挂载</h2>
<p>因为系统是安装在240G的固态上的, 而电影都是放在1T固态硬盘上的, 所以需要让硬盘开机自动挂载, 但是惊喜的是, Ubuntu 20.04桌面版附带的"磁盘"软件是内置挂载磁盘管理功能的, 只要鼠标点击设置即可配置硬盘开机挂载, 这里就不上图了.</p>
<h2 id="部署samba服务">部署samba服务</h2>
<p>作为NAS, 肯定是要让我的另一台笔记本电脑能够访问地访问到, 所以, 所以而win下的共享就是用smb协议的, 所以需要在Ubuntu上安装samba服务, 另一个惊喜的是Ubuntu 20.04桌面版的文件管理器也能够通过右键文件夹设置共享, 第一次打开共享功能会提示让你安装samba, 后面只需要输入以下命令添加samba用户即可 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">smbpasswd -a jiayao # 这里的用户得是linux里面有的用户 </span><br><span class="line">New SMB password:  </span><br><span class="line">Retype new SMB password:</span><br><span class="line">sudo service smbd restart # 重启smbd服务</span><br></pre></td></tr></table></figure>
<p>配置完用户之后, 剩下的就不用配置了, 让文件管理器帮你配置即可, 只需要找到你想要共享的文件夹, 右键共享即可.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统后如何恢复使用scoop</title>
    <url>/2019/03/19/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E4%BD%BF%E7%94%A8scoop/</url>
    <content><![CDATA[<p>重装系统之后, 如果把原有的scoop文件夹粘贴回去user文件夹,然后在powershell中再次输入<a href="https://jiayaoo3o.github.io/2019/01/30/Windows%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8-scoop/">Windows下的软件管理神器:scoop</a>文章中的安装命令,会得到一个<strong>Scoop is already installed</strong>错误,要想正确恢复scoop,根据<a href="https://github.com/lukesampson/scoop/issues/2894">官方回答</a>,请按照以下步骤:</p>
<span id="more"></span>
<ol type="1">
<li><p>重装系统之前,先完整复制用户目录下的scoop文件夹到别的地方</p></li>
<li><p>重装系统之后,将scoop文件夹粘贴回去用户目录</p></li>
<li><p>在环境变量设置中,新建一个用户变量,名字为SCOOP,值为当前scoop文件夹的地址,即:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\xxxx\scoop</span><br></pre></td></tr></table></figure></li>
<li><p>允许脚本执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set-executionpolicy remotesigned -s currentuser</span><br></pre></td></tr></table></figure></li>
<li><p>双击用户变量中的path,新建一个路径,填入 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%SCOOP%\shims</span><br></pre></td></tr></table></figure></li>
<li><p>管理员权限powershell中运行:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scoop reset *</span><br></pre></td></tr></table></figure></li>
</ol>
<p>即可恢复所有软件的正常使用.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>scoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Mutiny入门教程</title>
    <url>/2021/07/25/Mutiny%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本篇教程想要教会你如何使用quarkus的官方响应式编程库Mutiny, 并且学会如何在quarkus下进行响应式编程.</p>
<h2 id="什么是mutiny">什么是Mutiny?</h2>
<p><a href="https://smallrye.io/smallrye-mutiny/">Mutiny</a>是一个事件驱动的, quarkus官方的java响应式编程库. 在quarkus框架中进行响应式编程开发, 指的就是通过Mutiny来包装, 观察, 处理事件所产生的数据流.</p>
<h2 id="如何学习">如何学习?</h2>
<p>接下来我会用<strong>提问-解答</strong>的方式去讲解怎么学习使用Mutiny, 只要一步步跟着问题去思考, 就可以学会使用Mutiny.</p>
<span id="more"></span>
<h2 id="unit与multit">Uni&lt;T&gt;与Multi&lt;T&gt;?</h2>
<p>理解Uni和Multi是什么, 是学习Mutiny和响应式编程中最重要的事情.</p>
<p>什么是Uni和Multi? 它们指的是<code>某个行为或动作引起的事件所产生的数据流, 泛型T表示这个数据流的数据类型</code>, 这一句话是理解整个响应式编程的重点.</p>
<h2 id="什么是事件">什么是事件?</h2>
<p>发生了某一个行为或者动作, 就可以代表为一个事件, 例如 :</p>
<ul>
<li>你<strong>点击</strong>了一下鼠标, 点击鼠标这个行为, 就是一个事件.</li>
<li>你<strong>拿起</strong>一台手机这个行为, 就是一个事件.</li>
<li>你<strong>敲击</strong>一下键盘这个行为, 就是一个事件.</li>
</ul>
<p>以上三点, 都可以概括成<strong>产生了一个"你做了某事"的事件</strong>.</p>
<h2 id="数据流又是什么呢">数据流又是什么呢?</h2>
<p>它是指某个事件所产生的结果, <strong>泛型T</strong>就是这个事件所产生的数据流的类型.</p>
<p>例如在你<strong>拿起一台手机</strong>这个事件中, 返回的结果就是一个数据流, 一个手机就可以看作是数据流里的一个数据, 所以伪代码就是 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;手机&gt; event = 你拿起一台手机;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Multi&lt;手机&gt; event = 你拿起一台手机;</span><br></pre></td></tr></table></figure>
<p>你去查找数据库, 这个事件得到一个数据类型为字符串的数据流 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; event  = 查找数据库;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Multi&lt;String&gt; event  = 查找数据库;</span><br></pre></td></tr></table></figure>
<p>又或者, 你去查找数据库, 这个事件得到一个数据类型为Long的数据流 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;Long&gt; event = 查找数据库;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Multi&lt;Long&gt; event = 查找数据库;</span><br></pre></td></tr></table></figure>
<p>又或者, 你做的这个行为没有产生什么东西, 返回一个Void的数据流 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;Void&gt; event = 做了啥事情返回一个<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Multi&lt;Void&gt; event = 做了啥事情返回一个<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>这个时候, 应该就可以理解什么是Uni和Multi了, <strong>他们就是代指某个事件所产生的数据流, 而里面的泛型就是这个数据流的类型</strong>.</p>
<p>那么到了这里, 你自然而然就会问, <strong>这个Uni和Multi有什么区别呢?</strong></p>
<p>区别就是, <strong>Uni代表着这个事件返回的数据流内有0个或1个T类型数据, 而Multi代表这个事件返回的数据流内有0个或N多个T类型数据</strong>, 根据上面的例子 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;手机&gt; event = 你拿起一台手机;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Multi&lt;手机&gt; event = 你拿起一台手机;</span><br></pre></td></tr></table></figure>
<p><strong>Uni&lt;手机&gt;</strong>代表了这个事件要么失败了, 数据流内是一个异常, 要么事件成功了, 数据流内是一个手机.</p>
<p><strong>Multi&lt;手机&gt;</strong>代表了这个事件要么失败了, 数据流内是一个异常, 要么事件成功了, 数据流内是N个 (1个或多个都可以)手机.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; event  = 查找数据库;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Multi&lt;String&gt; event  = 查找数据库;</span><br></pre></td></tr></table></figure>
<p><strong>Uni&lt;String&gt;</strong>代表了查找数据库这个事件产生的数据流要么是一个失败 (抛出异常), 要么是一个String(注意这个Stirng可能为null, 因为数据库返回的就是null, 没查到).</p>
<p><strong>Multi&lt;String&gt;</strong>代表了查找数据库这个事件产生的数据流要么是一个失败 (抛出异常), 要么是N个String(注意这个Stirng可能为null, 因为数据库返回的就是null, 没查到)</p>
<p>那你自然而然又会问, <strong>那是不是说Uni&lt;List&lt;String&gt;&gt;和Multi&lt;String&gt;是相同的的意思呢?</strong></p>
<p><strong>不是</strong></p>
<p><strong>Uni&lt;List&lt;String&gt;&gt;</strong>代表着一个数据流里面有一个元素, 这个元素是<strong>List&lt;String&gt;</strong>.</p>
<p><strong>Multi&lt;String&gt;</strong>代表着数据流里面有N个元素, 这些元素都是<strong>String</strong>类型.</p>
<p>一般情况下使用简单的Uni就已经足够了.</p>
<h2 id="uni和multi的特性">Uni和Multi的特性</h2>
<p>Uni和Multi有两个至关重要的特性, 必须要记住的 :</p>
<ol type="1">
<li>数据流是不可变的, <strong>对这个数据流的任何操作都会返回一个新的数据流</strong>.</li>
<li>对数据流的操作是惰性的, <strong>必须要有人消费 (或者表达为监听, 订阅)这个数据流, 这个对数据流的操作才会真正地发生</strong>.</li>
</ol>
<p>先来解释第一点, 这个应该比较好理解, 因为大家经常接触类似的东西, 就是String.</p>
<p>String本身一旦创建, 就是不可变的了, 对一个字符串进行修改, 都会产生一个新的字符串, 原本的旧字符串是不会改变的 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String apple = <span class="string">&quot;APPLE&quot;</span>;</span><br><span class="line">apple.toLowerCase();</span><br><span class="line">log.info(apple); <span class="comment">//肯定还是&quot;APPLE&quot;</span></span><br></pre></td></tr></table></figure>
<p>创建了一个字符串apple, 但是对它调用<code>.toLowerCase()</code>之后, 只会产生一个新字符串, 并不会改变apple本身.</p>
<p>Uni和Multi也一样, 对这个数据流进行操作之后, 就会产生一个新的Uni或者Multi :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; uni = Uni.createFrom().item(<span class="string">&quot;hello&quot;</span>);<span class="comment">//发生一个事件, 产生的数据流的结果是&quot;hello&quot;字符串</span></span><br><span class="line"></span><br><span class="line">uni.onItem().transform(item -&gt; item + <span class="string">&quot; mutiny&quot;</span>);<span class="comment">//将字符串&quot;hello&quot;变成&quot;hello mutiny&quot;</span></span><br><span class="line">uni.onItem().transform(String::toUpperCase);<span class="comment">//再将字符串全部改成大写</span></span><br><span class="line"></span><br><span class="line">uni.subscribe().with(item -&gt; System.out.println(item));<span class="comment">//打印字符串</span></span><br></pre></td></tr></table></figure>
<p>这个打印的结果是什么?</p>
<p>答案就是最开始的<code>"hello"</code>, 因为我们对最开始的事件uni做任何操作, 都只会产生一个新的流, 原本的流是不会被改变的, 如果你没有用一个变量去接着它, 那结果就不会被影响, 所以如果上面的例子想要生效, 可以有两种办法 :</p>
<ol type="1">
<li><p>要么你就一直链式调用下去 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; uni = Uni.createFrom().item(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">uni.onItem().transform(item -&gt; item + <span class="string">&quot; mutiny&quot;</span>).onItem().transform(String::toUpperCase).subscribe().with(item -&gt; System.out.println(item));</span><br></pre></td></tr></table></figure></li>
<li><p>要么你就每次都用变量接着这个流 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; uni = Uni.createFrom()</span><br><span class="line">        .item(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">uni = uni.onItem()</span><br><span class="line">        .transform(item -&gt; item + <span class="string">&quot; mutiny&quot;</span>);</span><br><span class="line">uni = uni.onItem()</span><br><span class="line">        .transform(String::toUpperCase);</span><br><span class="line">uni.subscribe()</span><br><span class="line">        .with(item -&gt; System.out.println(item));</span><br></pre></td></tr></table></figure></li>
</ol>
<p>继续解释上面的第二点, <strong>对Uni和Multi的操作是惰性的</strong>, 这是什么意思?</p>
<p><strong>这是指, 你最终必须明确表示对这个结果感兴趣, 明确地订阅了这个数据流, 对数据流的操作才会真正地发生.</strong></p>
<p>对数据流的各种操作 (即uni后面跟着的带动词的方法), 并不是真正在操作这个数据流, 而是在<strong>铺设操作数据流的流水线</strong> (脑海中想象工厂的流水线), 只有当流水线的最末尾有人订阅了这个数据流, 流水线才会真正地工作, 数据才会真正地在流水线中流动到最终的订阅者手里.</p>
<p>例如上面这个例子, <code>uni.subscribe().with(item -&gt; System.out.println(item));</code>这一行代码就表明了用户对这个uni感兴趣, 因为你想要打印这个字符串, 所以你订阅这个数据流, <strong>只有当你订阅了这个数据流, 对这个数据流的操作流水线才会工作, 才会真正进行后面的字符串拼接, 字符串转大写等操作.</strong></p>
<p>如果没有最后的这一行<code>.subscribe()</code>, 就相当于工厂的流水线都铺设好了, 但是根本没有开工, 虽然代码写着产生一个字符串数据流, 并且想要拼接字符串, 然后全部转大写, <strong>但是这一切都不会发生.</strong></p>
<p>那么有哪些行为可以表达我对这个数据流感兴趣呢?</p>
<ol type="1">
<li><p>要么直接在代码里写出来你想要<code>.subscribe()</code>这个流, 这表明你<strong>主动</strong>要订阅这个数据流.</p></li>
<li><p>要么将这个数据流最终返回到系统外部, 由系统自动帮你订阅这个消息 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GET</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uni&lt;ApiResponse&gt; <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Uni&lt;String&gt; uni = Uni.createFrom()</span><br><span class="line">            .item(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    uni = uni.onItem()</span><br><span class="line">            .transform(item -&gt; item + <span class="string">&quot; mutiny&quot;</span>);</span><br><span class="line">    uni = uni.onItem()</span><br><span class="line">            .transform(String::toUpperCase);</span><br><span class="line">    <span class="keyword">return</span> uni.chain(ApiResponse::ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个接口, 只要程序接收到外部的<strong>get</strong>请求, 调用了这个接口, 就会返回一个Uni出去, 这里你会发现虽然我们没有调用<code>.subscribe()</code>这个方法, 但是因为这里已经是系统的最外层了, 我们把uni通过接口返回出去之后, 系统就会自动帮我们订阅这个数据流.</p></li>
</ol>
<p>所以说, 当你发现你的代码不生效的时候, 一定要看看是不是自己忘记订阅了.</p>
<p>理解了这些最基本的概念, 现在我们可以开始在响应式编程的海洋里自由飞翔了.</p>
<h2 id="如何创建一个数据流">1.如何创建一个数据流?</h2>
<p>Mutiny中, 产生一个流会有两个途径 :</p>
<ol type="1">
<li><p>你手动创建了一个事件产生了一个数据流.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; appleUni = Uni.createFrom().item(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">List&lt;String&gt; appleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">appleList.add(<span class="string">&quot;apple1&quot;</span>);</span><br><span class="line">appleList.add(<span class="string">&quot;apple2&quot;</span>);</span><br><span class="line">appleList.add(<span class="string">&quot;apple3&quot;</span>);</span><br><span class="line">Multi&lt;String&gt; appleMulti = Multi.createFrom()</span><br><span class="line">        .iterable(appleList);      </span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Multi&lt;String&gt; appleMulti = Multi.createFrom()</span><br><span class="line">        .items(<span class="string">&quot;apple1&quot;</span>, <span class="string">&quot;apple2&quot;</span>, <span class="string">&quot;apple3&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面这行代码, 表明本来没有什么事情发生, 但是你手动创建了一个事件. 事件返回一个类型是String的数据流, 注意, 在Mutiny中, <strong>数据流中的数据有一个专有名词, 叫做item</strong>, 在上面的代码中, item就是一个字符串, 内容为<code>"apple"</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; appleUni = Uni.createFrom().failure(<span class="keyword">new</span> Exception(<span class="string">&quot;bad apple&quot;</span>));</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Multi&lt;String&gt; appleMulti = Multi.createFrom().failure(<span class="keyword">new</span> Exception(<span class="string">&quot;some bad apples&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>上面这行代码, 表明本来没有什么事情发生, 但是你手动创建了一个事件产生了一个数据流, 里面装着的item是一个<strong>异常</strong>.</p></li>
<li><p>你调用某些方法, 例如查找数据库引发了一个事件.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;Apple&gt; appleUni = NotificationRecordEntity.findById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码它根据id查找了仓库中id为1的苹果, 事件返回了这个数据流, 里面的item是一个<strong>Apple</strong>类.</p></li>
</ol>
<p>当你拿到了一个Uni或者一个Multi, 你就算是正式开始进入响应式编程的世界了.</p>
<h2 id="如何订阅一个数据流">2.如何订阅一个数据流?</h2>
<p>上面说到, 当产生一个数据流之后, 你必须表达出你对这个数据流感兴趣, 即你必须消费这个数据流, 对数据流的操作才会发生, 在代码中, 体现为<code>.subscribe().with()</code>方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; appleUni = Uni.createFrom().item(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">appleUni.subscribe().with(log::info);</span><br></pre></td></tr></table></figure>
<p>上面代码表明, 产生一个数据流后中间没有进行任何操作, 马上就订阅了这个数据流, 然后消费掉了, 消费的行为体现为用<code>log.info()</code>方法打印了<code>"apple"</code>这个item.</p>
<blockquote>
<p>学习响应式编程的一个前提是先得把lambda表达式和java8的stream给学明白了, 不会写起码也得懂得怎么看lambda表达式.</p>
</blockquote>
<h2 id="如何转换一个数据流中的item">3.如何转换一个数据流中的item?</h2>
<p>直到现在, 我们都一直在创建一个最简单的字符串Uni, 然后什么操作都没有进行直接就消费掉了, 但是这种行为就好比学习编程的时候打印一句<code>"hello world"</code>, 对于实际开发是没啥意义的, 所以接下来要讲的是, 当我得到一个<strong>Uni&lt;String&gt;</strong>之后, 要怎么对这个Uni的item进行变换呢?</p>
<p>这时候要使用<code>.onItem().transform()</code>方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; checkedAppleUni = appleUni.onItem()</span><br><span class="line">        .transform(apple -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(apple.equals(<span class="string">&quot;apple&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;good apple&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;bad apple&quot;</span>;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p><code>.onItem()</code>表明了你要对item进行操作, 而<code>.transform()</code>表明了你想要对item进行转换.</p>
<p>当你使用了transform后, 你需要传入一个<code>Function&lt;? super T, ? extends R&gt; mapper</code> 的lambda表达式作为入参, 这个表达式接收一个<strong>T</strong>范型, 并且返回一个你想要的<strong>R</strong>泛型,</p>
<p>上面的代码表明, 你想要对appleUni内的item进行转换, <strong>如果item等于"apple", 就将它转换成"good apple", 否则就转换为"bad apple".</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;Integer&gt; intUni = appleUni.onItem()</span><br><span class="line">        .transform(apple -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(apple.equals(<span class="string">&quot;apple&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码表明, 你不但可以将原来的item变为其他字符串, 甚至可以变为一个数字, 实际上, <strong>你可以把item转换为你想要的任何一种类型R.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multi&lt;String&gt; apples = Multi.createFrom()</span><br><span class="line">        .items(<span class="string">&quot;apple1&quot;</span>, <span class="string">&quot;apple2&quot;</span>, <span class="string">&quot;apple3&quot;</span>);</span><br><span class="line">Multi&lt;String&gt; bananas = apples.onItem()</span><br><span class="line">        .transform(apple -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;banana&quot;</span> + apple.substring(apple.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>对一个Multi内的item进行操作时, 相当于铺设了操作item的流水线, 这时候数据会一个一个通过流水线, 所以数据流中的所有元素都会进行转换, 例如上面的Multi内原本有三个字符串<code>"apple1", "apple2", "apple3"</code>, 当调用<strong>一次</strong>transform之后, 里面的item就变成了<code>"banana1", "banana2", "banana3"</code>了.</p>
<h2 id="如何在产生一个数据流之后做某些事情">4.如何在产生一个数据流之后做某些事情?</h2>
<p>一般情况下我们会在触发了一个数据流之后, 继续通过这个数据流的内容去引发另一个事件从而产生其他的数据流, 典型的例子就是通过数据库查到某张表的数据, 再通过这个数据去查找数据库的另一张关联表, 或者再去调用系统的另一个服务等, 在Mutiny中, 大致可以分成几种类型 :</p>
<ol type="1">
<li><p>对数据流直接调用某个方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; u = uni.onItem()</span><br><span class="line">    .invoke(i -&gt; System.out.println(<span class="string">&quot;Received item: &quot;</span> + i));</span><br><span class="line">Multi&lt;String&gt; m = multi.onItem()</span><br><span class="line">    .invoke(i -&gt; System.out.println(<span class="string">&quot;Received item: &quot;</span> + i));</span><br></pre></td></tr></table></figure>
<p>这个时候可以选择使用<code>.invoke()</code>方法, 这个方法允许你传入一个<code>Consumer&lt;? super T&gt; callback</code>入参, 当item准备就绪的之后就会直接调用<code>.invoke()</code>方法中的<code>Consumer</code>, 如图所示 :</p>
<p><img src="https://smallrye.io/smallrye-mutiny/assets/images/event-invoke.png" /></p>
<p>这里需要注意的是,<code>.invoke()</code>方法是同步的! 也就是说<strong>线程会阻塞</strong>在这个位置, 直到内部的方法执行完毕! 按照官方文档, <code>.invoke()</code>方法一般用于打印日志, 个人建议少用这个方法.</p></li>
<li><p>对数据流的处理触发另一个事件 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">multi.onCompletion().call(() -&gt; resource.close());</span><br></pre></td></tr></table></figure>
<p>当你想要在某个数据流处理完成时触发另一个事件, 例如在上一个事件打开了一个资源, 事件完成了想要关闭资源, 这时候就可以选择使用<code>.call()</code>方法.</p>
<p><code>.call()</code>方法可以传入一个<strong>Supplier&lt;Uni&lt;?&gt;&gt; supplier或者Function&lt;? super T, Uni&lt;?&gt;&gt; function</strong>作为入参, <code>supplier</code>意味着这个事件不需要上一个数据流的item作为入参, <code>function</code>意味着这个事件需要上一个数据流的item作为入参 (lambda基础内容), 如图所示 :</p>
<p><img src="https://smallrye.io/smallrye-mutiny/assets/images/event-call.png" /></p>
<p>但是这里需要注意的时, 和<code>.invoke()</code>不一样的是, <code>.call()</code>是<strong>异步</strong>的, <strong>不会阻塞线程</strong>, 所以在调用了<code>.call()</code>里面的方法后线程可以继续处理后面的事件.</p>
<p>如果你仔细观察上面这张图, 会发现一个事情, 就是在图的左边, 原本的item内容是<code>1, 2, 3</code>, 但是执行了<code>.call()</code>之后, 右边内容还是<code>1, 2, 3</code>, 这代表什么呢? 这代表了, <code>.call()</code>内部的事件的返回值数据流item不会替代上一个数据流item的内容! 即上游数据流根本不关心<code>.call()</code>内部的事件返回什么, 内部的事件中<strong>只有异常能够传播到外部数据流中</strong>, 也就是说, 如果后续还有事件, 它要么就只能接收到原来的item的<code>1, 2, 3</code>, 要么就只能接收到由<code>.call()</code>传播出来的异常, 至于<code>.call()</code>内部事件正常的返回值, 没人在乎.</p>
<p>从这里就能看出看出, <code>.call()</code>适合用于哪种场景了, 就是调用了某个方法, 但是不在乎方法的返回值的时候, 例如官方推荐的两个用法就是<strong>关闭资源和刷新数据</strong>. 关闭资源的时候我们只在乎有没有关闭失败, 至于close的时候返回什么对我们来说不重要.</p></li>
<li><p>对数据流的处理触发另一个事件, 并且需要另一个事件的数据流 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Uni&lt;String&gt; <span class="title">invokeRemoteGreetingService</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">Uni&lt;String&gt; result = uni</span><br><span class="line">    .onItem().transformToUni(name -&gt; invokeRemoteGreetingService(name));</span><br></pre></td></tr></table></figure>
<p>这个场景是日常使用最多的场景, 就是一个数据流要去触发另一个事件, 并且需要用到另一个事件产生的数据流item, 例如上面的例子, <code>invokeRemoteGreetingService()</code>方法是一个远程调用的函数, 它的item是一个Stirng, 而这个String对我们来说是很有价值的, 这个时候就不能用上面的<code>.call()</code>了, 需要用到<code>.onItem().transformToUni()</code>方法, 如图所示 :</p>
<p><img src="https://smallrye.io/smallrye-mutiny/assets/images/transform-to-uni.png" /></p>
<p>可以看到, 和上一张图片不同, 这里的圆圈数据流经过<code>.onItem().transformToUni()</code>流水线处理之后, 就变成了方块流水线了, 也就是说, <code>.onItem().transformToUni()</code>方法中生成的内部事件数据流会取代外部事件数据流.</p>
<p>官方觉得<code>.onItem().transformToUni()</code>太长了, 所以做了一个简短的方法叫做<code>.chain()</code>, 表示用于链式调用, 两者是等价的 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; result = uni</span><br><span class="line">    .onItem().transformToUni(name -&gt; invokeRemoteGreetingService(name));</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">Uni&lt;String&gt; result = uni.chain(name -&gt; invokeRemoteGreetingService(name));</span><br></pre></td></tr></table></figure></li>
<li><p>对Multi流的处理触发其他事件 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multi&lt;String&gt; merged = multi</span><br><span class="line">    .onItem().transformToUniAndMerge(name -&gt; invokeRemoteGreetingService(name));</span><br><span class="line"></span><br><span class="line">Multi&lt;String&gt; concat = multi</span><br><span class="line">    .onItem().transformToUniAndConcatenate(name -&gt; invokeRemoteGreetingService(name));</span><br></pre></td></tr></table></figure>
<p>当我们想要在Multi流里面调用事件时, 事情就没有这么简单了, 在前面的例子中, 都是在一个Uni流中调用其他事件, 但是由于Uni流内只有一个item, 所以并不涉及顺序问题, 但是当我们在Multi中, 就必须考虑另一个场景了, 那就是返回的结果是否要按原数据流顺序返回?</p>
<p>例如有这么一个Multi, 他的最初items是<code>["a", "b"]</code>, 现在它要调用<code>invokeRemoteGreetingService()</code>这个远程方法, 这个方法接收一个name, 返回一个item为<code>"Hello name"</code>的Uni数据流, 如下所示 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Uni&lt;String&gt; <span class="title">invokeRemoteGreetingService</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但由于网络原因, 调用这个远程方法返回的时间是不一定的, <strong>有可能后面调用的反而先返回了</strong>, 后续事件读取到的数据流就有可能是<code>["Hello b", "Hello a"]</code>, 因此需要怎么处理数据流取决于你是否需要确保返回结果是有序的, Mutiny为此提供了两种方案 :</p>
<ul>
<li><p>merge -- 合并, 它不保留顺序, 并且将产生的结果按照返回的顺序依次传给下游事件.</p></li>
<li><p>concatenate -- 串联, 它严格要求传给下游事件的结果按照原来的的顺序进行.</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multi&lt;String&gt; merged = multi</span><br><span class="line">      .onItem().transformToUniAndMerge(name -&gt; invokeRemoteGreetingService(name));</span><br><span class="line"><span class="comment">//结果为可能为[&quot;Hello b&quot;, &quot;Hello a&quot;], 也可能是[&quot;Hello a&quot;, &quot;Hello b&quot;]</span></span><br><span class="line">  </span><br><span class="line">Multi&lt;String&gt; concat = multi</span><br><span class="line">      .onItem().transformToUniAndConcatenate(name -&gt; invokeRemoteGreetingService(name));</span><br><span class="line"><span class="comment">//结果为[&quot;Hello a&quot;, &quot;Hello b&quot;], 维持原本的顺序</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="如何转换uni为multi">5.如何转换Uni为Multi?</h2>
<p>想要从Uni转换到Multi, 可以使用<code>.onItem().transformToMulti()</code>方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multi&lt;String&gt; result = uni</span><br><span class="line">    .onItem().transformToMulti(item -&gt; Multi.createFrom().items(item, item));</span><br></pre></td></tr></table></figure>
<p>该方法需要传入一个<code>Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper</code>入参, 用于指导程序如何用一个Uni的item去创建一个Multi, 上面的例子表明, 你选择直接用2个item作为入参, 创建1个Multi, 如图所示 :</p>
<p><img src="https://smallrye.io/smallrye-mutiny/assets/images/uni-transform-to-multi.png" /></p>
<p>1个圆圈的Uni通过上面的代码编程了2个圆圈的Multi.</p>
<h2 id="如何处理失败">6.如何处理失败</h2>
<p>上面的代码都是默认没有失败的, 但是在现实世界里这是不可能呢, 想象程序中所有的代码都没有<code>try-catch</code>做保护会多么的脆弱.</p>
<p>在Mutiny中, <strong>对于失败的判断必须是程序抛出异常</strong>, 而不能够自定义, 例如不能认为远程调用http请求的时候返回404状态码叫做失败, 除非手动判断如果返回状态码等于404, 就抛出异常.</p>
<p>Mutiny对于失败的处理有以下几种, 他们都是在<code>.onFailure()</code>方法上进行的 :</p>
<ul>
<li>传递到下游事件 (默认的)</li>
<li>将一个异常转换成另一个异常</li>
<li>切换到另一个备用item用于覆盖失败</li>
<li>切换到另一个备用事件用于覆盖失败</li>
<li>进行重试</li>
</ul>
<p>对于第一点, 传递到下游很容易理解, 意思就是如果你不对异常进行处理, 下游事件再用<code>.onItem().transform()</code>等方法拿到的不会是上游数据流的item, 而是一个exception.</p>
<p>对于第二点, 将一个异常转换成另一个异常也很好理解, 例如将一个普通的<code>IOException</code>异常转换成更加具体的<code>ServiceUnavailableException</code>异常:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; u = uni</span><br><span class="line">        .onFailure().transform(failure -&gt;</span><br><span class="line">                <span class="keyword">new</span> ServiceUnavailableException(failure));</span><br></pre></td></tr></table></figure>
<p>对于第三点, 通常情况下, 遇到失败了你会想用另一个事件产生的数据流数据来覆盖失败, 例如 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; u1 = uni</span><br><span class="line">        .onFailure().recoverWithItem(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">Uni&lt;String&gt; u2 = uni</span><br><span class="line">        .onFailure().recoverWithItem(f -&gt; getFallback(f));</span><br></pre></td></tr></table></figure>
<p>当uni失败的时候, 既可以直接传一个item进去替换掉失败产生的exception, 也可以传一个<code>Supplier</code>进去提供你想要的item.</p>
<p>需要注意的是, 如果是数据流Multi, 那么当对数据流中的数据进行操作时引起异常, 然后使用另一个事件产生的数据流item来覆盖失败时, 下游事件会<strong>在收到这个覆盖的item之后收到一个结束流信号</strong>, 而不会继续处理异常之后的item, 例如 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multi&lt;String&gt; apples = Multi.createFrom()</span><br><span class="line">        .items(<span class="string">&quot;apple1&quot;</span>, <span class="string">&quot;apple2&quot;</span>, <span class="string">&quot;apple3&quot;</span>);</span><br><span class="line">apples.onItem()</span><br><span class="line">        .transformToUniAndConcatenate(apple -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(apple.equals(<span class="string">&quot;apple2&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Uni.createFrom()</span><br><span class="line">                        .failure(<span class="keyword">new</span> Exception(<span class="string">&quot;bad apple&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Uni.createFrom()</span><br><span class="line">                    .item(<span class="string">&quot;hello-&quot;</span> + apple);</span><br><span class="line">        &#125;)</span><br><span class="line">        .onFailure()</span><br><span class="line">        .recoverWithItem(<span class="string">&quot;backup apple&quot;</span>)</span><br><span class="line">        .subscribe()</span><br><span class="line">        .with(log::info);</span><br></pre></td></tr></table></figure>
<p>原本的apples内有<code>"apple1", "apple2", "apple3"</code>这三个item, 后续我对这三个item进行处理, 如果item等于<code>"apple2"</code>, 那就抛出一个异常, 否则返回<code>"hello-" + apple</code>.</p>
<p>在<code>.onFailure()</code>阶段, 我又对异常进行了处理, <code>如果发现了异常, 就将item替换为一个"backup apple",</code> 这是响应式编程中很常见的处理方式, 那现在问题是, 最终对于这个apples的订阅, 打印日志应该显示什么结果呢?</p>
<p>答案是, 打印结果为 :</p>
<blockquote>
<p>hello-apple1</p>
<p>backup apple</p>
</blockquote>
<p>这是因为当apple2引发一个异常时, 整个数据流就中断了, 我们恢复失败<strong>只是将exception覆盖为指定的<code>"backup apple"</code>, 然后下游事件就接收到了一个完成信号</strong>, 不会继续往下传递<code>hello-apple3</code>了.</p>
<p>在Multi中, 你也可以在收到异常的时候直接通过<code>.recoverWithCompletion()</code>宣布数据流处理完毕, <strong>此时下游事件不会收到异常信息, 只会接收到异常之前的item</strong> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multi&lt;String&gt; apples = Multi.createFrom()</span><br><span class="line">        .items(<span class="string">&quot;apple1&quot;</span>, <span class="string">&quot;apple2&quot;</span>, <span class="string">&quot;apple3&quot;</span>);</span><br><span class="line">apples.onItem()</span><br><span class="line">        .transformToUniAndConcatenate(apple -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(apple.equals(<span class="string">&quot;apple2&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Uni.createFrom()</span><br><span class="line">                        .failure(<span class="keyword">new</span> Exception(<span class="string">&quot;bad apple&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Uni.createFrom()</span><br><span class="line">                    .item(<span class="string">&quot;hello-&quot;</span> + apple);</span><br><span class="line">        &#125;)</span><br><span class="line">        .onFailure()</span><br><span class="line">        .recoverWithCompletion()</span><br><span class="line">        .subscribe()</span><br><span class="line">        .with(log::info);</span><br></pre></td></tr></table></figure>
<p>这里和上面不一样的地方在于, 没有对异常进行覆盖, 而是直接宣布传递一个完成信号, 这时候打印的结果就是 :</p>
<blockquote>
<p>hello-apple1</p>
</blockquote>
<p>对于第四点, 当我们遇到失败的时候, 也可以直接切换到另一个数据流来覆盖失败, 如下所示 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; u = uni</span><br><span class="line">        .onFailure().recoverWithUni(f -&gt; getFallbackUni(f));</span><br><span class="line"></span><br><span class="line">Multi&lt;String&gt; m = multi</span><br><span class="line">        .onFailure().recoverWithMulti(f -&gt; getFallbackMulti(f));</span><br></pre></td></tr></table></figure>
<p>对于Multi来说, 使用<code>.recoverWithMulti()</code>会在遇到异常时直接切换到新的Multi, 例如 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multi&lt;String&gt; apples = Multi.createFrom()</span><br><span class="line">        .items(<span class="string">&quot;apple1&quot;</span>, <span class="string">&quot;apple2&quot;</span>, <span class="string">&quot;apple3&quot;</span>);</span><br><span class="line">apples.onItem()</span><br><span class="line">        .transformToUniAndConcatenate(apple -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(apple.equals(<span class="string">&quot;apple2&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Uni.createFrom()</span><br><span class="line">                        .failure(<span class="keyword">new</span> Exception(<span class="string">&quot;bad apple&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Uni.createFrom()</span><br><span class="line">                    .item(<span class="string">&quot;hello-&quot;</span> + apple);</span><br><span class="line">        &#125;)</span><br><span class="line">        .onFailure()</span><br><span class="line">        .recoverWithMulti(()-&gt;Multi.createFrom().items(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>))</span><br><span class="line">        .subscribe()</span><br><span class="line">        .with(log::info);</span><br></pre></td></tr></table></figure>
<p>当检检测到异常时, 我选择直接用一个新的Multi来替换原有的Multi, 所以这时候打印的日志就应该时 :</p>
<blockquote>
<p>hello-apple1</p>
<p>a</p>
<p>b</p>
<p>c</p>
</blockquote>
<h2 id="如何进行失败重试">7.如何进行失败重试?</h2>
<p>有一些失败是基本没有重试的必要的, 例如文件不存在抛出一个IO异常, 那很可能重试多少次都没有意义, 但是有一些失败是有重试价值的, 最典型的例子就是网络请求, 有时候网络波动可能导致失败, 但是很可能过一会儿重试了就成功了.</p>
<p>Mutiny设计上有一个让我无法理解的地方, 就是重试必须在<code>.onFailure()</code>上进行, <strong>也就是说一定得要发生失败了才能重试</strong>, 但是有很多时候想要重试并不一定是发生了失败, 例如我上面举的例子, 想要在http请求返回状态码为非200的时候进行重试, 这是是一个很常见的场景, 但是Mutiny不支持这样做, 你必须手动抛出一个异常之后才能进行重试, 我当初请问过他们团队为什么不将重试的条件作为可判断的, 他们说这是经过长时间讨论的方案😂.</p>
<p>想要进行失败重试, 你需要使用 <code>.onFailure().retry()</code>, 对于重试策略, Mutiny提供了很多种不同方案 :</p>
<ol type="1">
<li><p>马上重试 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indefinitelyUni&lt;String&gt; u = uni</span><br><span class="line">        .onFailure().retry().indefinitely();</span><br></pre></td></tr></table></figure>
<p>这个方法会在遇到失败的时候马上重试, 但是注意如果一直失败就会一直重试, 直接死循环, 所以很少使用.</p></li>
<li><p>指定重试次数 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; u = uni</span><br><span class="line">        .onFailure().retry().atMost(<span class="number">3</span>);</span><br><span class="line">Multi&lt;String&gt; m = multi</span><br><span class="line">        .onFailure().retry().atMost(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码表明你<strong>最多</strong>想要立刻重试三次.</p></li>
<li><p>带延迟的重试 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; u = uni</span><br><span class="line">        .onFailure().retry()</span><br><span class="line">        .withBackOff(Duration.ofMillis(<span class="number">100</span>))</span><br><span class="line">        .atMost(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Uni&lt;String&gt; u = uni</span><br><span class="line">        .onFailure().retry()</span><br><span class="line">        .withBackOff(Duration.ofMillis(<span class="number">100</span>), Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">        .atMost(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>一般发生错误没必要马上重试, 可以先延迟一下, <code>.withBackOff()</code>方法可以配置延迟多久之后再重试, 可以只传一个延迟参数, 例如100, 此时会延迟100ms之后再重试, <strong>并且每次重试延迟都会翻倍</strong>.</p>
<p>也可以传两个参数, 一个是初始延迟, 另一个是最大延迟, 此时<strong>每次重试延迟都会翻倍直到最大延迟</strong>.</p></li>
<li><p>带随机抖动的重试 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; uni = uni</span><br><span class="line">    .onFailure().retry()</span><br><span class="line">        .withBackOff(Duration.ofSeconds(<span class="number">1</span>)).withJitter(<span class="number">0.2</span>).atMost(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>每次增加的延迟都正好翻倍, 可能不够随机性, 所以可以使用<code>.withJitter()</code>方法, 传入一个0到1之间的抖动参数, 越接近1抖动范围越大.</p></li>
<li><p>带截止时间的重试 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; uni = uni</span><br><span class="line">    .onFailure().retry()</span><br><span class="line">        .withBackOff(Duration.ofSeconds(<span class="number">1</span>)).withJitter(<span class="number">0.2</span>).expireIn(<span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<p>有时候你不一定想写重试次数, 而是写一个<strong>持续时间</strong>或者<strong>截止时间</strong>, 如上所示, <code>.expireIn()</code>接收一个long类型的持续时间, 单位是毫秒, <code>.expireAt()</code>接收一个long类型的截至时间, 表明多久之后结束重试.</p></li>
<li><p>直到满足判断条件的重试 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uni&lt;String&gt; u = uni</span><br><span class="line">        .onFailure().retry()</span><br><span class="line">        .until(f -&gt; shouldWeRetry(f));</span><br></pre></td></tr></table></figure>
<p>有时候你就是想要一直重试到满足条件为止, 这时候你可以使用<code>.until()</code>方法, 传入一个判断条件, 直到判断返回<code>true</code>为止.</p></li>
</ol>
<h2 id="学海无涯">学海无涯</h2>
<p>到这里, Mutiny的入门教程就结束了, 不知道有多少人能看到这一篇教程, 但是我相信只要是认真看完了肯定能学会响应式编程入门, 那么接下来要干什么呢?</p>
<ol type="1">
<li>如果我哪里讲得不明白, 可以直接发送邮件向我进行询问.</li>
<li>继续去<a href="https://smallrye.io/smallrye-mutiny/guides">Mutiny官方指南</a>学习高阶知识.</li>
<li>继续去<a href="https://quarkus.io/guides/">quarkus官方指南</a>学习quarkus开发知识.</li>
<li>我的一个<a href="https://github.com/jiayaoO3O/18-comic-finder">爬虫项目</a>用到了响应式编程, 可以去看一下真正的项目是怎么使用响应式进行开发的.</li>
<li>和我一起翻译quarkus官方指南 : <a href="https://github.com/jiayaoO3O/quarkus-guides-translation">quarkus-guides-translation</a></li>
</ol>
<p><img src="https://user-images.githubusercontent.com/22891632/114197582-152e7b80-9985-11eb-9e15-5aa7ea62933c.gif" /></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Quarkus</tag>
        <tag>Mutiny</tag>
      </tags>
  </entry>
</search>
